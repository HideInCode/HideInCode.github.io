{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://hideincode.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-05-06T16:42:16.766Z","updated":"2024-05-06T16:42:16.766Z","comments":false,"path":"/404.html","permalink":"https://hideincode.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2024-05-07T09:39:13.152Z","updated":"2024-05-07T09:39:13.152Z","comments":false,"path":"about/index.html","permalink":"https://hideincode.github.io/about/index.html","excerpt":"","text":"只想过平静的生活的程序员"},{"title":"书单","date":"2024-05-06T16:42:16.766Z","updated":"2024-05-06T16:42:16.766Z","comments":false,"path":"books/index.html","permalink":"https://hideincode.github.io/books/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2024-05-06T17:47:34.535Z","updated":"2024-05-06T17:47:34.535Z","comments":false,"path":"categories/index.html","permalink":"https://hideincode.github.io/categories/index.html","excerpt":"","text":""},{"title":"项目仓库","date":"2024-05-07T09:39:55.977Z","updated":"2024-05-07T09:39:55.977Z","comments":false,"path":"repository/index.html","permalink":"https://hideincode.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-05-06T16:42:16.766Z","updated":"2024-05-06T16:42:16.766Z","comments":true,"path":"links/index.html","permalink":"https://hideincode.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-05-06T17:48:59.185Z","updated":"2024-05-06T17:48:59.185Z","comments":false,"path":"tags/index.html","permalink":"https://hideincode.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常见攻击与漏洞","slug":"basic/常见攻击与漏洞","date":"2024-04-30T16:00:00.000Z","updated":"2024-05-07T09:01:42.293Z","comments":true,"path":"2024/05/01/basic/常见攻击与漏洞/","permalink":"https://hideincode.github.io/2024/05/01/basic/%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%B8%8E%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"https://hideincode.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"safe","slug":"safe","permalink":"https://hideincode.github.io/tags/safe/"}]},{"title":"K8S集群搭建","slug":"devops/k8s","date":"2023-11-10T16:00:00.000Z","updated":"2024-05-07T09:04:03.886Z","comments":true,"path":"2023/11/11/devops/k8s/","permalink":"https://hideincode.github.io/2023/11/11/devops/k8s/","excerpt":"","text":"K8S集群搭建","categories":[{"name":"开发部署","slug":"开发部署","permalink":"https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"devops","slug":"devops","permalink":"https://hideincode.github.io/tags/devops/"}]},{"title":"Docker部署一些组件","slug":"devops/docker","date":"2023-05-06T16:00:00.000Z","updated":"2024-05-07T09:04:51.272Z","comments":true,"path":"2023/05/07/devops/docker/","permalink":"https://hideincode.github.io/2023/05/07/devops/docker/","excerpt":"","text":"docker部署部署操作 进入官网，查看manu文档 按照系统执行命令，本地虚拟机可以先yum update 安装好引擎后添加阿里云镜像加速 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://p63g7kqk.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker ​ 4. 设置开机自启动：sudo systemctl enable docker 安装docker引擎时出错：重新配置yum源 12345cd /etc/yum.repos.drm -rf !(CentOS_Base.Repo)yum update 打包成镜像运行12# docker build -f Dockerfile -t docker.io/shh/demo:v1.0 .# docker run -d --name demo -p 8080:8080 shh/demo:v1.0 Dockfile模板12345678910FROM java:8EXPOSE 8080# VOLUME 指定了临时文件目录为/tmp。# 其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmpVOLUME /tmp# 将jar包添加到容器中并更名为app.jarADD HelloDocker-0.0.1-SNAPSHOT.jar /app.jar# 运行jar包RUN bash -c &#x27;touch /app.jar&#x27;ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 安装Mysql 下载镜像：docker pull mysql:5.7 指定端口映射、文件挂载、密码后启动： 123456docker run -p 3306:3306 --name mysql \\-v /mydata/mysql/log:/var/log/mysql \\-v /mydata/mysql/data:/var/lib/mysql \\-v /mydata/mysql/conf:/etc/mysql \\-e MYSQL_ROOT_PASSWORD=root \\-d mysql:5.7 修改配置 1234567891011vi /mydata/mysql/conf/my.cnf[client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]init_connect=&#x27;SET collation_connection = utf8_unicode_ci&#x27; init_connect=&#x27;SET NAMES utf8&#x27; character-set-server=utf8collation-server=utf8_unicode_ciskip-character-set-client-handshakeskip-name-resolve 安装Redis 下载镜像：docker pull redis 启动：要先在本机生成文件后，才能挂载。 123456mkdir -p /mydata/redis/conftouch /mydata/redis/conf/redis.confdocker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \\-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \\-d redis redis-server /etc/redis/redis.conf 安装ES 镜像 12docker pull elasticsearch:7.4.2docker pull kibana:7.4.2 创建实例 1234567891011121314151617mkdir -p /mydata/elasticsearch/configmkdir -p /mydata/elasticsearch/dataecho &quot;http.host: 0.0.0.0&quot; &gt;&gt; /mydata/elasticsearch/config/elasticsearch.ymlchmod -R 777 /mydata/elasticsearch/docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \\-e &quot;discovery.type=single-node&quot; \\-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \\-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \\-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \\-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\-d elasticsearch:7.4.2# kibibna 地址要改docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.56.10:9200 -p 5601:5601 \\-d kibana:7.4.2 RabbitMQ 下载镜像：docker pull rabbitmq 运行： 1docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management 端口解释： 4369, 25672 (Erlang发现&amp;集群端口) 5672, 5671 (AMQP端口) 15672 (web管理后台端口) 61613, 61614 (STOMP协议端口) 1883, 8883 (MQTT协议端口) https://www.rabbitmq.com/networking.html","categories":[{"name":"开发部署","slug":"开发部署","permalink":"https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"devops","slug":"devops","permalink":"https://hideincode.github.io/tags/devops/"}]},{"title":"并发编程","slug":"basic/并发","date":"2023-04-30T16:00:00.000Z","updated":"2024-05-07T09:32:15.376Z","comments":true,"path":"2023/05/01/basic/并发/","permalink":"https://hideincode.github.io/2023/05/01/basic/%E5%B9%B6%E5%8F%91/","excerpt":"","text":"","categories":[{"name":"基础知识","slug":"基础知识","permalink":"https://hideincode.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"threads","slug":"threads","permalink":"https://hideincode.github.io/tags/threads/"},{"name":"concurrent","slug":"concurrent","permalink":"https://hideincode.github.io/tags/concurrent/"}]},{"title":"AC1337","slug":"algo/AC1337","date":"2022-08-07T16:00:00.000Z","updated":"2024-05-07T10:39:18.213Z","comments":true,"path":"2022/08/08/algo/AC1337/","permalink":"https://hideincode.github.io/2022/08/08/algo/AC1337/","excerpt":"","text":"AC1337 用于记录刷题的一些思路和技巧 算法可行性 数据规模 算法可接受时间复杂度 &lt;&#x3D; 10 O(n!) &lt;&#x3D; 20 O(2^n) &lt;&#x3D; 100 O(n^4) &lt;&#x3D; 500 O(n^3) &lt;&#x3D; 2500 O(n^2) &lt;&#x3D; 10^6 O(nlogn) &lt;&#x3D; 10^7 O(n) &lt;&#x3D; 10^14 O(sqrt(n)) - O(logn) - O(1) 线型处理逻辑存储已知情况 栈 单调栈，栈中元素为单调，下一个最大的元素。 成对出现的问题，用栈进行消消乐。 队列 单调队列 优先队列 树型处理逻辑回溯组合问题 无重复元素，可重复选择，组合出一个target; 下一层起点为i，这样保证只会从当前元素后开始往后选。 有重复元素，不可重复选择，组合出一个target; 排序，使得相同元素连在一起。 跳过相同元素。 从i + 1开始进入下层搜索。 排列问题 无重复元素，所有排列情况; 朴素版本(记录决策树): 无需start，需要判断元素使用情况(visited数组&#x2F;基于无重复直接在容器里面判断)。 进阶版本(交换元素): 考虑start后面的每个位置来填充start，知道start到达n;即通过交换i，start; 下一层为start+1，即下一个要填的位置; 这样[0，start]就是统计过的排列，[start+1，n-1]就是待统计的。 有重复元素，排列情况。 子集问题 组合没有顺序上的要求，只是选择上区别;排列是对顺序有要求。 无重复元素，找所有子集。 回溯:记录决策树的每一个结点即可 状态压缩:已知所有可能性，用二进制表示，记录每一这可能性;即二进制每一位表示是否选择。 有重复元素，找所有子集: 回溯:无重复情况+排序判断相邻元素去重。 状态压缩:无重复情况+排序判断相邻元素去重。即前一个元素相同但是没有被选择，那么选择当前情况必定重复。因为当前的情况之前肯定统计过了，考虑[1，2，2]的第二个2。。。 对重复元素排序处理:保证相同情况在同一层出现，出现一次就行了，后面都不再统计。 剪枝:有些时候需要贪心的先解决大的，大的搞不定小的肯定也不行。 递归玩法 定义状态 做出选择 缩小范围 上报结果 数组 前缀和 计数 双指针 二分法 找确定的目标值 猜数字 极大化极小，极小化极大。就是使得每部分的最大值最小。 这种问题的一般结构就是，多种分配情况到达分组目标，每种情况中又会有最大值，判断所有情况中的最小的最大值。 具体题目模型参考: 分割数组的最大值 也可以称之为: 根据答案二分。 旋转有序数组，旋转后分成两部分 两部分都是上升的 后部分小于前部分 利用和mid和left的值的对比，判断target处于哪个部分。 滑动窗口 1234567int i = 0;for (int j = 0; j &lt; n; j++) &#123; while (check()) &#123; i++; //记录结果 &#125;&#125; 原地哈希 O(n)时间内使得数组有序，类似于计数排序，只不过把输入数组本身当成桶。 对于每个nums[i]，放入到对应下标位置。 再次遍历，没有归位的就是缺少的值。 一般有标记法和交换法 标记法 对归位后的数字进行标记，提前把负数改成N+1 把值对应的位置上的值加上负号，即nums[nums[i] - 1] &#x3D; -abs(nums[nums[i] - 1]) 没有标记为负数的就是没有归位的，即为缺失之数 交换法： 通过交换把值放到对应下标上，比如nums[0]放入nums[nums[0]] 再次遍历找出没有放入下标的值即可 动态规划 前缀和: 前缀和其实也是一种动态规划，拥有最优子结构，用于范围求和。而且前缀和中元素一般都是递增的，可以用二分搜索。 后缀和：有些情况需要求i左边的结果和i右边的结果，来简化计算，需要同时求前缀和与后缀和。 背包问题 0-1背包：物品只能用一次，取决于选与不选。 一维空间:想明白遍历顺序，两个循环可否交换。 1234567for(int i=0;i&lt;cnt;i++)&#123; //由大到小，不可与外层交换。 for(int j=cap;i&gt;=0;j--)&#123; //求容量为j时，最大值。 dp[j]=max(dp[j]，dp[j-w[i]]+v[i]); &#125;&#125; 完全背包: 物品可以重复选择，每次选择一个一维空间:遍历顺序，循环可否交换位置。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 123456for(int i=0;i&lt;cnt;i++)&#123; //又小到大，可以交换循环位置。 for(int j=0;j&lt;=cap;j++)&#123; dp[j]=max(dp[j]，dp[j-w[i]]+v[i]); &#125;&#125; 遍历顺序与排列组合的关系：外物内容是组合，外容内物是排列。 如果求组合数就是外层for循环遍历物品个数，内层for遍历背包容量。 如果求排列数就是外层for遍历背包容量，内层for循环遍历物品个数。 多重背包:物品有次数限制 123456789for(int i = 0; i &lt; weight。length; i++) &#123; // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量 // 以上为01背包，然后加一个遍历个数 for (int k = 1; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= 0; k++) &#123; // 遍历个数 dp[j] = Math。max(dp[j]， dp[j - k * weight[i]] + k * value[i]); &#125; System。out。println(Arrays。toString(dp)); &#125;&#125; 01背包一维化理解 一维化的本质:就是把二维的每一行依次用一行表示。用新一行的结果覆盖老的结果。由于二维情况可以，计算当前行需要上一行的值。如果只保留一行的话，那么新计算的结果就要重新写入数组。这时候不能覆盖上一行已经计算好的。从左往右的覆盖的话，那么计算下个j用的就是当前的i，而非i-1。从右往左的覆盖:用的还是上一行的数据。 分组背包：每组只能选一个 回文串问题 差分数组：解决频繁范围修改，但是不用频繁查询的问题。 [i， j]范围内全部+1，使用额外数组dif[i]+1，dif[j+1]-1。 用dif数组还原修改结果。 不需要首项 123for(int i=1;i&lt;diff。length;i++)&#123; dif[i]+=dif[i-1];&#125; 需要首项 1234dif[0]=nums[0];for(int i=1;i&lt;diff。length;i++)&#123; dif[i]=dif[i-1]+nums[i];&#125; 链表 dummy节点简化代码。 快慢指针： 环形链表 两链表相交 删除重复值 翻转链表：转化为基础的翻转链表。 树 这里指的是单纯的内存意义上的物理树，和逻辑树不同。 DFS(先序，中序，后序，mirrors)，BFS 二叉搜索树的中序遍历是升序 数的直径 公共祖先问题 树的生成 插入操作基于代码模式 root。next&#x3D;f(root。next，。。。) 一般分治而成，即找到根节点后把区间缩小，逐步生成 ​ 5。 树上dp 图 物理结构 ：邻接表、临界矩阵、边的数组、父结点数组、链式向前星。 求联通分量，并查集、dfs、tarjan、Kosaraju 找环： dfs bfs 拓扑排序：依赖顺序问题 必须是有向无环图(DAG) DFS的逆后序，即把dfs的后序结果用栈保存起来。 BFS:把入度为0的先放入，然后遍历到一个结点就减少这个结点的入度。 最小生成树： Prim：点按照已经生成的森林最近的距离加入树 Kruskal：边按照权重排序加入生成树 最短路： 无权最短路：bfs 非负权重最短路：Dijstra，理解松弛操作，就是bfs加了优先队列。 负权重：Bellman-Ford，复杂度O(VE) 欧拉回路 基环内向树：图中有环，环上有些节点会有分支，形成有一个有环的树。常见解法： 用拓扑排序找出环 判断节点是在链表上，还是在环上 二分图判定 DFS 时间戳，即Tarjan相关算法。 字符串 排序问题 计数排序 分组问题，通过组号分发到数组。 基数排序 LSD 定长字符串，从右往左排序。 MSD 随机字符串，从左往右排序。 三向快排 处理有大量重复键的排序问题 常规比较排序 查询问题 Trie(字典树，前缀树) Map 子串查找 暴力法 滑动窗口 KMP 了解DFA BM RK 正则表达式 了解NFA 数据压缩 (数据都可以转成二进制，二进制流都可以理解为字符串) 双位压缩 对于DNA的4种碱基ACTG，可以用11 00 01 10 四种方式表达，但是只用两位。 游程编码(Run-Length Encoding) 首先转为二进制，将连续相同部分进行编码，如0000000000000001111111000000011111111111记成15个0，7个1，7个0，11个1，由于01交换出现，所以只对长度就行，把15 7 7 1改成二进制1111 0111 0111 1011，完成压缩。 霍夫曼(Huffman) 通过字符出现频率压缩 LZW 位运算 a | b：计算并集 a &amp; b： 求a和b的最长公共前缀后面补齐0。如1010与1000得到1000 a ^ b：不进位相加 汉明距离：x^(x-1) 最低位的1变成0。 如110 ^ (100 - 1)结果为100 lowbit: x &amp; (-x) 截断x最低位的1及其后缀，必定是2的n次幂。 如1100 &amp; (-1100）时结果为100 求子集: 求k的二进制子集，针对中的二进制为1的位开始进行减法，判断数字k的二进制子集， 像枚举(2^k-1) ~ 0一样枚举其子集 12345int sub = k;do &#123; //sub就是一个子集 sub = (sub - 1) &amp; k;&#125; while(sub != k); 去掉最后一位 | (101101-&gt;10110) | x &gt;&gt;1 在最后加一个0 | (101101-&gt;1011010) | x &lt;&lt;1 在最后加一个1 | (101101-&gt;1011011) | x &lt;&lt; 1+1 把最后一位变成1 | (101100-&gt;101101) | x or 1 把最后一位变成0 | (101101-&gt;101100) | x or 1-1 最后一位取反 | (101101-&gt;101100) | x xor 1 把右数第k位变成1 | (101001-&gt;101101，k&#x3D;3) | x or (1 &lt;&lt; (k-1)) 把右数第k位变成0 | (101101-&gt;101001，k&#x3D;3) | x and not(1 &lt;&lt; (k-1)) 右数第k位取反 | (101001-&gt;101101，k&#x3D;3) | x xor (1 &lt;&lt; (k-1)) 取末三位 | (1101101-&gt;101) | x and 7 取末k位 | (1101101-&gt;1101，k&#x3D;5) | x and (1 &lt;&lt; k-1) 取右数第k位 | (1101101-&gt;1，k&#x3D;4) | x &gt;&gt; (k-1) and 1 把末k位变成1 | (101001-&gt;101111，k&#x3D;4) | x or (1 &lt;&lt; k-1) 末k位取反 | (101001-&gt;100110，k&#x3D;4) | x xor (1 &lt;&lt; k-1) 把右边连续的1变成0 | (100101111-&gt;100100000) | x and (x+1) 把右起第一个0变成1 | (100101111-&gt;100111111) | x or (x+1) 把右边连续的0变成1 | (11011000-&gt;11011111) | x or (x-1) 取右边连续的1 | (100101111-&gt;1111) | (x xor (x+1)) &gt;&gt; 1 数学数论MOD运算 同余定理:a MOD M&#x3D;&#x3D;b MOD M 等价于 (a-b) MOD &#x3D;&#x3D; 0 a + b会溢出: (a + b) mod M &#x3D; (a mod M + b mod M) mod M 防止出现负数 +M:(a - b) % M &#x3D; (a % M - b % M + M) % M (ab)%M &#x3D; (a%M)(b%M)%M 对于MOD除法 这里要求b和M互质，且M是质数。 不能这么玩（a&#x2F;b) % M !&#x3D; ((a%M) &#x2F; (b%M)) % M 正确玩法 求逆元+费马小定理 求（a&#x2F;b) % M问题转化为 求b的逆元，即a*b^(-1)%M，此时只需求b^(-1)的值 b* b^(-1)与1模M同余 费马小定理得：M为质数时，b^(M - 1) 与1模M同余 可得b* b^(M - 2)与1模M同余 取b的逆元为b^(M-2) 最终（a&#x2F;b) % M &#x3D;&#x3D; a * pow(b，M - 2) % M，pow为求幂，可用快速幂实现。 最大公因数与最小公倍数 gcd(a，b) &#x3D;&#x3D; gcd(b，a) gcd(a，b) &#x3D;&#x3D; gcd(a-b， b) (a &gt; b) gcd(a，b) &#x3D;&#x3D; gcd(a%b， b) gcd(a，b，c) &#x3D;&#x3D; gcd(gcd(a，b)，c) gcd(ka，kb) &#x3D;&#x3D; kgcd(a，b) 最小公倍数模板 12345//lcm(a，b) = (a * b) / gcd(a，b)//先乘后除防溢出public long lcm(long a， long b) &#123; return a / gcd(a， b) * b;&#125; 组合数取余 从n中取m个元素，记为C(n， m) &#x3D; n! &#x2F; (m! * (n - m)!)，又知C(n， m) &#x3D; C(n - 1， m - 1) + C(n - 1， m); 求C(n， m) % M O(n^2) 123456789101112int M = (int)1e9+7;long C[1005][1005];void getC(int n)&#123; for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=i;j++)&#123; if(j==0 || j==i) C[i][j]=1; else C[i][j]=(C[i-1][j-1]+C[i-1][j]) % M; &#125; &#125;&#125; O(n) 123456789101112131415//逆元方法int mo = (int)1e9 + 7;long C(long n，long m)&#123; long M=0，inv[N]，mul[N]，invMul[N]; while(M&lt;=n)&#123; if(M)&#123; inv[M]=M==1?1:(mo-mo/M)*inv[mo%M]%mo; mul[M]=mul[M-1]*M%mo; invMul[M]=invMul[M-1]*inv[M]%mo; &#125; else mul[M]=1，invMul[M]=1; M++; &#125; return mul[n]*invMul[m]%mo*invMul[n-m]%mo;&#125; 如果对质数求余，可用Lucas定理在O(n)复杂度解决 12345long Lucas(long n，long m，long p)&#123; long ans=1; while(n|m)ans=ans*C(n%P，m%P)%P，n/=P，m/=P; return ans;&#125; 概率与统计 这类问题离不开随机函数 rand7生成rand10 蒙特卡洛方法之拒绝采样 (randX() - 1)*Y + randY()可以等概率的生成[1， X * Y]范围的随机数 大范围randx生成小范围randy:可用randx%y+1 x必须是y的倍数才能等概率的生成，所以如果不是倍数，那么对于生成的不符合的值要去掉。即一直循环到合适的。 水塘抽样 详见相同概率取元素 数据结构设计 栈生成队列 队列生成栈 LFU LRU 经典算法 线性筛：用于线性速度搜索n以内的质数 扫描线：矩阵相交求面积、周长、点的个数问题。 倍增：快速幂、最近公共祖先 摩尔投票法：消消乐。 计算根号2：牛顿迭代法 TopK问题 堆(优先队列) O(nlogk) 快速选择 O(n) 二叉搜索树O(nlogk) 排序 多路归并问题 快速选择 逆序对","categories":[{"name":"解题技巧","slug":"解题技巧","permalink":"https://hideincode.github.io/categories/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://hideincode.github.io/tags/algo/"}]},{"title":"模板","slug":"algo/模板","date":"2022-08-07T16:00:00.000Z","updated":"2024-05-07T08:46:03.138Z","comments":true,"path":"2022/08/08/algo/模板/","permalink":"https://hideincode.github.io/2022/08/08/algo/%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"模板距离与个数 计算数组中i到j的距离:i - j 计算数组中i到j的元素个数: i - j + 1 前缀和一维 123456//对nums.length=n求前缀和//sum[i]:[0,i-1]的和int[] sum = new int[n+1]for(int i=0;i&lt;n;i++)&#123; sum[i+1]=sum[i]+nums[i];&#125; 二维 123456//对grid[][]求前缀和,grid.length=m,grid[0].length=nfor(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; sum[i+1][j+1]=sum[i][j+1]+sum[i+1][j]-sum[i][j]+grid[i][j]; &#125;&#125; 二维异或 12345678int m = matrix.length;int n = matrix[0].length;int[][] sum = new int[m+1][n+1];for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; sum[i+1][j+1]=sum[i][j+1]^sum[i+1][j]^sum[i][j]^matrix[i][j]; &#125;&#125; 连续值分组循环模板 哨兵法: 开头定义一个哨兵,相邻比较。 1234567891011int i = 0;while(i &lt; n) &#123; int start = i; int cnt = 0 while (i &lt; n - 1 &amp;&amp; nums[i] == nums[i + 1])&#123; i++; &#125; dist= i-start; cnt = i-start+1; i += 1&#125; 标记法: 12345678//相同的标记一下for(int i=0;i&lt;n;i++)&#123; if(nums[i]%2==0)&#123; cnt++; &#125;else&#123; cnt=0; &#125;&#125; 归并排序的merge操作:合并两个有序数组123456789101112131415161718int[] aux;void merge(int[] nums,int lo,int mid,int hi)&#123; int p = lo; int q = mid+1; System.arraycopy(nums,lo,aux,lo,hi-lo+1); for(int i=lo;i&lt;hi;i++)&#123; if(p&gt;mid)&#123; nums[i]=aux[q++]; &#125;else if(q&gt;hi)&#123; nums[i]=aux[p++]; &#125;else if(nums[p]&lt;nums[q])&#123; nums[i]=nums[p]; &#125;else &#123; nums[i]=nums[q]; &#125; &#125;&#125; 辗转相除法求最大公约数123456int gcd(int p,int q) &#123; if(q == 0)&#123; return p; &#125; return gcd(q, p % q);&#125; partition操作：用于O(n)求topK或者快排。123456789101112131415//跑的快的版本,使用快慢指针.int partition(int[] a,int lo, int hi)&#123; int pivot = a[lo]; //j指向处理好的小范围. int j=lo; for(int i=lo+1;i&lt;=hi;i++)&#123; //把小的调换到前面去,i一直标记大的 if(a[i]&lt;pivot)&#123; swap(a,++j,i); &#125; &#125; //把轴放中间 swap(a,lo,j); return j;&#125; 12345678910111213141516171819//好理解的版本,使用双向指针.int partition(int[] a, int lo,int hi)&#123; int pivot = a[lo]; int i=lo+1,j=hi; while(i&lt;=j)&#123; if(a[i]&lt;=pivot)&#123; i++; continue; &#125; if(a[j]&gt;=pivot)&#123; j--; continue; &#125; swap(a,i,j); &#125; swap(a,lo,j); return j;&#125; 堆排序的heapify操作:把输入的数组构建成一个完全二叉树堆是一个选择器,能在O(logN)时间选出最值 sink(k)把下标k的元素下沉到合适位置,swim(k)把下标为k的元素上浮到合适位置，这个过程叫做堆化（heapify) 一个堆只有n&#x2F;2个父节点. buildHeap就是把小堆合成大堆的过程 insert:加到数组结尾后swim delete最大值:swap(a[0],a[n-1]),把a[n-1]删除,a[0]进行sink. 123456789101112131415161718192021222324252627282930313233//构建大根堆:把数组a构建成a[0]为最大值的堆.public void buildMaxHeap(int[] a, int n) &#123; for (int i = n / 2; i &gt;= 0; i--) &#123; //每个父节点都要尝试调整 sink(a, i, n); &#125; &#125;//自底向上堆化.private void swim(int[] a,int k)&#123; while (k &gt; 0 &amp;&amp; a[(k-1)/2]&lt;a[k]) &#123; swap(a,(k-1)/2, k); k = (k-1)/2; &#125;&#125;//自顶向下堆化: 父,左,右,选出最大为新的父节点.private void sink(int[] a, int i, int n) &#123; int l = i * 2 + 1, r = i * 2 + 2, max = i; //找出父节点,左子节点,右子节点中的最大值的下标max. if (l &lt; n &amp;&amp; a[l] &gt; a[max]) &#123; max = l; &#125; if (r &lt; n &amp;&amp; a[r] &gt; a[max]) &#123; max = r; &#125; //当前父节点不是最大值,那么就要下沉 if (max != i) &#123; swap(a, i, max); sink(a, max, n); &#125;&#125; 树状数组:单点修改与区间查询 数组的区间查询首先考虑用前缀和,但是如果修改多于查询,那么就就要用到读和写都是O(n)的树状数组. 内存中的数据结构是数组,逻辑上是一棵树. x&amp;(-x):求x的最低位的1和后面0组成的数字,俗称lowbit操作. 1234567891011121314151617181920212223242526272829//原始数组长度int n;//逻辑树int[] tree;init(int n)&#123; this.n = n; tree = new int[n+1];&#125;//求最低位1和后面的0构成的数int lowbit(n)&#123; return n &amp; (-n);&#125;//把i处值增加dvoid update(int i,int d)&#123; while(i&lt;=n)&#123; tree[i]+=d; //所有父结点都要修改 i += lowbit(i); &#125;&#125;//查询tree中[1,i]的前缀和,即原数组中[0,i-1]的和int sum(int i)&#123; int sum = 0; while(i&gt;0)&#123; sum+=tree[i]; i-=lowbit[i]; &#125;&#125; 线段树: 区间修改与区间查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 /** * 线段树（动态开点）、区间修改 **/public class SegmentTreeDynamic &#123; class Node &#123; Node left, right; //val是子节点的和，add该节点所有对应的孩子节点都应该有此更新 int val, add; &#125; private Node root = new Node(); //// 在区间 [start, end] 中更新区间 [l, r] 的值，将区间 [l, r] ➕ val public void update(Node node, int start, int end, int l, int r, int val) &#123; if (l &lt;= start &amp;&amp; end &lt;= r) &#123; node.val += (end - start + 1) * val; node.add += val; return ; &#125; int mid = (start + end) &gt;&gt; 1; pushDown(node, mid - start + 1, end - mid); if (l &lt;= mid) update(node.left, start, mid, l, r, val); if (r &gt; mid) update(node.right, mid + 1, end, l, r, val); pushUp(node); &#125; //在[start, end]中搜[l, r]的和 public int query(Node node, int start, int end, int l, int r) &#123; if (l &lt;= start &amp;&amp; end &lt;= r) return node.val; int mid = (start + end) &gt;&gt; 1, ans = 0; pushDown(node, mid - start + 1, end - mid); if (l &lt;= mid) ans += query(node.left, start, mid, l, r); if (r &gt; mid) ans += query(node.right, mid + 1, end, l, r); return ans; &#125; //修改时，自上而下修改值。 private void pushUp(Node node) &#123; node.val = node.left.val + node.right.val; &#125; //查与改时，自上而下创建和修改节点。 //leftNum表示左节点为根的子树个数，rightNum同理。 private void pushDown(Node node, int leftNum, int rightNum) &#123; if (node.left == null) &#123; node.left = new Node(); &#125; if (node.right == null) &#123; node.right = new Node(); &#125; // 根据标记add修改 if (node.add == 0) &#123; return; &#125; //左节点和 = 左节点的标记 x 节点个数 node.left.val += node.add * leftNum; //同理 node.right.val += node.add * rightNum; // 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖 node.left.add += node.add; node.right.add += node.add; //标记下传完成，删除标记。 node.add = 0; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//单点修改的线段树class SegmentTree &#123; private int[] tree; private int[] arr; public SegmentTree(int[] nums) &#123; this.arr = nums; this.tree = new int[4 * nums.length]; if(arr.length!=0)&#123; buildTree(0,arr.length-1,0); &#125; &#125; private void buildTree(int start,int end,int root)&#123; if(start==end)&#123; tree[root]=arr[start]; return; &#125; int mid = (start + end) &gt;&gt;&gt; 1; int left = 2 * root + 1; int right = 2 * root + 2; buildTree(start,mid,left); buildTree(mid+1,end,right); tree[root]=tree[left]+tree[right]; &#125; public void update(int i, int val) &#123; update(0,arr.length-1,i,val,0); &#125; private void update(int start,int end,int idx, int val, int root)&#123; if(start==end)&#123; tree[root]=val; arr[idx] = val; return; &#125; int mid = (start + end) &gt;&gt;&gt; 1; int left = 2 * root + 1; int right = 2 * root + 2; if(idx&lt;=mid)&#123; update(start,mid,idx,val,left); &#125;else&#123; update(mid+1,end,idx,val,right); &#125; tree[root]=tree[left]+tree[right]; &#125; public int sumRange(int i, int j) &#123; return sum(0,arr.length-1,0,i,j); &#125; private int sum(int start,int end,int root, int l,int r)&#123; if(l&gt;end||r&lt;start)&#123; return 0; &#125; if(l&lt;=start&amp;&amp;r&gt;=end)&#123; return tree[root]; &#125; if(start==end)&#123; return tree[root]; &#125; int mid = (start + end) &gt;&gt;&gt; 1; int left = 2 * root + 1; int right = 2 * root + 2; int left_sum=sum(start,mid,left,l,r); int right_sum = sum(mid+1,end,right,l,r); return left_sum+right_sum; &#125;&#125; 快速乘: 计算x*n12345678910111213141516private long mul(int x, int n) &#123; long result = 0; while (n &gt; 0) &#123; //最低位是1,是有用的数字,放入结果 if ((n &amp; 1) == 1) &#123; //累计结果 result += x; &#125; //计算下一位 n &gt;&gt;= 1; //x翻倍 x += x; &#125; return result;&#125; 快速幂: 计算x^n123456789101112131415161718 private long pow(int x, int n) &#123; if (n == 0) &#123; return 1; &#125; int ans = 1; while (n &gt; 0) &#123; //最低位是1,是有用的数字,放入结果 if ((n &amp; 1) == 1) &#123; //累计结果 ans *= x; &#125; n &gt;&gt;= 1;//x取平方 x *= x; &#125; return ans; &#125; 简单解释: *快速乘: ** 53 &#x3D; 5 * (11)2 &#x3D; 5 * ( (10)2 + (1)2) &#x3D; 5 * (10)2 + 5*1 &#x3D; (5 * 21 * 1 + 5 * 20 * 0) + 5 * 1&#x3D; ((5+5) * 1 + (5) * 0) +5 &#x3D; 15 快速幂: 5^3 &#x3D; 5 ^ (11)2 &#x3D; 5 ^ ( (10)2 + (1)2) &#x3D; 5^ (10)2 * 5^1 &#x3D; 5 ^ (2 * 1 + 1 * 0) * 5 &#x3D; 5 * 5 * 5 &#x3D; 125 一般用于防止爆数据,加快计算速度. 二维数组遍历方向问题 a b c d e f g h i j k l 从对角线开始,斜向遍历 ↘ ↘ ↘ 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; int m = 3; int n = 8; char[][] cs = new char[m][n]; for (int i = 0; i &lt; m * n; i++) &#123; cs[i / n][i % n] = (char) (&#x27;a&#x27; + i); &#125; for (char[] c : cs) &#123; System.out.println(c); &#125; //斜线序号,给每条斜线标个序号 for (int k = 0; k &lt; n; k++) &#123; //行坐标,每条斜线的行坐标越来越小;由于输出第一行(abc),所以是n-k; //不能是m-k,m-k只会输出m个,如果m&gt;n还好,如果m&lt;n将输出不完整. for (int i = 0; i &lt; n - k; i++) &#123; //列坐标,行坐标+斜线序号 int j = k + i; //越界检查 if (i&gt;=m||j &gt;= n) &#123; continue; &#125; System.out.print(cs[i][j]); &#125; System.out.println(); &#125;&#125; 摩尔投票法12345678910111213141516int pre = nums[0];int cnt=1;int n = nums.length;for(int i=1;i&lt;n;i++)&#123; if(nums[i]==pre)&#123; cnt++; &#125;else&#123; if(cnt==0)&#123; pre=nums[i]; cnt=1; &#125; cnt--; &#125;&#125; 二分法 存在一个数target,返回下标. 闭区间法 [left,right] 123456789101112int left=0,right=nums.length-1,mid;while(left&lt;=right)&#123; mid=(left+right)&gt;&gt;&gt;1; if(nums[mid]==target)&#123; return mid; &#125;else if(target&lt;nums[mid])&#123; right=mid-1; &#125;else&#123; left=mid+1; &#125; &#125;return -1; 返回&gt;&#x3D;target的最左位置，用于求&lt;target的个数,. 开区间法 [left,right) 1234567891011121314//第一个&gt;=target的值//返回结果可以表示有多少个元素比target小private int lowerBound(int[] arr,int target)&#123; int left=0,right=arr.length,mid; while(left&lt;right)&#123; mid=(left+right)&gt;&gt;&gt;1; if(target&lt;=arr[mid])&#123; right=mid; &#125;else&#123; left=mid+1; &#125; &#125; return left;&#125; 返回&gt;target的最左位置，用于求&lt;&#x3D;target的个数。 开区间法 [left,right) 12345678910111213//第一个&gt;target的元素.private int upperBound(int[] arr,int target)&#123; int left=0,right=arr.length,mid; while(left&lt;right)&#123; mid=(left+right)&gt;&gt;&gt;1; if(target&gt;=arr[mid])&#123; left=mid+1; &#125;else&#123; right=mid; &#125; &#125; return left;&#125; 永远有两个值的方式,用法不明待开发. 1234567891011121314151617181920212223int binarySearch(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int left = 0, right = nums.length - 1; while (left + 1 &lt; right)&#123; // Prevent (left + right) overflow int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; // Post-processing: // End Condition: left + 1 == right if(nums[left] == target) return left; if(nums[right] == target) return right; return -1;&#125; 数组的一一映射问题比如长度为n的数组里面只有[0,n-1]的元素,如果有重复的,给出重复的. 映射问题:由一一映射变成1对多映射; 利用数组能直接根据下标查询和修改值得特性,把元素归位. 重复的元素的位置不够用,只要发现已经被占,那肯定重复. 对于有序数组,删除重复元素,最多保留k位重复值问题,快慢指针.慢指针会在k+1处等着新的不同值来覆盖. 1234567int process(int[] nums, int k) &#123; int idx = 0; for (int x : nums) &#123; if (idx &lt; k || nums[idx - k] != x) nums[idx++] = x; &#125; return idx;&#125; 线性筛：O(n)筛选质数1234567891011121314151617181920212223public static List&lt;Integer&gt; getPrimes(int n) &#123; //非素数标记 boolean[] isnp = new boolean[n + 1]; List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(); //只能从2开始 for (int i = 2; i &lt;= n; i++) &#123; if (!isnp[i])&#123; primes.add(i); &#125; for (int p : primes) &#123; if (p * i &gt; n) &#123; break; &#125; isnp[p * i] = true; if (i % p == 0) &#123; break; &#125; &#125; &#125; return primes;&#125; 并查集：用于连通性问题1234567891011121314151617181920212223242526272829303132333435363738394041424344public static class UF&#123; private int[] parent; private int[] size; private int count; public UF(int n)&#123; parent = new int[n]; size = new int[n]; count=n; for(int i=0;i&lt;n;i++)&#123; parent[i]=i; size[i]=1; &#125; &#125; public void union(int p,int q)&#123; int proot = find(p); int qroot= find(q); if(proot==qroot)&#123; return ; &#125; //平衡节点个数 if(size[proot]&gt;size[qroot])&#123; parent[qroot]=proot; size[proot]+=size[qroot]; &#125;else&#123; parent[proot]=qroot; size[qroot]+=size[proot]; &#125; count--; &#125; public int find(int p)&#123; while(p!=parent[p])&#123; //路径压缩 parent[p]=parent[parent[p]]; p=parent[p]; &#125; return p; &#125; public boolean connected(int p,int q)&#123; return find(p)==find(q); &#125; public int count()&#123; return count; &#125; &#125; 字典树: 用于具有相同前缀的字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class Trie &#123; private static class Node &#123; private boolean val; private Node[] next = new Node[26]; &#125; private Node root; public void put(String key) &#123; if (root == null) &#123; root = new Node(); &#125; Node cur = root; for (int i = 0; i &lt; key.length(); i++) &#123; char c = key.charAt(i); if (cur.next[c - &#x27;a&#x27;] == null) &#123; cur.next[c - &#x27;a&#x27;] = new Node(); &#125; cur = cur.next[c - &#x27;a&#x27;]; &#125; cur.val = true; &#125; public boolean get(String key) &#123; Node cur = root; for (int i = 0; i &lt; key.length(); i++) &#123; char c = key.charAt(i); if (cur.next[c - &#x27;a&#x27;] == null) &#123; return false; &#125; cur = cur.next[c - &#x27;a&#x27;]; &#125; return cur.val; &#125; public String longestPrefixOf(String s) &#123; Node cur = root; int end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (cur.next[c - &#x27;a&#x27;] == null) &#123; break; &#125; if (cur.val) &#123; end = i; &#125; cur = cur.next[c - &#x27;a&#x27;]; &#125; return s.substring(0, end); &#125; private String shortestPrefixOf(String s)&#123; Node cur=root; for(int i=0;i&lt;s.length();i++)&#123; char c = s.charAt(i); if(cur.next[c-&#x27;a&#x27;]==null)&#123; break; &#125; cur=cur.next[c-&#x27;a&#x27;]; if(cur.val)&#123; return s.substring(0,i+1); &#125; &#125; return s; &#125; /** * 先找到prefix的结点,再以此节点开始探索所有可能. * * @param prefix * @return */ public Set&lt;String&gt; startsWith(String prefix) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); if (root == null) &#123; return set; &#125; Node cur = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; char c = prefix.charAt(i); if (cur.next[c - &#x27;a&#x27;] == null) &#123; return set; &#125; cur = cur.next[c - &#x27;a&#x27;]; &#125; startsWith(cur, prefix, set); return list; &#125; private void startsWith(Node cur, String prefix, List&lt;String&gt; trace) &#123; if (cur == null) &#123; return; &#125; if (cur.val) &#123; trace.add(prefix); &#125; //每一个字符有26种选择. for (int j = 0; j &lt; 26; j++) &#123; startsWith(cur.next[j], prefix + ((char) (j + &#x27;a&#x27;)), trace); &#125; &#125; public List&lt;String&gt; keys() &#123; return startsWith(&quot;&quot;); &#125; //s中含有通配符.,配置符合要求的值. public List&lt;String&gt; keysMatch(String s) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); keysMatch(root, &quot;&quot;, s, list); return list; &#125; private void keysMatch(Node root, String pre, String pat, List&lt;String&gt; trace) &#123; if (root == null) &#123; return; &#125; //完成匹配 if (pre.length() == pat.length()) &#123; if (root.val) &#123; trace.add(pre); &#125; return; &#125; char next = pat.charAt(pre.length()); for (int i = 0; i &lt; 26; i++) &#123; if (next == &#x27;.&#x27; || (next - &#x27;a&#x27;) == i) &#123; keysMatch(root.next[i], pre + ((char) (&#x27;a&#x27; + i)), pat, trace); &#125; &#125; &#125; public void delete(String key) &#123; delete(root, key, 0); &#125; private Node delete(Node root, String key, int d) &#123; if (root == null) &#123; return null; &#125; if (d == key.length()) &#123; root.val = false; &#125; else &#123; char c = key.charAt(d); root.next[c - &#x27;a&#x27;] = delete(root.next[c - &#x27;a&#x27;], key, d + 1); &#125; if (root.val) &#123; return root; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (root.next[i] != null) &#123; return root; &#125; &#125; return null; &#125; public int size() &#123; return size(root); &#125; private int size(Node root) &#123; if (root == null) &#123; return 0; &#125; int cnt = 0; if (root.val) &#123; cnt++; &#125; for (int i = 0; i &lt; 26; i++) &#123; cnt += size(root.next[i]); &#125; return cnt; &#125;&#125; 求子集: 二进制状态压缩后，求出所有子集。123456//求mask的二进制子集int sub = mask;while (sub ! = 0) &#123; //这个sub就是子集之一 sub = (sub - 1) &amp; mask;&#125; 求所有情况子集：对于2^n种情况遍历,根据题目描述过滤12345678for(int mask=0;mask&lt;(1&lt;&lt;n);mask++)&#123; for(int i=0;i&lt;n;i++)&#123; //根据mask判断当前情况,即检查mask每一位的情况. if(((mask&gt;&gt;i)&amp; 1) !=0)&#123; //符合mask状态 &#125; &#125;&#125; LFU Least Frequently Used,淘汰频率最少使用的,最少使用次数相同,淘汰最旧的. 要统计频率,定义一个freq变量, put或者get时+1 缓存满了,删除freq最小的key,若有多个,删除最旧的 建立freq到key的映射关系,方便根据freq找key 使用minFreq记录最小次数,方便删除 freq和key是一对多的,且key列表存在时序 删除一个key时freq+1,就是把当前key放到freq+1里面去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class LFUCache &#123; // key 到 val 的映射，我们后文称为 KV 表 HashMap&lt;Integer, Integer&gt; keyToVal; // key 到 freq 的映射，我们后文称为 KF 表 HashMap&lt;Integer, Integer&gt; keyToFreq; // freq 到 key 列表的映射，我们后文称为 FK 表 HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys; // 记录最小的频次 int minFreq; // 记录 LFU 缓存的最大容量 int cap; public LFUCache(int capacity) &#123; keyToVal = new HashMap&lt;&gt;(); keyToFreq = new HashMap&lt;&gt;(); freqToKeys = new HashMap&lt;&gt;(); this.cap = capacity; this.minFreq = 0; &#125; public int get(int key) &#123; if (!keyToVal.containsKey(key)) &#123; return -1; &#125; // 增加 key 对应的 freq increaseFreq(key); return keyToVal.get(key); &#125; public void put(int key, int val) &#123; if (this.cap &lt;= 0) return; /* 若 key 已存在，修改对应的 val 即可 */ if (keyToVal.containsKey(key)) &#123; keyToVal.put(key, val); // key 对应的 freq 加一 increaseFreq(key); return; &#125; /* key 不存在，需要插入 */ /* 容量已满的话需要淘汰一个 freq 最小的 key */ if (this.cap &lt;= keyToVal.size()) &#123; removeMinFreqKey(); &#125; /* 插入 key 和 val，对应的 freq 为 1 */ // 插入 KV 表 keyToVal.put(key, val); // 插入 KF 表 keyToFreq.put(key, 1); // 插入 FK 表 freqToKeys.putIfAbsent(1, new LinkedHashSet&lt;&gt;()); freqToKeys.get(1).add(key); // 插入新 key 后最小的 freq 肯定是 1 this.minFreq = 1; &#125; private void increaseFreq(int key) &#123; int freq = keyToFreq.get(key); /* 更新 KF 表 */ keyToFreq.put(key, freq + 1); /* 更新 FK 表 */ // 将 key 从 freq 对应的列表中删除 freqToKeys.get(freq).remove(key); // 将 key 加入 freq + 1 对应的列表中 freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet&lt;&gt;()); freqToKeys.get(freq + 1).add(key); // 如果 freq 对应的列表空了，移除这个 freq if (freqToKeys.get(freq).isEmpty()) &#123; freqToKeys.remove(freq); // 如果这个 freq 恰好是 minFreq，更新 minFreq if (freq == this.minFreq) &#123; this.minFreq++; &#125; &#125; &#125; private void removeMinFreqKey() &#123; // freq 最小的 key 列表 LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(this.minFreq); // 其中最先被插入的那个 key 就是该被淘汰的 key int deletedKey = keyList.iterator().next(); /* 更新 FK 表 */ keyList.remove(deletedKey); if (keyList.isEmpty()) &#123; freqToKeys.remove(this.minFreq); // 问：这里需要更新 minFreq 的值吗？ &#125; /* 更新 KV 表 */ keyToVal.remove(deletedKey); /* 更新 KF 表 */ keyToFreq.remove(deletedKey); &#125;&#125; LRU Least Recently Used,淘汰最近最少使用 缓存中的数据要有时序,考虑链表或者说队列 要能快速找到key对应的val,那么就是hashmap 上面两者结合,就是LinkedHashMap 1234567891011121314151617181920212223242526272829303132333435363738394041class LRUCache &#123; int cap; LinkedHashMap&lt;Integer, Integer&gt; cache = new LinkedHashMap&lt;&gt;(); public LRUCache(int capacity) &#123; this.cap = capacity; &#125; public int get(int key) &#123; if (!cache.containsKey(key)) &#123; return -1; &#125; // 将 key 变为最近使用 makeRecently(key); return cache.get(key); &#125; public void put(int key, int val) &#123; if (cache.containsKey(key)) &#123; // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; &#125; if (cache.size() &gt;= this.cap) &#123; // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); &#125; // 将新的 key 添加链表尾部 cache.put(key, val); &#125; private void makeRecently(int key) &#123; int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); &#125;&#125;","categories":[{"name":"解题技巧","slug":"解题技巧","permalink":"https://hideincode.github.io/categories/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://hideincode.github.io/tags/algo/"}]},{"title":"经典问题","slug":"algo/经典例题","date":"2022-08-07T16:00:00.000Z","updated":"2024-05-07T08:45:58.275Z","comments":true,"path":"2022/08/08/algo/经典例题/","permalink":"https://hideincode.github.io/2022/08/08/algo/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/","excerpt":"","text":"经典问题动态规划:求最值: 问题 给定目标，找到达到目标的最小（最大）成本&#x2F;路径&#x2F;总和。 答案 在当前状态之前的所有可能路径中选择最小（最大）路径，然后为当前状态添加值。 //状态转移方程 routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i] 1234567891011* ``` for (int i = 1; i &lt;= target; ++i) &#123; for (int j = 0; j &lt; ways.size(); ++j) &#123; if (ways[j] &lt;= i) &#123; dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ; &#125; &#125; &#125; return dp[target] --- [746. Min Cost Climbing Stairs Easy](https://leetcode-cn.com/problems/min-cost-climbing-stairs) [64. Minimum Path Sum Medium](https://leetcode-cn.com/problems/minimum-path-sum) [322. Coin Change Medium](https://leetcode-cn.com/problems/coin-change) [931. Minimum Falling Path Sum Medium](https://leetcode-cn.com/problems/minimum-falling-path-sum) [983. Minimum Cost For Tickets Medium](https://leetcode-cn.com/problems/minimum-cost-for-tickets) [650. 2 Keys Keyboard Medium](https://leetcode-cn.com/problems/2-keys-keyboard) [279. Perfect Squares Medium](https://leetcode-cn.com/problems/perfect-squares) [1049. Last Stone Weight II Medium](https://leetcode-cn.com/problems/last-stone-weight-ii) [120. Triangle Medium](https://leetcode-cn.com/problems/triangle) [474. Ones and Zeroes Medium](https://leetcode-cn.com/problems/ones-and-zeroes) [221. Maximal Square Medium](https://leetcode-cn.com/problems/maximal-square) [322. Coin Change Medium](https://leetcode-cn.com/problems/coin-change) [1240. Tiling a Rectangle with the Fewest Squares Hard](https://leetcode-cn.com/problems/tiling-a-rectangle-with-the-fewest-squares) [174. Dungeon Game Hard](https://leetcode-cn.com/problems/dungeon-game) [871. Minimum Number of Refueling Stops Hard](https://leetcode-cn.com/problems/minimum-number-of-refueling-stops) --- 方案计数 问题 给定一个目标，找到许多达到目标的独特方法。要分清分类计数原理,分步计数原理; 答案 总结所有可能的方法以达到当前状态。 routes[i] = routes[i-1] + routes[i-2], ... , + routes[i-k] 1234567891011* ```java for (int i = 1; i &lt;= target; ++i) &#123; for (int j = 0; j &lt; ways.size(); ++j) &#123; if (ways[j] &lt;= i) &#123; dp[i] += dp[i - ways[j]]; &#125; &#125; &#125; return dp[target] --- [70. Climbing Stairs easy](https://leetcode-cn.com/problems/climbing-stairs) [62. Unique Paths Medium](https://leetcode-cn.com/problems/unique-paths) [1155. Number of Dice Rolls With Target Sum Medium](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum) [688. Knight Probability in Chessboard Medium](https://leetcode-cn.com/problems/knight-probability-in-chessboard) [494. Target Sum Medium](https://leetcode-cn.com/problems/target-sum) [377. Combination Sum IV Medium](https://leetcode-cn.com/problems/combination-sum-iv) [935. Knight Dialer Medium](https://leetcode-cn.com/problems/knight-dialer) [1223. Dice Roll Simulation Medium](https://leetcode-cn.com/problems/dice-roll-simulation) [416. Partition Equal Subset Sum Medium](https://leetcode-cn.com/problems/partition-equal-subset-sum) [808. Soup Servings Medium](https://leetcode-cn.com/problems/soup-servings) [790. Domino and Tromino Tiling Medium](https://leetcode-cn.com/problems/domino-and-tromino-tiling) [801. Minimum Swaps To Make Sequences Increasing](https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences) [673. Number of Longest Increasing Subsequence Medium](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence) [63. Unique Paths II Medium](https://leetcode-cn.com/problems/unique-paths-ii) [576. Out of Boundary Paths Medium](https://leetcode-cn.com/problems/out-of-boundary-paths) [1269. Number of Ways to Stay in the Same Place After Some Steps Hard](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps) [1220. Count Vowels Permutation Hard](https://leetcode-cn.com/problems/count-vowels-permutation) --- 区间DP 问题 给定一组数字，考虑到当前数字以及从左侧和右侧可获得的最佳值，可以找到问题的最佳解决方案。 答案 找到每个间隔的所有最佳解决方案，并返回最佳答案。 dp[i][j] = dp[i][k] + result[k] + dp[k+1][j] 123456789101112* ```java for(int l = 1; l&lt;n; l++) &#123; for(int i = 0; i&lt;n-l; i++) &#123; int j = i+l; for(int k = i; k&lt;j; k++) &#123; dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]); &#125; &#125; &#125; return dp[0][n-1] --- [1130. Minimum Cost Tree From Leaf Values Medium](https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values) [96. Unique Binary Search Trees Medium](https://leetcode-cn.com/problems/unique-binary-search-trees) [1039. Minimum Score Triangulation of Polygon Medium](https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon) [546. Remove Boxes Medium](https://leetcode-cn.com/problems/remove-boxes) [1000. Minimum Cost to Merge Stones Medium](https://leetcode-cn.com/problems/minimum-cost-to-merge-stones) [312. Burst Balloons Hard](https://leetcode-cn.com/problems/burst-balloons) [375. Guess Number Higher or Lower II Medium](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii) --- 字符串上的DP 问题 此模式的一般问题陈述可能会有所不同，但大多数情况下会给您两个字符串，这些字符串的长度不大. 答案 这种模式中的大多数问题都需要一种可以接受O（n ^ 2）复杂度的解决方案。 // i - indexing string s1 // j - indexing string s2 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (s1[i-1] == s2[j-1]) &#123; dp[i][j] = /*code*/; &#125; else &#123; dp[i][j] = /*code*/; &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637 --- [1143. Longest Common Subsequence Medium](https://leetcode-cn.com/problems/longest-common-subsequence) [647. Palindromic Substrings Medium](https://leetcode-cn.com/problems/palindromic-substrings) [516. Longest Palindromic Subsequence Medium](https://leetcode-cn.com/problems/longest-palindromic-subsequence) [1092. Shortest Common Supersequence Medium](https://leetcode-cn.com/problems/shortest-common-supersequence) [72. Edit Distance Hard](https://leetcode-cn.com/problems/edit-distance) [115. Distinct Subsequences Hard](https://leetcode-cn.com/problems/distinct-subsequences) [712. Minimum ASCII Delete Sum for Two Strings Medium](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings) [5. Longest Palindromic Substring Medium](https://leetcode-cn.com/problems/longest-palindromic-substring) --- ### 0-1背包问题* 问题 * 考虑使用和不使用当前状态的,做出你的选择* 答案 * 如果决定选择当前值，请使用先前的结果（忽略该值）； 反之亦然，如果您决定忽略当前值，请使用使用值的先前结果。 * ```java // i - indexing a set of values // j - options to ignore j values for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= k; ++j) &#123; dp[i][j] = max(&#123;dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]&#125;); dp[i][j-1] = max(&#123;dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]&#125;); &#125; &#125; --- [198. House Robber Easy](https://leetcode-cn.com/problems/house-robber) [121. Best Time to Buy and Sell Stock Easy](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock) [714. Best Time to Buy and Sell Stock with Transaction Fee Medium](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) [309. Best Time to Buy and Sell Stock with Cooldown Medium](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown) [123. Best Time to Buy and Sell Stock III Hard](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii) [188. Best Time to Buy and Sell Stock IV Hard](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv) --- 经典例题LIS：最长递增子序列 LCS：最长公共子串 MSA：最大和子数组 LPS：最长回文子串 ​ 常见面试思路题目 如何从大量的 URL 中找出相同的 URL？ 如何从大量数据中找出高频词？ 如何找出某一天访问百度网站最多的 IP？ 如何在大量的数据中找出不重复的整数？ 如何在大量的数据中判断一个数是否存在？ 如何查询最热门的查询串？ 如何统计不同电话号码的个数？ 如何从 5 亿个数中找出中位数？ 如何按照 query 的频度排序？ 如何找出排名前 500 的数？ 讲讲大数据中 TopK 问题的常用套路？","categories":[{"name":"解题技巧","slug":"解题技巧","permalink":"https://hideincode.github.io/categories/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://hideincode.github.io/tags/algo/"}]},{"title":"网络","slug":"basic/网络","date":"2022-07-06T16:00:00.000Z","updated":"2024-05-07T09:00:24.034Z","comments":true,"path":"2022/07/07/basic/网络/","permalink":"https://hideincode.github.io/2022/07/07/basic/%E7%BD%91%E7%BB%9C/","excerpt":"","text":"网络浏览器输入网址到展示内容发生了什么？ DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索⾃身的 DNS 缓存、搜索操 作系统的 DNS 缓存、读取本地的 Host ⽂件和向本地 DNS 服务器进⾏查询等。对于向本地 DNS 服务器进⾏ 查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有 权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此⽹址映射关系，则调⽤这 个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该⽹址映射关系，那 么将根据其设置发起递归查询或者迭代查询； TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建⽴链接，发起三次握⼿； 发送 HTTP 请求：TCP 连接建⽴起来后，浏览器向服务器发送 HTTP 请求； 服务器处理请求并返回 HTTP 报⽂：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进⾏处 理，并将处理结果及相应的视图返回给浏览器； 浏览器解析渲染⻚⾯：浏览器解析并渲染视图，若遇到对 js ⽂件、css ⽂件及图⽚等静态资源的引⽤，则᯿复 上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染⻚⾯，最终向⽤户呈现⼀个完整的 ⻚⾯。 连接结束。 三次握手 闭上眼睛再背一边 什么握手要三次？需要客户端确认服务端的收发能力 也需要服务端确认客户端的收发能力 四次挥手 背 为什么要挥手四次？需要确认断开 这里客户端最后一次发送后会进入TIME_WAIT状态，需要保证服务端收到ACK报文。 没有收到的话服务端会重新发送FIN报文。 HTTPpost与get的区别 使用场景：get获取资源，post传输对象 参数：get请求需要编码，post可以用中文。 安全性：get是安全的，post不是。 幂等性：get是幂等的，post不是。 可缓存： 请求报文方法：get可缓存，post多数情况下不可缓存。 响应报文状态码：可缓存。 响应报文的Cache-Control首部字段没有指定不进行缓存。 不同版本的区别 http1.0:不能长连接，只能短连接。打开需要connection:keep-alive; http1.1:可以长连接，多个http请求服务器也只能一个个响应。默认长连接， http2.0:多路复用，把报文分解成更小的二进制帧传送，不用http报文可以混合在一个TCP连接上传输。 与HTTPS的区别 开销：HTTPS要用到CA申请证书，一般免费证书很少，需要花钱。 资源消耗：HTTP明文传输；HTTPS加密传输，占用更多CPU和内存。 端口不同：HTTP80；HTTPS443； 安全性：HTTP简单的无状态协议；HTTPS是TSL+HTTP进行加密传输、身份认证的网络协议、更安全。 HTTPS的工作流程 客户端发送加密规则给服务端告诉服务端要进行连接了。 服务器重中选出一套加密算法和hash算法以及自己的身份信息一证书的形式发送给浏览器。一般包括：服务器信息、加密公钥、整数的办法机构。 客户端收到证书后 验证证书的合法性 通过后，生成一串随机数，对证书的公钥进行加密。 用约定好的hash算法计算握手信息，然后用生成的密钥加密，一起发给服务器。 服务接受到信息后 用私钥解析处密码，用密码解析握手信息，验证hash和浏览器发来的是否一致 使用密钥加密 如果hash一致，握手成功。 TCP与UDP的区别TCP： 面向连接的运输层协议：传数据前必须先建立通道。 一个TCP只能有两个端点，一一映射。 可靠：不重、不漏、不错、有序。 双全工通信。 面向字节流。 UDP: 1. 无连接传输层协议 1. 尽力而为传输，不可靠。 1. 面向报文的，对应用层的报文不合并、不拆分，保留报文边界。 1. 没有拥塞机制，不会降低发送效率。 1. 可以一对一、一对多、多对多。 1. 首部开销小，只有8字节。 对比： TCP可靠，UDP不可靠。 TCP面向连接，UDP无连接。 TCP有序，UDP无序。 TCP不保存数据边界，UDP保存数据边界。 TCP传输较慢。 TCP拥有流量控制和拥塞控制，UDP没有。 TCP比较重量级。 TCP首部20字节，UDP首部8字节。 五层网络协议应用层 http ftp：文件传输 smtp：简单邮件传输 dns：域名系统 ssh：安全外壳 dhcp：动态主机配置 telnet：远程登录 传输层 tcp：传输控制协议 udp：用户数据报文协议 网络层 ip：网际协议 arp：地址转换协议 IP与物理地址的映射，如果发送数据包时能找到此映射就直接使用对应MAC地址，否则就直接广播出去。 rarp：反向地址转换协议 icmp：Internet控制报文协议 igmp：Internet组管理协议 rip：路由信息协议 ospf：分布式链路状态协议 bgp：边界网关协议 数据链路层 arq：自动重传请求协议 csma&#x2F;cd：停止等待协议 ppp：点对点协议 物理层 中继器 集线器 网线 HUB 滑动窗口粘包问题TCP传输时，一个数据包包含了发送端发送的两个数据包信息，就叫粘包。 具体的可分为发送方粘包和接收方粘包。 发送方粘包 TCP长连接时，当发送数据包过于小时，会启用Nagle算法，将小包和并发送，在缓冲区进行，发送出来就是粘包的。 接收方粘包 接收方接到数据，传输层的TCP会将数据包放到缓冲区，然后由应用层来获取。如果这时候应用层读取函数不能及时把缓冲区数据拿出来，那下一个数据又会补充道缓冲区末尾，形成粘包。 如何解决粘包 特殊字符控制 在包头添加数据包的长度 如果使用netty的话，可以有专门的编码器和解码器来解决这个问题。 UDP不会有粘包问题，UDP会丢包和乱序。 数字签名为了避免数据在传输过程中被替换，⽐如⿊客修改了你的报⽂内容，但是你并不知道，所以我们让发送端做⼀个数 字签名，把数据的摘要消息进⾏⼀个加密，⽐如 MD5，得到⼀个签名，和数据⼀起发送。然后接收端把数据摘要 进⾏ MD5 加密，如果和签名⼀样，则说明数据确实是真的。 数字证书对称加密中，双⽅使⽤公钥进⾏解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥 也被替换，则仍然可以伪造数据，因为⽤户不知道对⽅提供的公钥其实是假的。所以为了保证发送⽅的公钥是真 的，CA 证书机构会负责颁发⼀个证书，⾥⾯的公钥保证是真的，⽤户请求服务器时，服务器将证书发给⽤户，这 个证书是经由系统内置证书的备案的。 安全问题 sql注入 xss","categories":[{"name":"基础知识","slug":"基础知识","permalink":"https://hideincode.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"socket","slug":"socket","permalink":"https://hideincode.github.io/tags/socket/"}]},{"title":"Zookeeper","slug":"system/Zookeeper","date":"2022-02-28T16:00:00.000Z","updated":"2024-05-07T08:57:47.486Z","comments":true,"path":"2022/03/01/system/Zookeeper/","permalink":"https://hideincode.github.io/2022/03/01/system/Zookeeper/","excerpt":"","text":"Zookeeper 用于协调分布式组件，包括配置管理、名字服务、分布式锁、集群管理。","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"system design","slug":"system-design","permalink":"https://hideincode.github.io/tags/system-design/"}]},{"title":"MySQL","slug":"system/Mysql","date":"2021-10-23T16:00:00.000Z","updated":"2024-05-07T08:56:17.814Z","comments":true,"path":"2021/10/24/system/Mysql/","permalink":"https://hideincode.github.io/2021/10/24/system/Mysql/","excerpt":"","text":"MySQL 伟大滴麦色可友，养活互联网企业的神器。 组成结构架构 server层 连接器：管理链接，权限验证 查询缓存：命中直接返回 分析器：词法分析，语法分析 优化器：执行计划生成，索引选择 执行器：操作引擎，返回结果 引擎层：操作引擎，返回结果。 redo-log WAL：Write-Ahead Logging crash-safe innodb 物理日志：在数据页上做的修改 循环写 bin-log server层，意味着所有引擎可以用 逻辑日志：语句原始逻辑，给ID&#x3D;2的字段c加1 追加写 两段式提交 redolog进入prepare 写入binlog 提交事务 索引B+树 为什么选B+树？ 选了B+而不用B树，是因为B树在每个节点都存储数据，而B+树只会在叶子节点存储数据，所以B树IO会更频繁；数据库的索引是存在磁盘上的，当数据量大时，就不能全部加载到内存，只能逐一加载。 基于B树实现，具有B树的平衡性； 索引特性 回表 索引覆盖 最左前缀原则 索引下推 事务基本性质 原子性(Atomicity) 事务的所有操作只有成功和失败,操作期间不会去对数据库数据进行增删改操作,只记录操作,只有commit后才会去修改数据库的数据.事务失败就会rollback,数据不会有任何变化. 一致性（Consistency） 会话的双方要同时进行的DML操作,使得事务执行后数据库从一个一致性状态变到另一个一致性状态. 隔离性（Isolation） 事务之间是相互独立的两个对象,可以设置不同的隔离级别. 持久性（Durability） 事务终结的标志,提交后的事务将会永久性改变数据库的数据. 隔离级别 read uncommitted -&gt;脏读 这种隔离级别下 两个事务A B,A 没有提交数据 ,B 读到了A没有commit的数据(事务A正在操作的数据),这种数据叫做dirty data,这种行为叫做dirty read,一般只在理论上存在; read committed -&gt; 不可重复度 两个事务A B,A提交数据,B就读到A的数据,这种隔离级别的缺点就是不可重复度,即会话双方一方修改,一方读取,总是读取不到正确数据.不可重复读的重点是修改. repeatable read -&gt; 幻读 看这名字就知道就是来解决无法重复读的问题的.事务A开始时,不管事务BCD修改数据还是提交事务,都不会改变A读取的数据.幻读:幻读是指当事务不是独立执行时发生的一种现象.事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。这时候事务A的用户发现表中还存在没有修改的数据行,就像出现了幻觉一样. serializable -&gt; 效率低 不会出现上述问题,但由于进行了锁表操作,所以会降低吞吐量.解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表. 隔离的原理多版本并发控制MVCC 锁全局锁 一般全库逻辑备份时会用到 FlushTablesWithReadLock：库进入只读，阻塞DML，DDL，未提交的更新事务。故障时会释放锁。 set global readlonly&#x3D;true：用于主备库判断，故障时数据库不会释放锁。 表锁 lock tables … read&#x2F;write 客户端断开自动释放 元数据锁：metadata lock：访问表时自动开启，修改表结构时加MDL锁； 给小表安全加字段： kill长事务 alter table语句加等待时间，过期放弃。 行锁 innodb特有 死锁与死锁检测： 循环依赖导致 等到超时：innodb_lock_wait_timeout 主动检测：innodb_deadlock_detect&#x3D;on，缺点影响性能。 减小主动检测的性能影响： 控制并发度，一行只能十个线程，但是客户端过多还是不行。 设计层面优化，把记录拆分多条，然后算多个记录的和。 常见表结构设计表设计三大范式 范式只是一种参考，实际生产要考虑索引问题、联表查询效率问题。 列不可分 一列不可有两种属性 比如地址可分为省、市、区三个字段 在范式1的基础上，所有的非主键字段要完全依赖主键，不是依赖主键的某一部分（针对联合主键） 出现了多对多关系 例如一张表存学生和课程 新增一个学生，该学生还没有选课，因此就不能新增。新增老师同理。 一个表只描述一件事情 在范式2基础上，所有非主键字段和主键字段没有传递依赖 出现一对多关系 例如一张表存老师和学生 修改老师职称时要改很多数据（修改一影响多） 没人选该老师课程时，该老师职称记录会被删除。（多没了代表了一也没了，不合理） 新老师还没指定职称，那么职称不知如何保存。 一对多出现时考虑：一和多分成两张表，多表存一表主键， SQL命令使用常识 count：count(字段)&lt;count(id)&lt;count(1)约等count(*) order by： sort_buffer_size：排序内存大小，如果太小就利用临时文件排序。 rowid排序：如果要返回字段过多，只取出排序字段。 如果内存够，就用内存排序。 join: 正确选择驱动表，驱动表走全表扫描，被驱动表走数索引。 使用join语句，性能比强行拆成多个单表执行SQL语句的性能好。 如果使用join，需要使用小表做驱动。 常见疑难杂症 普通索引和唯一索引怎么选？ 读：区别不大 写： change buffer：缓存更新操作，唯一索引不能用，只有普通索引可以用。如果更新后马上查询，不要用这个。redolog节省随机写磁盘的io消耗，changebuffer节省对应读的io消耗。 唯一索引：判断冲突 普通索引：更新记录在changebuffer 怎么给字符串加索引？ mysql为什么会抖一下？ 内存脏页：内存数据和磁盘数据不一样时，内存页就是脏页。 为什么表数据删除一半，表文件大小不变？ delete结果不会变，alter table才会改变。 为什么逻辑相同的语句，性能缺差异巨大？ 条件字段函数操作 隐式类型转换 隐式字符编码转换 查一行也很慢？ 查询长时间不返回：锁表了，通过show processlist查看状态。 等DML锁：show processlist查看wait for table metadata lock 等flush 幻读有什么问题吗？ 鸩止渴的提高性能？ 先处理占着链接但是不工作的线程 减少链接过程的消耗 慢查询性能问题 索引没有设计好 语句没写好 QPS突增问题 如何保证数据不丢？ binglog写入机制 redolog写入机制 保证主备一致？ 涉及到binlog可选 statement row mixed 怎么保证高可用？ 主备延迟 备库机器差劲 备库压力大 大事务 可靠性优先策略 备库为什么会延迟几个小时？ 5.5版本并行复制策略 按表分发 按行分发 5.7并行复制策略 5.7.22并行复制策略 主库出问题，从库怎么办？ 基于位点的主备切换 基于GTID的主备切换 读写分离有哪些坑？ 主备延迟导致的读写分离 强制走主库 sleep 判断主备无延迟 通过seconds_behind_master 位点比对 GTID semi-sync半同步复制 判断数据库是不是出问题？ select 1 查表判断 更新判断 内部统计 误删数据怎么办？ 删除行 删除库&#x2F;表 为什么有些命令kill不掉？ kill query + 线程id kill connection + 线程id 关于客户端的误解：表多就慢 查大量数据会不会打爆内存？ 全表扫描对server层影响：先装net_buffer，满了就输出，边读边发。 全表扫描对innodb的影响 为什么临时表可以重名？ create temporary table 创建临时表 创建的临时表只能被当前session访问 可以与普通表重名，优先访问临时表，show tables不显示临时表。 何时会用到临时表？ union执行流程 group by innodb虽然厉害，那么memory还用不用？ innodb索引组织表 有序存放 有空位也会写入新位置 数据位置变化只要修改主键索引 通过主键就一次，普通索引要两次 memory堆组织表 按照写入顺序存放 有空位就插入 位置变化要修改所有索引 查找时一视同仁 怎么快速复制一张表？ sqldump方法：生成包含insert语句的方法，可以在where参数里面加过滤，不能join 导出csv 物理拷贝：最快、必须全表拷贝、需要到机器上拷贝，在用户登录数据库的场景下无法使用，都得是innodb grant之后要跟着flushprivileges吗？ 要不要分区分表？ 自增ID用完怎么办？ 表定义自增id：用完会冲突，可以增加范围biginit unsigned。 innodb系统自增row_id： 不显示指定主键时，系统隐式自带。 用完就会重零开始覆盖 xid 作用于事务：这是redo log和binglog配合使用的id 不要在binlog重复 innodb trx_id：每次随着mysql重启会被保存起来。 thread_id 练习初始化SQL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748drop table if exists dept;drop table if exists salgrade;drop table if exists emp; create table dept( deptno int(10) primary key, dname varchar(14), loc varchar(13) ); create table salgrade( grade int(11), losal int(11), hisal int(11) ); create table emp( empno int(4) primary key, ename varchar(10), job varchar(9), mgr int(4), hiredate date, sal double(7,2), comm double(7,2), deptno int(2) ); insert into dept(deptno,dname,loc) values(10,&#x27;ACCOUNTING&#x27;,&#x27;NEW YORK&#x27;);insert into dept(deptno,dname,loc) values(20,&#x27;RESEARCHING&#x27;,&#x27;DALLAS&#x27;);insert into dept(deptno,dname,loc) values(30,&#x27;SALES&#x27;,&#x27;CHICAGO&#x27;);insert into dept(deptno,dname,loc) values(40,&#x27;OPERATIONS&#x27;,&#x27;BOSTON&#x27;); insert into salgrade(grade,losal,hisal) values(1,700,1200);insert into salgrade(grade,losal,hisal) values(2,1201,1400);insert into salgrade(grade,losal,hisal) values(3,1401,2000);insert into salgrade(grade,losal,hisal) values(4,2001,3000);insert into salgrade(grade,losal,hisal) values(5,3001,5000); insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7369,&#x27;SIMITH&#x27;,&#x27;CLERK&#x27;,7902,&#x27;1980-12-17&#x27;,800,null,20);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7499,&#x27;ALLEN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-02-20&#x27;,1600,300,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7521,&#x27;WARD&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-02-22&#x27;,1250,500,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7566,&#x27;JONES&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-04-02&#x27;,2975,null,20);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7654,&#x27;MARTIN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-09-28&#x27;,1250,1400,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7698,&#x27;BLAKE&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-05-01&#x27;,2850,null,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7782,&#x27;CLARK&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-06-09&#x27;,2450,null,10);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7788,&#x27;SCOTT&#x27;,&#x27;ANALYST&#x27;,7566,&#x27;1987-04-19&#x27;,3000,null,20);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7839,&#x27;KING&#x27;,&#x27;PRESIDENT&#x27;,null,&#x27;1981-11-17&#x27;,5000,null,10);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7844,&#x27;TURNER&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-09-08&#x27;,1500,null,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7876,&#x27;ADAMS&#x27;,&#x27;CLERK&#x27;,7788,&#x27;1987-05-23&#x27;,1100,null,20);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7900,&#x27;JAMES&#x27;,&#x27;CLERK&#x27;,7698,&#x27;1981-12-03&#x27;,950,null,30);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7902,&#x27;FORD&#x27;,&#x27;ANALYST&#x27;,7566,&#x27;1981-12-03&#x27;,3000,null,20);insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values(7934,&#x27;MILLER&#x27;,&#x27;CLERK&#x27;,7782,&#x27;1982-01-23&#x27;,1300,null,10); 每个部门薪水最高的人员名称 123456789SELECT e.ename NAME, t.maxsal, d.dname deptname FROM emp e JOIN ( SELECT deptno, max( sal ) maxsal FROM emp GROUP BY deptno ) t ON t.deptno = e.deptno AND t.maxsal = e.sal JOIN dept d ON t.deptno = d.deptno; 薪水在部门平均水平以上的人 12345select e.ename name,e.deptno,e.salfrom emp e join (select deptno,avg(sal) avgsal from emp group by deptno) t on e.sal &gt; t.avgsal and t.deptno=e.deptno; 取得部门中的平均薪水等级(所有人) 1234select t.deptno deptno,s.grade grade from (select deptno, avg(sal) avgsal from emp group by deptno) t join salgrade s on t.avgsal between losal and hisal; 取得部门中所有人的薪水等级,并对部门薪水等级求平均 1select t.dept, avg(t.grade) avg_grade from (select e.deptno dept,e.ename name,e.sal salary,s.grade grade from emp e join salgrade s on e.sal between s.losal and hisal) t group by t.dept; 也可以 1select e.deptno dept,avg(s.grade) from emp e join salgrade s on e.sal between s.losal and hisal group by e.deptno; 不用聚合函数max,取得最高薪水,使用两种方法解决 select ename,sal from emp order by sal desc limit 1; select sal from emp where sal not in (select distinct a.sal sal_a from emp a join emp b on a.sal &lt; b.sal); 取得平均薪水最高的部门的部门编号(2种方案) 可能有相等数据,取第一个可能会错误,所以要根据deptno找到重复的max select deptno,avg(sal) as avgsal from emp group by deptno having avg(sal) = (select avg(sal) avgsal from emp group by deptno order by avgsal desc limit 1); 1234567891011122. 聚合函数max ```mysql select deptno,avg(sal) avgsal from emp group by deptno having avg(sal) = (select max(t.avgsal) from (select deptno,avg(sal) avgsal from emp group by deptno ) t); 取得平均薪水最高的部门的部门名称 1234567891011121314select d.dname,m.avgsalfrom dept djoin (select deptno,avg(sal) avgsalfrom empgroup by deptnohaving avg(sal) = (select max(t.avgsal) from (select deptno,avg(sal) avgsal from emp group by deptno ) t)) m on m.deptno=d.deptno; 求平均薪水的等级最高的部门名称 求各个部门平均薪水的等级(结果只有部门名称.平均薪水,等级三个字段) 1234select t.avgsal,s.grade,t.dname from (select d.dname dname,avg(e.sal) avgsal from emp e join dept d on e.deptno=d.deptno group by dname) tjoin salgrade son t.avgsal between s.losal and s.hisal; 获取最高等级值 1234select max(s.grade) from (select deptno,avg(sal) avgsal from emp group by deptno) tjoin salgrade son t.avgsal between s.losal and s.hisal; 联合上两张表 给出avgsal,dname,grade,满足平均值为最大值 123456789select t.avgsal,s.grade,t.dname from (select d.dname dname,avg(e.sal) avgsal from emp e join dept d on e.deptno=d.deptno group by dname) tjoin salgrade son t.avgsal between s.losal and s.hisalwhere s.grade=(select max(s.grade) from (select deptno,avg(sal) avgsal from emp group by deptno) tjoin salgrade son t.avgsal between s.losal and s.hisal); 取得比普通员工(员工代码没有在mgr字段上出现的)的最高薪水还要高的姓名 先找到普通员工(注意not in (不能有null))select * from emp where empno not in (select distinct mgr from emp where mgr is not null); 2. 找出普通员工最高薪水 select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null); 找出薪水高于1600 12select ename ,sal from emp where sal &gt; (select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null)); ​ 补充学习: select ename,sal,(case job when &#39;manager&#39; then sal * 0.8 when &#39;salesman&#39; then sal*1.5 end) newsal from emp; 取得薪水最高的前五 取得薪水最高的第六名到第十名 取得最后入职的5名员工 取得每个薪水等级有多少个员工 12345select e.ename, e.sal, s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;select t.sgrade ,count(*) from (select e.ename, e.sal, s.grade sgrade from emp e join salgrade s on e.sal between s.losal and s.hisal) t group by t.sgrade;select count(*), s.grade from emp e join salgrade s on e.sal between s.losal and s.hisalgroup by s.grade; 列出所有员工和领导的名字 列出所有的领导,not in 领导就是员工(自连接) 12select distinct a.empno,a.ename,b.mgr from emp a join emp b on a.empno =b.mgr;-- 所有的领导select ename from emp where ename not in (select distinct a.ename from emp a join emp b on a.empno =b.mgr); 找出入职日期早于其直接领导的员工编号,姓名,部门名称 12345678910111213141516171819SELECT t.adno, t.aname, d.dname FROM ( SELECT a.empno eno, a.ename aname, a.hiredate ahdate, a.deptno adno, b.hiredate bhdate FROM emp a LEFT JOIN emp b ON a.mgr = b.empno ) t JOIN dept d ON d.deptno = t.adno WHERE t.ahdate &lt; t.bhdate 1234-- 老司机做法选出员工直接老板和各自的入职日期,通过where筛选 select a.empno aempno, a.ename aename,d.dname ddname, b.empno bempno, b.ename bename from emp a join emp b on a.mgr = b.empno join dept d on d.deptno = a.deptno where a.hiredate&lt;b.hiredate; 列出部门名称和这些部门员工信息,同时列出没有员工的部门select d.dname,e.* from emp e right join dept d on e.deptno=d.deptno order by d.dname asc; 列出至少有5个员工的所有部门(什么这里select后可以有groupby没有的东西)select dept.*,emp.deptno,count(*) from emp join dept on emp.deptno = dept.deptno group by dept.deptno having count(*) &gt;=5; 列出薪资比simith高的员工的个人信息select * from emp where sal &gt; (select sal from emp where ename=&#39;simith&#39;); 列出所有clerk职位的员工姓名,部门名称,部门人数 123select e.ename ename,d.dname ddname, t.countall from emp e join dept d on d.deptno = e.deptno join (select e.deptno, count(*) countall from emp e group by e.deptno) t on t.deptno = d.deptnowhere job=&#x27;clerk&#x27; ;select e.deptno, count(*) countall from emp e group by e.deptno; ​ 列出最低薪资大于1500的各工种及从事此工作的全部员工人数 1select job,min(sal) minsal,count(*) from emp group by job having minsal &gt;1500; 在不知道部门编号的情况下列出sales部门的员工姓名 这题又理解错误,emp的deptno是知道的,只有dept表中deptno不知道 12select deptno from dept where dname=&#x27;sales&#x27;;select ename from emp where deptno = ( select deptno from dept where dname=&#x27;sales&#x27;); 列出薪资高于公司平均薪资的所有员工,所在部门,上级领导,员工的工资等级 12345678910111213141516-- 注意用全连接找出king的信息SELECT e.mgr, e.ename, e.deptno, e2.ename boss, d.dname, s.grade FROM emp e LEFT JOIN emp e2 ON e.mgr = e2.empno JOIN dept d ON d.deptno = e.deptno JOIN salgrade s ON e.sal BETWEEN s.losal AND s.hisal WHERE e.sal &gt; ( SELECT avg( sal ) FROM emp ); 列出与scott从事相同工作的所有员工及其部门名称 123456789101112131415SELECT job FROM emp WHERE ename = &#x27;scott&#x27;;SELECT e.ename, d.dname, e.job FROM emp e JOIN dept d ON e.deptno = d.deptno WHERE job = ( SELECT job FROM emp WHERE ename = &#x27;scott&#x27; ); 列出薪资等于部门30中员工的薪资的其他员工的姓名和薪金 1234567891011121314SELECT DISTINCT sal FROM emp WHERE deptno = 30; SELECT ename, sal FROM emp WHERE ( sal IN ( SELECT DISTINCT sal FROM emp WHERE deptno = 30 ) ) AND deptno &lt;&gt; 30; 列出薪资高于部门30中员工的薪资的其他员工的姓名和薪金 1234567SELECT ename, sal FROM emp WHERE sal &gt; ( SELECT max( t.sal ) FROM ( SELECT DISTINCT sal FROM emp WHERE deptno = 30 ) t ); 列出在每个部门工作的员工数量,平均工资和平均服务期限(工龄) 1234567891011-- 所有、每个这类关键字，一般需要全连接SELECT e.deptno, count( e.ename ) totalmember, IFNULL(avg( sal ) ,0) avgsal, IFNULL(avg( ( ( TO_DAYS( now( ) ) - TO_DAYS( hiredate ) ) / 356 )),0) yearFROM emp e RIGHT JOIN dept d ON e.deptno = d.deptno GROUP BY deptno; 列出所有员工的姓名,部门名称,工资select e.ename,d.dname,e.sal from emp e join dept d on e.deptno=d.deptno; 列出所有部门的详细信息和人数 1select d.deptno,d.dnae,d.loc,count(e.ename) from emp e right join dept d on e.deptno=d.deptno group by d.deptno,d.dname,d.loc; 列出各个工作岗位最低工资和符合最低工资的人姓名(判空与去重) 12345678910SELECT t.job, e.ename, t.minsal FROM emp e JOIN ( SELECT job, min( sal ) minsal FROM emp GROUP BY job ) t ON e.job = t.job AND e.sal = t.minsal ORDER BY t.minsal ASC; 获取各个部门mgr的最低薪资 123456789SELECT deptno, min( sal ) minsal FROM emp where job=&#x27;manager&#x27;GROUP BY deptno; 取出所有员工年薪,由低到高排序 1234567SELECT ename, sal * 12+ ifnull( comm, 0 ) yearsal FROM emp ORDER BY yearsal ASC; 取出员工领导薪水超过3000的员工名称和领导名称 12345SELECT e.ename, e2.ename leaderFROM emp e JOIN emp e2 ON e.mgr = e2.empno AND e2.sal &gt; 3000; 取出含有s的部门,给出此部门的工资合计,部门人数 1234567891011SELECT d.dname empname, count( e.ename ) totalpersons, SUM( ifnull( e.sal, 0 ) ) sumsal FROM emp e RIGHT JOIN dept d ON e.deptno = d.deptno WHERE d.dname LIKE &#x27;%s%&#x27; GROUP BY d.dname; 给任职超过30年的人加薪10%;工作时间计算公式(年)(( TO_DAYS( now( ) ) - TO_DAYS( hiredate ) ) &#x2F; 365 ) year create table emp_bak as select * from emp; 面试一下 初始化数据 12345678910111213141516171819202122232425262728293031323334353637383940414243drop table if exists s;drop table if exists c;drop table if exists sc; create table s( sno int(10) primary key, sname varchar(14) ); create table c( cno int(10) primary key, cname varchar(14), cteacher varchar(14) ); create table sc( sno int(10), cno int(10), scgrade int(10), primary key(sno,cno) ); insert into s(sno,sname) values(1,&#x27;a&#x27;);insert into s(sno,sname) values(2,&#x27;b&#x27;);insert into s(sno,sname) values(3,&#x27;c&#x27;);insert into s(sno,sname) values(4,&#x27;d&#x27;); insert into c(cno,cname,cteacher) values(1,&#x27;java&#x27;,&#x27;王老师&#x27;);insert into c(cno,cname,cteacher) values(2,&#x27;C++&#x27;,&#x27;张老师&#x27;);insert into c(cno,cname,cteacher) values(3,&#x27;C#&#x27;,&#x27;李老师&#x27;);insert into c(cno,cname,cteacher) values(4,&#x27;mysql&#x27;,&#x27;周老师&#x27;);insert into c(cno,cname,cteacher) values(5,&#x27;oracle&#x27;,&#x27;黎明&#x27;); insert into sc(sno,cno,scgrade) values(1,1,50);insert into sc(sno,cno,scgrade) values(1,2,50);insert into sc(sno,cno,scgrade) values(1,3,50);insert into sc(sno,cno,scgrade) values(2,2,80);insert into sc(sno,cno,scgrade) values(2,3,70);insert into sc(sno,cno,scgrade) values(2,4,59);insert into sc(sno,cno,scgrade) values(3,1,60);insert into sc(sno,cno,scgrade) values(3,2,61);insert into sc(sno,cno,scgrade) values(3,3,99);insert into sc(sno,cno,scgrade) values(3,4,100);insert into sc(sno,cno,scgrade) values(3,5,52);insert into sc(sno,cno,scgrade) values(4,3,82);insert into sc(sno,cno,scgrade) values(4,4,99);insert into sc(sno,cno,scgrade) values(4,5,40); 有3个表s(学生表),c(课程表),sc(学生选课表)s(sno,sname) 代表 (学号,姓名)c(cno,cname,cteacher) 代表(课号,课名,教师)sc(sno,cno,scgrade)代表 (学号,课号,成绩) 找出没选过”黎明”老师的所有学生姓名1. 肯定要用补集求解,所以先求黎明苏所在表的相关信息select cno,cname from c where cteacher&#x3D;’黎明’;2. 选了黎明的人select sno from sc where cno &#x3D; (select cno from c where cteacher&#x3D;’黎明’); 3. 没选黎明的人 select sname from s where sno not in (select sno from sc where cno &#x3D; (select cno from c where cteacher&#x3D;’黎明’)) 列出2门以上(含2门) 不及格学生姓名及他的所有成绩的平均成绩 1. 先选出2门不及格的学生 select sno from sc where scgrade &lt; 60 group by sno having count(*)&gt;=2 ; 2. 连接s取姓名 select s.sname from sc join s on sc.sno = s.sno where sc.scgrade &lt; 60 group by s.sname having count(*)&gt;=2 ; 3. 算出每个学生的平均成绩跟不及格的姓名连接(下面这个做法不行,因为其他成绩已经过滤掉了,只会求不及格成绩的平均线) select s.sname name, avg(sc.scgrade) avgscore from sc join s on sc.sno = s.sno where sc.scgrade &lt; 60 group by s.sname having count(*)&gt;=2 ; 123456789101112131415161718192021-- 求出所有学生平均成绩select sc.sno,avg(sc.scgrade) avgscore from sc group by sc.sno;select sno,avg(sc.scgrade) avgscore from sc group by sno; SELECT t1.NAME NAME, t2.avgscore avgscore FROM ( SELECT s.sname NAME, s.sno sno FROM sc JOIN s ON sc.sno = s.sno WHERE sc.scgrade &lt; 60 GROUP BY NAME, sno HAVING count( * ) &gt;= 2 ) t1 JOIN ( SELECT sc.sno sno, avg( sc.scgrade ) avgscore FROM sc GROUP BY sc.sno ) t2 ON t1.sno = t2.sno GROUP BY t1.sno; 即学过1号课程又学过2号课程所有学生的姓名1. 学过1号课程的所有学生(sname,cno)select s.sname sname,sc.cno cno from sc join s on s.sno=sc.sno where cno = 1;2. 学过2号课程的所有学生(sname,cno)select s.sname sname,sc.cno cno from sc join s on s.sno=sc.sno where cno=2;3. 求交集 123select t1.sname sname from (select s.sname sname,sc.cno cno from sc join s on s.sno=sc.sno where cno = 1) t1 join (select s.sname sname,sc.cno cno from sc join s on s.sno=sc.sno where cno=2) t2 on t1.sname = t2.sname; 总结作业到此完成,所有的问题都可分成小问题来拼出来,这个过程中除了注意sql的语法,mysql的特殊语法,还要考虑判空,去重,是否要全连接等.查询数据的思路 我需要哪些字段?这些字段分别在那些表里?这些表靠什么连接? 涉及多表字段(自连接也算) 要先分开查询,查询时要注意判空与去重,以及选用合适的过滤方法和分组函数. 连接时选用内还是外连接,是要用增加查询字段,进行子查询,还是表连接要先后判断一下.","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"system design","slug":"system-design","permalink":"https://hideincode.github.io/tags/system-design/"}]},{"title":"Spring","slug":"system/Spring","date":"2021-07-04T16:00:00.000Z","updated":"2024-05-07T08:57:21.902Z","comments":true,"path":"2021/07/05/system/Spring/","permalink":"https://hideincode.github.io/2021/07/05/system/Spring/","excerpt":"","text":"Spring为什么Spring? IOC进行松耦合与容器化管理对象，AOP进行业务和系统逻辑分开。 轻量，几兆而已。 事务处理能力：本地全局都可以进行统一事物管理。 异常处理：可以全局捕获运行时异常。 MVC进行web编程提高生产效率。 AOP的基本概念 切⾯（Aspect）：官⽅的抽象定义为“⼀个关注点的模块化，这个关注点可能会横切多个对象”。 连接点（Joinpoint）：程序执⾏过程中的某⼀⾏为。 通知（Advice）：“切⾯”对于某个“连接点”所产⽣的动作。 切⼊点（Pointcut）：匹配连接点的断⾔，在 AOP 中通知和⼀个切⼊点表达式关联。 ⽬标对象（Target Object）：被⼀个或者多个切⾯所通知的对象。 AOP 代理（AOP Proxy）：在 Spring AOP 中有两种代理⽅式，JDK 动态代理和 CGLIB 代理。 通知类型有哪些？ 前置通知（Before advice）：在某连接点（JoinPoint）之前执⾏的通知，但这个通知不能阻⽌连接点前的执 ⾏。ApplicationContext 中在 aop:aspect ⾥⾯使⽤ aop:before 元素进⾏声明； 后置通知（After advice）：当某连接点退出的时候执⾏的通知（不论是正常返回还是异常退出）。 ApplicationContext 中在 aop:aspect ⾥⾯使⽤ aop:after 元素进⾏声明。 返回后通知（After return advice ：在某连接点正常完成后执⾏的通知，不包括抛出异常的情况。 ApplicationContext 中在 aop:aspect ⾥⾯使⽤ &lt;&gt; 元素进⾏声明。 环绕通知（Around advice）：包围⼀个连接点的通知，类似 Web 中 Servlet规范中的 Filter 的 doFilter ⽅ 法。可以在⽅法的调⽤前后完成⾃定义的⾏为，也可以选择不执⾏。ApplicationContext 中在 aop:aspect ⾥ ⾯使⽤ aop:around 元素进⾏声明。 抛出异常后通知（After throwing advice）：在⽅法抛出异常退出时执⾏的通知。ApplicationContext 中在 a op:aspect ⾥⾯使⽤ aop:after-throwing 元素进⾏声明 Bean的生命周期 Spring 启动，查找并加载需要被 Spring 管理的 Bean，进⾏ Bean 的实例化； Bean 实例化后，对 Bean 的引⼊和值注⼊到 Bean 的属性中； 如果 Bean 实现了 BeanNameAware 接⼝的话，Spring 将 Bean 的 Id 传递给 setBeanName() ⽅法； 如果 Bean 实现了 BeanFactoryAware 接⼝的话，Spring 将调⽤ setBeanFactory() ⽅法，将 BeanFactory 容器实例传⼊； 如果 Bean 实现了 ApplicationContextAware 接⼝的话，Spring 将调⽤ Bean 的 setApplicationContext() ⽅ 法，将 Bean 所在应⽤上下⽂引⽤传⼊进来； 如果 Bean 实现了 BeanPostProcessor 接⼝，Spring 就将调⽤它们的 postProcessBeforeInitialization() ⽅ 法； 如果 Bean 实现了 InitializingBean 接⼝，Spring 将调⽤它们的 afterPropertiesSet() ⽅法。类似地，如果 Bean 使⽤ init-method 声明了初始化⽅法，该⽅法也会被调⽤； 如果 Bean 实现了 BeanPostProcessor 接⼝，Spring 就将调⽤它们的 postProcessAfterInitialization() ⽅ 法； 此时，Bean 已经准备就绪，可以被应⽤程序使⽤了。它们将⼀直驻留在应⽤上下⽂中，直到应⽤上下⽂被销 毁； 如果 Bean 实现了 DisposableBean 接⼝，Spring 将调⽤它的 destory() 接⼝⽅法，同样，如果 Bean 使⽤了 destory-method 声明销毁⽅法，该⽅法也会被调⽤。 Bean的作用域 singleton : 唯⼀ bean 实例，Spring 中的 bean 默认都是单例的； prototype : 每次请求都会创建⼀个新的 bean 实例； request：每⼀次 HTTP 请求都会产⽣⼀个新的 bean，该 bean 仅在当前 HTTP request 内有效； session : 每⼀次 HTTP 请求都会产⽣⼀个新的 bean，该 bean 仅在当前 HTTP session 内有效； global-session：全局 session 作⽤域，仅仅在基于 portlet 的 web 应⽤中才有意义，Spring5 已经没有了。 Portlet 是能够⽣成语义代码(例如：HTML)⽚段的⼩型 Java Web 插件。它们基于 portlet 容器，可以像 servlet ⼀样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。 Spring的事物隔离级别TransactionDefinition 接⼝中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT：使⽤后端数据库默认的隔离级别，MySQL 默认采⽤的 REPEATABLE_READ 隔离级别 Oracle 默认采⽤的 READ_COMMITTED 隔离级别； TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可 能会导致脏读、幻读或不可᯿复读； TransactionDefinition.ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻⽌脏读，但 是幻读或不可᯿复读仍有可能发⽣； TransactionDefinition.ISOLATION_REPEATABLE_READ：对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被 本身事务⾃⼰所修改，可以阻⽌脏读和不可᯿复读，但幻读仍有可能发⽣； TransactionDefinition.ISOLATION_SERIALIZABLE：最⾼的隔离级别，完全服从 ACID 的隔离级别。所有的事务依 次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可᯿复读以及幻读。但是 这将严᯿影响程序的性能。通常情况下也不会⽤到该级别. Spring的事物传播行为事务传播⾏为是为了解决业务层⽅法之间互相调⽤的事务问题。当事务⽅法被另⼀个事务⽅法调⽤时，必须指定事 务应该如何传播。例如：⽅法可能继续在现有事务中运⾏，也可能开启⼀个新事务，并在⾃⼰的事务中运⾏。在 TransactionDefinition 定义中包括了如下⼏个表示传播⾏为的常量： ⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加⼊该事务；如果当前没有事务，则 创建⼀个新的事务； TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加⼊该事务；如果当前没有事务，则 以⾮事务的⽅式继续运⾏； TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加⼊该事务；如果当前没有事务， 则抛出异常。 不⽀持当前事务的情况： TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建⼀个新的事务，如果当前存在事务，则把当前事务 挂起； TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以⾮事务⽅式运⾏，如果当前存在事务，则把当前事 务挂起。 TransactionDefinition.PROPAGATION_NEVER：以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。 其他情况： TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务 来运⾏；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED 循环依赖如何解决？MVC执行流程 ⽤户向服务器发送请求，请求被 Spring 前端控制Servelt DispatcherServlet 捕获； DispatcherServlet 对请求 URL 进⾏解析，得到请求资源标识符（URI）。然后根据该 URI，调⽤ HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截 器），最后以 HandlerExecutionChain 对象的形式返回； DispatcherServlet 根据获得的 Handler，选择⼀个合适的HandlerAdapter；（附注：如果成功获得 HandlerAdapter 后，此时将开始执⾏拦截器的 preHandler(…)⽅法） 提取 Request 中的模型数据，填充 Handler ⼊参，开始执⾏Handler（Controller)。在填充 Handler 的⼊参 过程中，根据你的配置，Spring 将帮你做⼀些额外的⼯作： （1）HttpMessageConveter：将请求消息（如：Json、xml 等数据）转换成⼀个对象，将对象转换为指定的响应 信息； （2）数据转换：对请求消息进⾏数据转换。如：String 转换成 Integer、Double 等； （3）数据格式化：对请求消息进⾏数据格式化。如：将字符串转换成格式化数字或格式化⽇期等； （4）数据验证：验证数据的有效性（⻓度、格式等），验证结果存储到 BindingResult 或 Error 中; Handler 执⾏完成后，向 DispatcherServlet 返回⼀个 ModelAndView 对象； 根据返回的 ModelAndView，选择⼀个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)返回给DispatcherServlet； ViewResolver 结合 Model 和 View，来渲染视图； 将渲染结果返回给客户端。 MVC核心组件 前端控制器 DispatcherServlet 作⽤：Spring MVC 的⼊⼝函数。接收请求，响应结果，相当于转发器，中央处理器。有了 DispatcherServlet 减 少了其它组件之间的耦合度。⽤户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个 流程控制的中⼼，由它调⽤其它组件处理⽤户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器 HandlerMapping 作⽤：根据请求的 url 查找 Handler。HandlerMapping 负责根据⽤户请求找到 Handler 即处理器 （Controller），SpringMVC 提供了不同的映射器实现不同的映射⽅式，例如：配置⽂件⽅式，实现接⼝⽅式，注 解⽅式等。 处理器适配器 HandlerAdapter 作⽤：按照特定规则（HandlerAdapter 要求的规则）去执⾏ Handler。通过 HandlerAdapter 对处理器进⾏执 ⾏，这是适配器模式的应⽤，通过扩展适配器可以对更多类型的处理器进⾏执⾏。 处理器 Handler 注意：编写 Handler 时按照 HandlerAdapter 的要求去做，这样适配器才可以去正确执⾏ Handler。Handler 是继 DispatcherServlet 前端控制器的后端控制器，在 DispatcherServlet 的控制下 Handler 对具体的⽤户请求进⾏处 理。由于 Handler 涉及到具体的⽤户业务请求，所以⼀般情况需要⼯程师根据业务需求开发 Handler。 视图解析器 View resolver 作⽤：进⾏视图解析，根据逻辑视图名解析成真正的视图（View ）。View Resolver 负责将处理结果⽣成 View 视 图，View Resolver ⾸先根据逻辑视图名解析成物理视图名即具体的⻚⾯地址，再⽣成 View 视图对象，最后对 View 进⾏渲染将处理结果通过⻚⾯展示给⽤户。SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、 freemarkerView、pdfView 等。⼀般情况下需要通过⻚⾯标签或⻚⾯模版技术将模型数据通过⻚⾯展示给⽤户， 需要由⼯程师根据业务需求开发具体的⻚⾯。 视图 View View 是⼀个接⼝，实现类⽀持不同的 View 类型（jsp、freemarker…）。 注意：处理器 Handler（也就是我们平常说的 Controller 控制器）以及视图层 View 都是需要我们⾃⼰⼿动 开发的。其他的⼀些组件⽐如：前端控制器 DispatcherServlet、处理器映射器 HandlerMapping、处理器适 配器 HandlerAdapter 等等都是框架提供给我们的，不需要⾃⼰⼿动开发。 SpringBoot 优点： 简化spring配置，自动配置。 内嵌各种容器，可以直接jar包启动 通过starter封装各种配置 避免了maven冲突 提供了监控服务 缺点： 封装太多，排查问题麻烦点。 SpringBoot自动配置原理 启动加载大量自动配置类 检查需要的功能有没有在自动配置中 可以通过properties文件添加组件 SpringBoot启动流程 SpringBoot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的 值 将这些值作为⾃动配置类导⼊容器 ， ⾃动配置类就⽣效 ， 帮我们进⾏⾃动配置⼯作； 整个J2EE的整体解决⽅案和⾃动配置都在springboot-autoconfigure的jar包中； 它会给容器中导⼊⾮常多的⾃动配置类 （xxxAutoConfiguration）, 就是给容器中导⼊这个场景需要的所有组 件 ， 并配置好这些组件 ； 5. 有了⾃动配置类 ， 免去了我们⼿动编写配置注⼊功能组件等的⼯作； SpringCloud集成定时任务 配置Quartz 定义job和trigger即可","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"system design","slug":"system-design","permalink":"https://hideincode.github.io/tags/system-design/"}]},{"title":"Redis","slug":"system/Redis","date":"2021-04-07T16:00:00.000Z","updated":"2024-05-07T08:56:55.119Z","comments":true,"path":"2021/04/08/system/Redis/","permalink":"https://hideincode.github.io/2021/04/08/system/Redis/","excerpt":"","text":"Redis数据类型 Strings Hash Lists 粉丝列表,文章评论;基于缓存分页lrange Sets 求交并补 Sorted Sets 缓存与数据库数据一致性问题 CAP 读的时候先读缓存,写时先写库. 问题:如果删除缓存失败,那么就会读到旧数据. 解决方案: 先删除缓存在更新库. 延时双删,利用队列 DelayQueue MQ 高并发情况下的问题： A线程先删除了缓存，再去改数据，此时B线程读取数据会直接读取数据库旧数据，然后写入缓存。等到A修改完成，那么缓存与库数据不一致情况就会出现。 解决方案，利用jvm本身的队列，进行串行化操作. 经典问题 雪崩：雪崩指的是大量的缓存失效（一般由于过期），大量查询直接到数据库，导致数据库爆炸。 预防：利用redis的高可用，就是主从+哨兵，集群； 正在发生：本地ehcache缓存+hystrix限流降级，避免mysql挂掉； 事后：redis持久化，之后再去重启redis就直接从磁盘拿数据。 穿透：高并发查询缓存和数据库中都没有的数据，例如查询id&#x3D;-1，致使所有的请求都打到数据库，数据库爆炸。因为视缓存为无物，所以叫做穿透。 解决方案：从数据库中查询不到的值，也要在缓存中设置一个空值，设置一个过期时间。 如果使用不同的负数查询，那么用布隆过滤器，把所有数据放到布隆hash中，利用布隆过滤器筛选，减少压力； 击穿： 热点数据的key在缓存失效瞬间，全部请求到数据库，导致数据库爆炸。 解决方案： 对于不怎么更新的数据，设置成永不过期。 更新不频繁的，耗时较短的数据，利用分布式锁，让少量请求更新缓存，其余的在锁释放后读取缓存即可； 若缓存更新频繁或者耗时较长，利用定时任务在过期前主动重新构建缓存或者延后缓存过期时间，保证所有请求都能访问对应的缓存； Redis并发竞争问题 并发写，由于顺序问题，导致数据出错。利用分布式锁和数据库中的时间戳（更新时间），利用锁一个个写，利用时间戳比对数据是否是最新的。 技术选型为啥用Redis redis支持复杂的数据结构,相比于memcached,redis支持集群,数据量多的情况下,还是redis更好用.redis内部使用文件事件处理器.比较复杂,todo **为啥单线程的redis这么快 ** 纯内存操作 基于非阻塞的IO多路复用机制 采用了C语言这种更加接近底层的语言 单线程避免了多线程的上下文频繁切换.也不会出现redis本身的资源竞争问题. redis是有多线程的,自6.0以后 因为某些方面,单线程已经没有太大优势了,读写网络的Read和Write系统在调用redis执行期间占用了大部分cpu时间,这种地方使用多线程对性能更友好. redis的过期策略 定期删除+惰性删除 每过100ms就随机抽查一部分设置了过期时间的key,如果过期就删除; 查询key的时候也会检查,如果key已经过期,那么直接删除; 此时大量过期key堆积,导致内存不够用,该如何是好 答案:内存淘汰机制 ​ 2. Redis 内存淘汰机制有以下几个： noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。 allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。 volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。 考点: LRU算法 Redis通过哨兵集群实现高可用 集群监控：负责监控 Redis master 和 slave 进程是否正常工作。 消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。 哨兵本身也是分布式的,可以做集群部署. 故障转移需要大部分的哨兵同意. 哨兵至少需要三个实例. 哨兵+Redis的主从部署,不保证数据零丢失,只能保证Redis集群的高可用. 复杂部署架构,需要在测试环境和生产环境做够充足演练. Redis的持久化 RDB持久化机制,对Redis中的数据执行周期性的持久化 AOF记录日志,类似于Mysql的binlog,追加的形式到日志文件,重启时通过回放日志文件来重新构建数据集. RDB优缺点 会生成多个文件,适合存储云端服务器做冷备份. 对redis的对外读写影响很小,让redis保持高性能. 比AOF更快的持久化 由于周期型的,所以数据完整性不如AOF. 持久化的文件特别大时,会导致对客户端的服务暂停数毫秒到几秒. AOF优缺点 数据完整性更可靠 写入性能高,直接追加. 日志文件过大也不会影响客户端的使用. 利用可读性较强的方式记录,适合做灾难性误删除的恢复. 开启后,支持写redis操作的QPS会降低 出现数据丢失 可以同时开启两者。","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"system design","slug":"system-design","permalink":"https://hideincode.github.io/tags/system-design/"}]},{"title":"Spring源码","slug":"code/spring","date":"2021-03-02T16:00:00.000Z","updated":"2024-05-07T08:44:59.813Z","comments":true,"path":"2021/03/03/code/spring/","permalink":"https://hideincode.github.io/2021/03/03/code/spring/","excerpt":"","text":"Spring 记录spring源码中的精华思想","categories":[{"name":"源码分析","slug":"源码分析","permalink":"https://hideincode.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"code","slug":"code","permalink":"https://hideincode.github.io/tags/code/"}]},{"title":"JDK中的源码","slug":"code/jdk","date":"2020-09-06T16:00:00.000Z","updated":"2024-05-07T08:59:20.238Z","comments":true,"path":"2020/09/07/code/jdk/","permalink":"https://hideincode.github.io/2020/09/07/code/jdk/","excerpt":"","text":"JDK 用于记录jdk中的好的设计模式，算法思路，一些特性与bug。","categories":[{"name":"源码分析","slug":"源码分析","permalink":"https://hideincode.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"}],"tags":[{"name":"code","slug":"code","permalink":"https://hideincode.github.io/tags/code/"}]},{"title":"Mybatis","slug":"system/MyBatis","date":"2020-08-01T16:00:00.000Z","updated":"2024-05-07T08:55:43.666Z","comments":true,"path":"2020/08/02/system/MyBatis/","permalink":"https://hideincode.github.io/2020/08/02/system/MyBatis/","excerpt":"","text":"Mybatis 半自动ORM框架，对JDBC进行了封装。 使用xml&#x2F;注解进行配置和映射。 灵活编写SQL，不用与代码耦合。 兼容各种数据库。 提供了映射标签。 但是SQL编写量变大，多表时麻烦；SQL语句以来数据库，不好随便换库。 不要用RowBounds进行分页，这是个内存分页。 缓存 一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，其存储作⽤域为 Session，当 Session flush 或 close 之 后，该 Session 中的所有 Cache 就将清空，默认打开⼀级缓存； 二级缓存：与⼀级缓存其机制相同，默认也是采⽤ PerpetualCache，HashMap 存储，不同在于其存储作⽤域为 Mapper(Namespace)，并且可⾃定义存储源，如 Ehcache。默认不打开⼆级缓存，要开启⼆级缓存，使⽤⼆级缓 存属性类需要实现 Serializable 序列化接⼝(可⽤来保存对象的状态)，可在它的映射⽂件中配。 对于缓存数据更新机制，当某⼀个作⽤域(⼀级缓存 Session &#x2F; ⼆级缓存 Namespaces)的进⾏了 C&#x2F;U&#x2F;D 操作后，默 认该作⽤域下所有 select 中的缓存将被 clear。","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"system design","slug":"system-design","permalink":"https://hideincode.github.io/tags/system-design/"}]},{"title":"常见消息队列选型","slug":"system/MQ","date":"2020-07-12T16:00:00.000Z","updated":"2024-05-07T08:55:16.063Z","comments":true,"path":"2020/07/13/system/MQ/","permalink":"https://hideincode.github.io/2020/07/13/system/MQ/","excerpt":"","text":"MQ 当碰到需要解耦、异步、削峰问题时，那么就使用MQ吧。 常见的MQActiveMQ：支持万级的吞吐量，较成熟完善；官方更新迭代较少，社区的活跃度不是很高，有消息丢失的情况。 RabbitMQ：延时低，微妙级延时，社区活跃度高，bug 修复及时，而且提供了很友善的后台界面；用 Erlang 语言开发，只熟悉 Java 的无法阅读源码和自行修复 bug。 RocketMQ：阿里维护的消息中间件，可以达到十万级的吞吐量，支持分布式事务。 Kafka：分布式的中间件，最大优点是其吞吐量高，一般运用于大数据系统的实时运算和日志采集的场景，功能简单，可靠性高，扩展性高；缺点是可能导致重复消费。 MQ处理消息时容易遇到的问题 消息丢失 RabbitMQ 生产者： 开启事务（不推荐） 开启confirm模式（推荐） MQ：开启持久化 消费者： 关闭自动ACK Kafka 生产者：设置acks&#x3D;all，数据一定不丢 MQ：？？ 消费者：Kafka会自动offset，可以关闭offset，使用手动提交offset，保证数据不会丢。 消息幂等 写数据时先根据主键查询数据是否存在，存在则更新。 利用数据库的唯一键索引。 如果是redis，那么redis的set天然支持去重幂等。 消息顺序性 RabbitMQ：拆分成多个Queue，每个Queue一个Consumer，然后Consumer内部用内存队列做排队，分发给底层不同的Worker处理。 Kafka：写N个内存Queue，具有相同key的数据进入到同一个Queue；对于N个线程，每个线程消费一个内存Queue，保证了顺序性。 消息积压 先修复consumer，保证消费速度，然后停掉consumer; 新建个topic，partion设置为原来10倍，临时建立原来10倍的queue。 写一个临时分发数据的consumer，用这个程序去消费积压数据，把数据轮询写入临时建好的10倍queue； 10倍机器部署consumer，每一批consumer消费一个queue，相当于把queue资源和consumer资源扩大10倍，以原来10倍速度消费； 等消费完积压的数据，恢复原来结构，正常消费。 消息失效 把丢失的消息查出来，重新导入MQ。 架构 如何高可用 RabbitMQ：镜像集群模式，队列的消息会分布在多个机器上，写消息时就会跟多个队列进行通讯。这样任意一个宕机都不影响系统。问题在于开销太大，拓展性差。 Kafka：partition和replica机制，每个节点都是一个broker，一个topic可以分成多个partition，partition可以存在多个broker上，也就是说一个topic的消息是分在多个机器上的。0.8版本后提供了HA机制，即replica副本机制。每个partition数据都会同步到其他机器，形成多个副本。然后所有的replica选举一个leader，生产消费都和这个leader打交道，其他的replica就是follower。写的时候leader会把数据同步到所有的follower上去，读的时候直接读leader上的数据。","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"system design","slug":"system-design","permalink":"https://hideincode.github.io/tags/system-design/"}]},{"title":"ES的使用与原理","slug":"system/ElasticSearch","date":"2020-06-10T16:00:00.000Z","updated":"2024-05-07T08:54:06.194Z","comments":true,"path":"2020/06/11/system/ElasticSearch/","permalink":"https://hideincode.github.io/2020/06/11/system/ElasticSearch/","excerpt":"","text":"ElasticSearch 简称ES，一种近实时、大量数据搜索工具。多用于监控（ELK)、信息检索。","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"system design","slug":"system-design","permalink":"https://hideincode.github.io/tags/system-design/"}]},{"title":"Dubbo","slug":"system/Dubbo","date":"2020-05-01T16:00:00.000Z","updated":"2024-05-07T08:55:11.453Z","comments":true,"path":"2020/05/02/system/Dubbo/","permalink":"https://hideincode.github.io/2020/05/02/system/Dubbo/","excerpt":"","text":"Dubbo RPC框架，用于服务之间调用。","categories":[{"name":"系统设计","slug":"系统设计","permalink":"https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"system design","slug":"system-design","permalink":"https://hideincode.github.io/tags/system-design/"}]},{"title":"代码问题","slug":"error/代码问题","date":"2020-03-31T16:00:00.000Z","updated":"2024-05-07T08:52:44.526Z","comments":true,"path":"2020/04/01/error/代码问题/","permalink":"https://hideincode.github.io/2020/04/01/error/%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"","text":"","categories":[{"name":"问题排查","slug":"问题排查","permalink":"https://hideincode.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}],"tags":[{"name":"error","slug":"error","permalink":"https://hideincode.github.io/tags/error/"}]},{"title":"开发环境准备","slug":"devops/开发工具配置","date":"2019-11-30T16:00:00.000Z","updated":"2024-05-07T08:52:25.347Z","comments":true,"path":"2019/12/01/devops/开发工具配置/","permalink":"https://hideincode.github.io/2019/12/01/devops/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/","excerpt":"","text":"开发环境准备代码工具：JDK、Idea、Maven、Git、VsCode、NodeJs、Anaconda、Pycharm vscode插件： EsLint —— 语法纠错 Auto Close Tag —— 自动闭合 HTML&#x2F;XML 标签 Auto Rename Tag —— 自动完成另一侧标签的同步修改 JavaScript(ES6) code snippets — — ES6 语 法 智 能 提 示 以 及 快 速 输 入 ， 除 js 外 还 支 持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含 js 代码文件的时间 HTML CSS Support —— 让 html 标签上写 class 智能提示当前项目所支持的样式 HTML Snippets —— html 快速自动补全 Open in browser —— 浏览器快速打开 Live Server —— 以内嵌服务器方式打开 Chinese (Simplified) Language Pack for Visual Studio Code 虚拟机配置：Vagrant、VirtualBox 常用服务：MySQL、Redis、Tomcat、Nginx 远程连接与可视化：MobaXterm、Navicat、RedisInsight 设计图工具：Processon、draw.io 杂项：Postman、Typora、Everything、XMind、7zip、梯子","categories":[{"name":"开发部署","slug":"开发部署","permalink":"https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"devops","slug":"devops","permalink":"https://hideincode.github.io/tags/devops/"}]},{"title":"Nginx相关","slug":"devops/ngxin","date":"2019-06-30T16:00:00.000Z","updated":"2024-05-07T08:51:44.755Z","comments":true,"path":"2019/07/01/devops/ngxin/","permalink":"https://hideincode.github.io/2019/07/01/devops/ngxin/","excerpt":"","text":"安装部署docker下安装 docker pull nginx docker run –name nginx -p 9000:80 -d nginx 先启动一个容器用来复制配置 生成挂载文件地址 1234567mkdir -p /opt/docker/nginx/confmkdir -p /opt/docker/nginx/htmlmkdir -p /opt/docker/nginx/logsdocker cp nginx:/etc/nginx/nginx.conf /opt/docker/nginx/conf/nginx.confdocker cp nginx:/etc/nginx/conf.d /opt/docker/nginx/conf/conf.ddocker cp nginx:/usr/share/nginx/html /opt/docker/nginx 干掉这个nginx 12docker stop nginx docker rm nginx 以80端口启动，一行命令。 12docker run -p 80:80 --name nginx --restart=always -v /opt/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /opt/docker/nginx/conf/conf.d:/etc/nginx/conf.d -v /opt/docker/nginx/html:/usr/share/nginx/html -v /opt/docker/nginx/logs:/var/log/nginx -d nginx 常见问题配置遗漏 每句配置结尾有分号！！！ 转发不到 查看error.log，请求路径是否符合预期。 斜杠问题 配置为： location hello&#x2F; { proxy_pass 192.168.56.10&#x2F; } 请求：nginx主机&#x2F;hello&#x2F;all location：不带&#x2F;的话会自动补上，带的话能正确拼接。 proxy_pass： 带&#x2F;：;最终请求：nginx主机&#x2F;all，即忽略location. 不带&#x2F;：最终请求：nginx主机&#x2F;hello&#x2F;all location不带，proxy_pass带：会生成双斜杠，nginx主机&#x2F;&#x2F;all，这是因为补齐机制导致。 总结：proxy_pass看项目的controller有没有带，location最好带上。","categories":[{"name":"开发部署","slug":"开发部署","permalink":"https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"devops","slug":"devops","permalink":"https://hideincode.github.io/tags/devops/"}]},{"title":"设计模式","slug":"basic/设计模式","date":"2019-06-05T16:00:00.000Z","updated":"2024-05-07T08:39:25.282Z","comments":true,"path":"2019/06/06/basic/设计模式/","permalink":"https://hideincode.github.io/2019/06/06/basic/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式 代码的设计本质上就是两个部分 职责划分 模块通信 单一职责(Single Responsibility) 类在命名时就应该想好职责，一个类只做一件事。 开闭原则(Open Close) 对拓展开放，对修改关闭。 接口隔离(Interface Segregation) 不能强迫用户使用他们不需要的接口。 如果一个接口只需部分方法就可以完成职责的话，那么这个接口的职责就不单一了，要考虑重新拆分。 接口制定尽量细小化，单一化，避免肥胖接口。 依赖倒置(Dependence Inversion) 抽象不依赖细节，高层不依赖底层。 应该依赖抽象接口而非具体实现。 使用接口避免了传递依赖，即不用引用实现类中依赖的对象。 替换原则(Liskov Substitution) 子类可以替换父类使用。 需要做到以下 非必要不重写父类非抽象方法。 子类的产生主要是为了新增自己的方法。 overload父类方法时： 子类中的方法参数要更加宽松。这样替换成父类时，子类父类可以做的事子类也可以做，不会因为入参有影响。 子类中的方法返回值要更加严格。防止改变父类功能，对于执行的结果，子类要对结果更加负责，否则会导致没办法替换父类。 继承是一种强制通信，即子类一定要接受父类的属性与方法，避免不了高耦合，所以组合优于继承。 当规定一个父类的所有子类都满足不重写父类已经实现类时，那么父类的具体方法才得到完美的复用。 如果非要重写父类已经实现的方法的话，打破继承关系，直接封装新类，然后用组合的方式引入进来。 迪米特法则(Law Of Demeter) 类与类之间有一串依赖关系时，只和直接联系对象通信。 哪些对象可以直接联系： 自己，即this。 方法中的参数对象。 直接引用的对象，包括其中的对象。 当前对象所创建对象。 过度使用迪米特可能会在项目中创建过多中间类。 总结 尽量遵守这6个规则，根据业务需求来规定类与接口的模式，如果执行不了也可以做出设计牺牲。切不要本末倒置，设计模式的最重要目标就是预测业务变化，在拓展点增加接口，减少代码修改。 各单位模块职责清晰(包，接口，类，函数等); 模块本身要可升级替换，有种可插拔的感觉; 新代码要尽力而为遵守，老代码需要重构时按此原则重构; SOLID原则比GOF23的定式重要;","categories":[{"name":"基础知识","slug":"基础知识","permalink":"https://hideincode.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"https://hideincode.github.io/tags/design-pattern/"}]},{"title":"机器问题排查","slug":"error/机器问题","date":"2019-06-05T16:00:00.000Z","updated":"2024-05-07T08:53:09.680Z","comments":true,"path":"2019/06/06/error/机器问题/","permalink":"https://hideincode.github.io/2019/06/06/error/%E6%9C%BA%E5%99%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"","categories":[{"name":"开发部署","slug":"开发部署","permalink":"https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"devops","slug":"devops","permalink":"https://hideincode.github.io/tags/devops/"}]},{"title":"Linux的玩法","slug":"devops/linux","date":"2019-03-05T16:00:00.000Z","updated":"2024-05-07T08:50:46.182Z","comments":true,"path":"2019/03/06/devops/linux/","permalink":"https://hideincode.github.io/2019/03/06/devops/linux/","excerpt":"","text":"Linux命令查看端口 lsof -i:8080 列出系统打开的文件 netstat -tunlp |grep 8080 列出包含8080端口的tcp、udp、拒绝别名、展示监听、进程名 查看进程 ps -ef |grep java 查看java进程 jps 查看java进程，需要安装jdk 杀进程 kill -9 pid 强制干掉$pid kill -15 pid 优雅停机 清理旧包脚本 1234567891011121314151617181920#!/bin/bashrm -rf targetappname=$1echo &quot;appname:$appname&quot;pid=`ps -ef | grep $appname | grep &#x27;java -Xms&#x27; | awk &#x27;&#123;printf $2&#125;&#x27;`echo $pidif [ -z $pid]; then echo &quot;$appname not start&quot; else kill -9 $pid echo &quot;$appname stoping...&quot;ficheck=`ps -ef | grep -w $pid | grep java`if [ -z $check]; then echo &quot;$appname pid:$pid is stop&quot; else echo &quot;$appname stop failed&quot;fi","categories":[{"name":"开发部署","slug":"开发部署","permalink":"https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"devops","slug":"devops","permalink":"https://hideincode.github.io/tags/devops/"}]},{"title":"Maven的一些问题","slug":"devops/maven","date":"2018-10-01T16:00:00.000Z","updated":"2024-05-07T08:51:08.523Z","comments":true,"path":"2018/10/02/devops/maven/","permalink":"https://hideincode.github.io/2018/10/02/devops/maven/","excerpt":"","text":"Maven的一些问题常见配置12345678910111213141516171819202122232425&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus-aliyun&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Nexus aliyun&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;&lt;localRepository&gt;../rep&lt;/localRepository&gt;","categories":[{"name":"开发部署","slug":"开发部署","permalink":"https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"devops","slug":"devops","permalink":"https://hideincode.github.io/tags/devops/"}]},{"title":"Jenkin安装","slug":"devops/jenkins","date":"2018-09-05T16:00:00.000Z","updated":"2024-05-07T08:50:14.692Z","comments":true,"path":"2018/09/06/devops/jenkins/","permalink":"https://hideincode.github.io/2018/09/06/devops/jenkins/","excerpt":"","text":"Jenkins部署与使用 去官网下载war包，注意支持的Java版本Jenkins官网 上传到服务器，下载jdk，使用命令：nohup java -Xms515m -Xmx1024m -jar -Dfile.encoding&#x3D;UTF-8 jenkins.war &gt; jenkins.log 2&gt;&amp;1 &amp; 进入2中生成log查看密码，或者&#x2F;root&#x2F;.jenkins&#x2F;secrets&#x2F;initialAdminPassword中看到密码。 host:8080登录,选择推荐安装，能跳过先跳过。 修改密码 安装Maven Integration plugin、Build Authorization Token Root Plugin、Publish Over SSH。用于进行maven打包、自动构建匿名token，链接服务器。 在服务器上安装maven，git。maven要配置好国内镜像。 新建任务选择构建一个maven项目，这一步必须安装插件才有 在系统管理-&gt;系统配置中，JekinsLocation指定jenkins服务器地址；配置Publish over SSH执行jar包的服务器地址与用户 在源码管理中配置git仓库地址与分支，PostSteps中配置执行jar包的服务器(使用绝对路径)，设置启动命令。在构建触发器中触发远程构建，自定义令牌，利用Build Authorization Token Root Plugin，生成链接，具体参考插件官网。 12#启动项目nohup java -Xms515m -Xmx1024m -jar -Dfile.encoding=UTF-8 *.jar &gt; app.log 2&gt;&amp;1 &amp; 在PreSteps中远程清除jar包，杀死旧进程。 1234567891011121314151617181920#!/bin/bashrm -rf targetappname=$1echo &quot;appname:$appname&quot;pid=`ps -ef | grep $appname | grep &#x27;java -Xms&#x27; | awk &#x27;&#123;printf $2&#125;&#x27;`echo $pidif [ -z $pid]; then echo &quot;$appname not start&quot; else kill -9 $pid echo &quot;$appname stoping...&quot;ficheck=`ps -ef | grep -w $pid | grep java`if [ -z $check]; then echo &quot;$appname pid:$pid is stop&quot; else echo &quot;$appname stop failed&quot;fi 点击构建，观察控制台。 可以配置gitlab的webhook触发自动部署，记得切换管理员到network中外发请求中勾选允许本地。 可以利用定时构建和cron表达式来定期构建。判断表达式可用工具：cron工具 可以配置告警邮件，要自己给出支持SMTP的邮箱，推荐网易，QQ不行。","categories":[{"name":"开发部署","slug":"开发部署","permalink":"https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"devops","slug":"devops","permalink":"https://hideincode.github.io/tags/devops/"}]},{"title":"git用法以及常见问题解决","slug":"devops/git","date":"2018-06-05T16:00:00.000Z","updated":"2024-05-07T08:49:43.615Z","comments":true,"path":"2018/06/06/devops/git/","permalink":"https://hideincode.github.io/2018/06/06/devops/git/","excerpt":"","text":"git解决了什么问题 分布式: 解决以前集中式单点文件服务器宕机的痛点,;由于git是分布式的vcs系统,无需联网就可以在本地提交保存各自的操作记录,最后与其他人合并推送到远程服务器保存即可. 轻量健全的分支系统:有想法就可以开分支,分支都在自己仓库内,不会影响其他人,便于切换和协作开发. 快:所有操作在本地,肯定会快. tips : git的学习曲线真的不算平滑,当然如果只是当个下载器那没啥可说. 建仓 git init git config –global user.name “sui” git config –global user.email “&#97;&#x40;&#x62;&#x2e;&#99;&#x6f;&#x6d;“ git config --list 查看现有配置 初始化仓库,配置自己的名字和邮箱 tips: 如果文件是代码的话,一般要配置上.gitignore和README.md文件. tips: 作者 和 提交者 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 分区 工作区—&gt;暂存区—&gt;本地仓库 git add 文件 开始追踪该文件,并加入缓存区.已经追踪但是修改了的文件也要重新add才能加入暂存区. git commit -m 把暂存区的所有变更提到本地仓库,工作区直接提交加-a git diff 查看未暂存的修改了哪些地方,不好用. git diff --cached 查看已暂存的变化. git rm 文件 从工作区删除该文件,并且不再追踪. git rm --cached 文件 不会从工作区删除该文件,不再追踪该文件. git mv source target 重命名,并且依旧追踪. git log 查看提交记录 撤销 git commit --amend 修正提交,把暂存区的文件提交,第二次提交将代替第一次提交的结果. 用于修正提交信息和提交遗漏文件 git checkout 文件 把该文件还原成暂存区中的状态 git reset HEAD 重置暂存区为上一次提交,工作区不变,暂存区改文件未提交.(放弃提交) 1. 默认是 git reset --mixed HEAD 同上 2. git reset --hard HEAD 重置所有没有提交入库的,工作区和暂存区都会修改,谨慎使用! 3. git reset --soft HEAD 重置HEAD指针,工作区和暂存区不会改变 4. git reset 文件 可以指定回退文件 git checkout HEAD . 把工作区的文件都会退到HEAD指向的提交 git checkout comId 文件 把工作区改文件退回到comId tips: 对于git,几乎所有的已提交的东西总能恢复. 远程仓库 git remote -v 查看要读写的远程仓库简称以及URL git remote add &lt;为远程仓库起的别名&gt; &lt;远程仓库地址&gt; 添加一个远程仓库 git fetch &lt;别名&gt; 从远程仓库下载本地缺失的提交,更新远程分支,并没有修改本地文件,需要自己手动合并. git pull &lt;别名&gt; 拉取并合并 git push &lt;别名&gt; &lt;branch&gt; 把本地仓库提交推送到远程仓库,如果已经有其他人推送,必须先拉取. git remote show &lt;别名&gt; 查看远程仓库所有分支与URL git remote rename &lt;旧名字&gt; &lt;新名字&gt; 重新命名简称 git remote remove &lt;别名&gt; 移除与远程仓库的关联 打标签标签是为了标记重要版本 git支持两种标签:轻量标签,附注标签.其中轻量标签只是简单打个标签不含其他额外信息,而附注标签会带有打标签人的姓名,邮箱,日期,和标签独有信息. git tag 列出所有标签 git tag -l &quot;v1.0*&quot; 匹配所有v1.0版本的 git tag -a v1.0 -m &quot;my version 1.0&quot; 打上附注标签标签v1.0,并填上信息 git show v1.0 看标签信息 git tag tagName 直接打上轻量标签 git tag -a &lt;tagName&gt; &lt;commId&gt; 给历史提交打标签 git push origin &lt;tagName&gt; 把标签推送到远程仓库(不会自动推送到远程) git push origin tags 把所有标签推送到远程仓库 git tag -d &lt;tagName&gt; 删除标签,并不会删除远程标签 git push &lt;remote&gt;:refs/tags/&lt;tagName&gt;删除远程关联的标签 git push origin --delete &lt;tagName&gt; 效果同上,删除远程标签 git checkout &lt;tagName&gt; 检出标签所指文件版本,会使仓库处于头指针分离状态,不建议用 起别名 git config --global alias.co checkout 把checkout改名为co 分支轻量的,无需副本的,支持频繁合并 HEAD 是一个指向当前所在的本地分支,可以把HEAD想象成当前分支的别名. 切换分支会重置工作区,而且工作目录和暂存区没有提交的内容如果和checkout的分支有冲突,那么将会切换失败,此时要先解决冲突. 冲突是指某个文件某一部分进行了不同的修改,这个是git无法处理的,合并完需要用git add来标记为已解决. git branch &lt;分支名字&gt; 创建一个分支,也就是创建了一个可移动的指向提交对象的指针,执行命令后HEAD并不会指向新建的分支. git checkout &lt;分支名称&gt; 切换分支,即把HEAD指向当前分支,工作区可能被改变,git发现有冲突时将切不过来. git merge hotfix 把hotfix合并到当前分支,喊过来一起干大事 git log --oneline --decorate --graph --all 项目分叉历史. git checkout -b &lt;分支名称&gt; 创建并切换到新分支 git branch -d &lt;分支名字&gt; 删除一个分支,一般分支要解决的问题完成后,就删除该分支 git branch -f main HEAD~3 让分支指向另一个提交,此处让main往回走三次. 如何管理分支 git branch 查看所有分支 git branch -v 查看每个分支最后一次提交 git branch --merged 查看哪些分支已经合并到当前分支 git branch --no-merged 查看还没有合并到当前的分支,对这些分支进行删除会失败. 关于远程分支 git ls-remote origin 获取远程仓库名为origin的所有分支引用. git remote show origin 获取远程分支的跟踪,合并,推送等信息 git fetch origin 拉取origin上本地没有数据 git push origin master 把本地仓库推送到远程仓库 git checkout -b release origin/release 建立一个指向远程release的本地分支 git push origin --delete hotFix 删除服务器上的hotFix分支 变基 给另一个分支A当儿子,找到当前分支和A的最近公共祖先结点,把最近祖先结点后到当前的提交并入A下. 相比于merge的优点:使提交历史更加简洁,把并行开发弄得像穿行开发. 相同点:结果快照和merge都是一样的,只是变更了历史. tips: git merge 有直接移动HEAD指针的功能 wanrning: 如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。 git rebase master 当前分支接着master git rebase --onto master server client 这里server拉取于master,client拉取于server,把属于client但是不属于server的提交变基到master下.git可以把树的当前节点合并到任意节点下 git rebase &lt;basebranch&gt; &lt;topicbranch&gt; 直接将topic合入master,无需切换分支 git pull --rebase 正确拉取已经被编辑的提交 服务器上的Git 基于不同协议传输数据 本地协议,基于文件共享系统的. HTTP协议 SSH协议 git协议 ssh-keygen -o 生成 ssh公钥到home路径的.ssh下的.pub文件,用于免密登录. git cherry-pick commId1 commId2 .. 摘樱桃,摘取有用提交. Git工具 git revert release HEAD~1 生成新提交,并撤销已存在提交的所有修改. 常见Git服务器: GitLab 第三方托管:GitHub,Gitee 参考文档 本地代码与远程仓库关联： git init git remote add &lt;别名&gt; &lt;clone地址&gt; 提交所有本地代码到本地仓库 git push &lt;别名&gt; &lt;分支&gt; 这里的分支要和本地一致 完成","categories":[{"name":"开发部署","slug":"开发部署","permalink":"https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"devops","slug":"devops","permalink":"https://hideincode.github.io/tags/devops/"}]},{"title":"操作系统","slug":"basic/操作系统","date":"2017-05-01T05:45:50.000Z","updated":"2024-05-07T08:40:40.297Z","comments":true,"path":"2017/05/01/basic/操作系统/","permalink":"https://hideincode.github.io/2017/05/01/basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"操作系统 这里主要是linus操作系统 进程的状态 运行 就绪 阻塞 进程的通信方式 管道 命名管道 消息队列 信号量 共享内存 进程调度算法 先来先服务 时间片轮转调度算法 短时间作业优先 最短剩余时间优先调度算法 高响应比优先调度算法 优先级调度算法 死锁 循环占有，A有了拿到锁1，再去拿锁2；B有锁2，去拿锁1；就这样僵住了。 产生原因： 资源竞争，有不可剥夺的资源。 进程推进不当。 资源分类： 可剥夺的资源：某些进程获得这些资源后，这些资源也能被其他进程或系统剥夺，CPU和主存均属于此列。 不可剥夺的资源：分配给进程后，不可强制回收，只能等进程用完释放。如磁带、打印机。 必要条件 死锁一定是这样子的，对于哲学家模型就是面只有一份只够一个人，每个人都会拿着自己的筷子不放手，每个人自己的筷子只能在自己用完后放手，形成了环。 互斥条件：进程要求对所分配的资源进⾏排它性控制，即在⼀段时间内某资源仅为⼀进程所占⽤。 请求和保持条件：当进程因请求资源⽽阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源在未使⽤完之前，不能剥夺，只能在使⽤完时由⾃⼰释放。 环路等待条件：在发⽣死锁时，必然存在⼀个进程–资源的环形链。 解决死锁 预防 破坏请求条件：⼀次性分配所有资源，这样就不会再有请求了； 破坏请保持条件：只要有⼀个资源得不到分配，也不给这个进程分配其他的资源： 破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源； 破坏环路等待条件：系统给每类资源赋予⼀个编号，每⼀个进程按编号递增的顺序请求资源，释放则相反。 避免 检测 解除 1. 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防⽌被挂起的进程 ⻓时间得不到资源）； 2. 撤销进程：强制撤销部分、甚⾄全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进 程代价的⾼低进⾏）； 3. 进程回退：让⼀个或多个进程回退到⾜以避免死锁的地步。进程回退时⾃愿释放资源⽽不是被剥夺。要求系统 保持进程的历史信息，设置还原点。 页面置换算法 先进先出队列法 最佳置换：淘汰未来最远将要使用的页，可以证明缺页数最少。 LRU 时钟置换算法：为每个页面设置一个访问位，将内存中的所有页面都通过链接指针链成一个循环队列. 用户态与内核态 内核态：处于内核态的 CPU 可以访问任意的数据，包括外围设备，⽐如⽹卡、硬盘等，处于内核态的 CPU 可以从⼀个程序切换到另外⼀个程序，并且占⽤ CPU 不会发⽣抢占情况，⼀般处于特权级 0 的状态我们称之 为内核态。 用户态：处于⽤户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，⽤户态下的 CPU 不允许独 占，也就是说 CPU 能够被其他程序获取。 用户态和内核态之间的切换tips:这里并不扎实，还需再看看。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"https://hideincode.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"OS","slug":"OS","permalink":"https://hideincode.github.io/tags/OS/"}]},{"title":"JVM","slug":"basic/JVM","date":"2017-04-30T16:00:00.000Z","updated":"2024-05-07T09:01:13.818Z","comments":true,"path":"2017/05/01/basic/JVM/","permalink":"https://hideincode.github.io/2017/05/01/basic/JVM/","excerpt":"","text":"JVM组成部分 类加载器 把代码转化成字节码 运行时数据区 字节码加载到内存 执行引擎 把字节码翻译成底层指令，交给CPU。 本地库接口 调用其他语言本地库接口 运行时数据区组成 线程共享区 方法区 存储虚拟机加载的类信息、常量、静态变量、编译后的代码。 别名：非堆。 不需要连续内存。 可以不实现垃圾收集。 会有OOM 分为运行时常量池、直接内存 堆 存放对象实例，为对象实例分配内存。 垃圾收集器管理主要区域，垃圾堆。 内存空间上逻辑连续即可，会有OOM. 线程私有区 栈 方法执行时的内存模型：方法执行时会创建栈帧，用于变量、操作数、动态链接、方法出口等。方法的调用到完成意味着栈帧在栈中入栈和出栈的过程。 局部变量表的单位时槽（slot）,在编译器分配完成。 会有OOM，SOE两种异常。 本地方法栈 区别于栈：为虚拟机用到的本地方法执行服务。 程序计数器 字节码的行号指示器，分支、循环跳转、异常处理、线程恢复都依赖于此。唯一一处没有OOM的区域。 对象大小计算 空Object是8byte Object obj &#x3D; new Object();会占据4 + 8个字节，栈中保存引用也要4byte空间。 对对象内存分配时都是以 8 的整数倍来分 boolean 1byte 对象的定位方式 句柄 引用中存储句柄地址，对象被移动时只会改变句柄中的实例数据指针，引用不用改变。 指针 速度快，存的是对象的地址。 垃圾回收思路 引用计数 每个对象实例都有个引用计数器； 给对象分配变量时，就将计数器+1； 同理，引用超过生命周期或者变量被赋新值时，计数器-1； 计数器为0时实例会被垃圾收集； 优点：快 缺点：无法检测循环引用 可达性分析 当成有向图处理 从GC Roots对象除法，包括 虚拟机栈中引⽤的对象（栈帧中的本地变量表）； ⽅法区中类静态属性引⽤的对象； ⽅法区中常量引⽤的对象； 本地⽅法栈中 JNI（Native⽅法）引⽤的对象 几个内存泄漏的场景 静态集合类引起的内存泄漏； 当集合⾥⾯的对象属性被修改后，再调⽤ remove() ⽅法时不起作⽤； 监听器：释放对象的时候没有删除监听器； 各种连接：⽐如数据库连接（dataSourse.getConnection()），⽹络连接(socket) 和 IO 连接，除⾮其显式的 调⽤了其 close() ⽅法将其连接关闭，否则是不会⾃动被 GC 回收的； 内部类：内部类的引⽤是⽐较容易遗忘的⼀种，⽽且⼀旦没释放可能导致⼀系列的后继类对象没有释放； 单例模式：单例对象在初始化后将在 JVM 的整个⽣命周期中存在（以静态变量的⽅式），如果单例对象持有 外部的引⽤，那么这个对象将不能被 JVM 正常回收，导致内存泄漏 尽量避免内存泄漏 尽量不要使用static成员变量，减少生命周期。 即使关闭资源 不用的对象考虑手动设置为null 常见垃圾回收算法 标记清除 Mark-Sweep 从根集合GC Roots扫描，对存活对象进行标记，在扫描所有标记对象进行回收。 不需要对象的移动 会造成内存碎片；原因是直接回收了不存活得对象。 复制算法 Copying 把堆分成一个对象面和多个空闲面 在对象面上分配空间，对象面满了后就复制到空闲面，形成对调。 不会有内存碎片。 标记-整理算法 在标记清理的同时将存活对象向左边空闲空间移动 解决内存碎片问题 分代收集算法 堆区域 老年代 少量需要回收 新生代 大量需要回收 永久代 分代收集算法 年轻代 复制为主 所有新生对象都在新生代 按照8：1：1分成一个eden区和两个survivor区，大部分对象在eden中生成。 回收时，先将eden区的复制到survivor0区，然后情况eden区，如果survivor0区满了后，将eden区和0区的复制到survivor1区，然后情空eden和0区，交换0区和1区，如此往复。 当1区也放不下时，直接放到老年代 当老年代也放不下的时候，触发一次Full GC，也叫Major GC. 老年代 以标记整理为主 在年轻代中经历多次垃圾回收仍然存活的对象，放入老年代。 内存比新生代大很多，大概1：2。 触发Full GC的概率比较低。 CMS垃圾收集器 初始标记：记录下直接与 root 相连的对象，暂停所有的其他线程，速度很快； 并发标记：同时开启 GC 和⽤户线程，⽤⼀个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并 不能保证包含当前所有的可达对象。因为⽤户线程可能会不断的更新引⽤域，所以 GC 线程⽆法保证可达性分 析的实时性。所以这个算法⾥会跟踪记录这些发⽣引⽤更新的地⽅。 重新标记：重新标记阶段就是为了修正并发标记期间因为⽤户程序继续运⾏⽽导致标记产⽣变动的那⼀部分对 象的标记记录。【这个阶段的停顿时间⼀般会⽐初始标记阶段的时间稍⻓，远远⽐并发标记阶段时间短】； 并发清除：开启⽤户线程，同时 GC 线程开始对为标记的区域做清扫。 优点：并发收集、低停顿 对CPU资源敏感、无法处理浮动垃圾、使用标记清除会有大量碎片。 G1垃圾收集器 力求最优解的收集器 把堆分成多个region的做法，利用分代的思想，优先处理活跃对象小的。 使用监控工具调优1、堆信息查看 可查看堆空间⼤⼩分配（年轻代、年⽼代、持久代分配） 提供即时的垃圾回收功能 垃圾监控（⻓时间监控回收情况） 查看堆内类、对象信息查看：数量、类型等 对象引⽤情况查看 有了堆信息查看⽅⾯的功能，我们⼀般可以顺利解决以下问题： 年⽼代年轻代⼤⼩划分是否合理 内存泄漏 圾回收算法设置是否合理 2、线程监控线程信息监控：系统线程数量 线程状态监控：各个线程都处在什么样的状态下 Dump 线程详细信息：查看线程内部运⾏情况 死锁检查 3、 热点分析 CPU 热点：检查系统哪些⽅法占⽤的⼤量 CPU 时间； 内存热点：检查哪些对象在系统中数量最⼤（⼀定时间内存活对象和销毁对象⼀起统计）这两个东⻄对于系统 优化很有帮助。我们可以根据找到的热点，有针对性的进⾏系统的瓶颈查找和进⾏系统优化，⽽不是漫⽆⽬的 的进⾏所有代码的优化。 4、快照快照是系统运⾏到某⼀时刻的⼀个定格。在我们进⾏调优的时候，不可能⽤眼睛去跟踪所有系统变化，依赖快照功 能，我们就可以进⾏系统两个不同运⾏时刻，对象（或类、线程等）的不同，以便快速找到问题。 举例说，我要检查系统进⾏垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进⾏垃圾回收 前后，分别进⾏⼀次堆情况的快照，然后对⽐两次快照的对象情况。 5、内存泄露检查 内存泄漏是⽐较常⻅的问题，⽽且解决⽅法也⽐较通⽤，这⾥可以᯿点说⼀下，⽽线程、热点⽅⾯的问题则是具体 问题具体分析了。 内存泄漏⼀般可以理解为系统资源（各⽅⾯的资源，堆、栈、线程等）在错误使⽤的情况下，导致使⽤完毕的资源 ⽆法回收（或没有回收），从⽽导致新的资源分配请求⽆法完成，引起系统错误。内存泄漏对系统危害⽐较⼤，因 为它可以直接导致系统的崩溃 jvm常见参数设置 堆设置 -Xms：初始堆⼤⼩ -Xmx：最⼤堆⼤⼩ -XX:NewSize&#x3D;n：设置年轻代⼤⼩ -XX:NewRatio&#x3D;n：设置年轻代和年⽼代的⽐值。如:为3，表示年轻代与年⽼代⽐值为 1：3，年轻代占整个年轻代 年⽼代和的 1&#x2F;4 -XX:SurvivorRatio&#x3D;n：年轻代中 Eden 区与两个 Survivor 区的⽐值。注意 Survivor 区有两个。如：3，表示 Eden：Survivor&#x3D;3：2，⼀个Survivor区占整个年轻代的 1&#x2F;5 -XX:MaxPermSize&#x3D;n：设置持久代⼤⼩ 收集器设置 -XX:+UseSerialGC：设置串⾏收集器 -XX:+UseParallelGC：设置并⾏收集器 -XX:+UseParalledlOldGC：设置并⾏年⽼代收集器 -XX:+UseConcMarkSweepGC：设置并发收集器 垃圾回收统计信息 -XX:+PrintGC：开启打印 gc 信息 -XX:+PrintGCDetails：打印 gc 详细信息 -XX:+PrintGCTimeStamps -Xloggc:filename 并⾏收集器设置 -XX:ParallelGCThreads&#x3D;n：设置并⾏收集器收集时使⽤的 CPU 数 -XX:MaxGCPauseMillis&#x3D;n：设置并⾏收集最⼤暂停时间 -XX:GCTimeRatio&#x3D;n：设置垃圾回收时间占程序运⾏时间的百分⽐ 并发收集器设置 -XX:+CMSIncrementalMode：设置为增量模式。适⽤于单 CPU 情况 -XX:ParallelGCThreads&#x3D;n：设置并发收集器年轻代收集⽅式为并⾏收集时，使⽤的 CPU 数。并⾏收集线程数 双亲委派机制 这个名字起的不好，叫父加载委托更合适，难道翻译也是被女权打怕了？ 类加载器层级 根加载器 拓展加载器 系统类加载器 自定义加载器 一个类收到加载请求后，会先去委派父类加载器完成，逐步往上，如果父类完不成的时候就才会用当前加载器加载。 好处：最终都由顶端的类加载器进行加载，保证类在多个加载器中都是同一个类。如果每个类使用自己的加载器，确保了类的全局唯一性。 主要实现看java.lang.ClassLoader 的loadClass()⽅法。 自定义加载，需要继承loadClass() ,重写findClass() 方法; 打破双亲委派机制 自己写个类加载器 重写loadClass() 重写findClass() 合适打破双亲委派机制？ Java 中所有涉及 SPI 的加载动作 加载核心类库需要用户代码，如JDBC使用DriverManager.getConnection获取连接使用双亲委派就会有问题。 Java内存模型 又称JMM，内存和CPU处理速度不一样，需要高速缓存，多核处理器又会有多个缓存，需要和主存保持一致。而JMM就是为了保证内存访问一致性出现的。 内存行为规范： 关于主内存与⼯作内存之间的具体的交互协议，即：⼀个变量如何从主内存拷⻉到⼯作内存、如何从⼯作内存同步 主内存之类的实现细节，Java内存模型中定义⼀下8种操作来完成： lock(锁定)：作⽤于主内存的变量。它把⼀个变量标志为⼀个线程独占的状态； unlock(解锁)：作⽤于主内存的变量，它把处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁 定； read(读取)：作⽤于主内存的变量，它把⼀个变量的值从主内存传输到线程的⼯作内存中，以便随后的load动 作使⽤； load(载⼊)：作⽤于⼯作内存的变量，它把read操作从主内存中得到变量值放⼊⼯作内存的变量的副本中； use(使⽤)：作⽤于⼯作内存的变量， 它把⼯作内存中⼀个变量的值传递给执⾏引擎，每当虚拟机遇到⼀个需 要使⽤到变量的值的字节码指令时将会执⾏这个操作； assign(赋值)：作⽤于⼯作内存的变量。它把⼀个从执⾏引擎接收到的值赋值给⼯作内存的变量，每当虚拟机 遇到需要给⼀个变量赋值的字节码时执⾏这个操作； store(存储)：作⽤于⼯作内存的变量。它把⼀个⼯作内存中⼀个变量的值传递到主内存中，以便随后的write 操作使⽤； write(写⼊)：作⽤于主内存的变量。它把store操作从⼯作内存中得到的变量的值放⼊主内存的变量中。 如果要把⼀个变量从⼯作内存复制到⼯作内存，那就要按顺序执⾏ read 和 load 操作，如果要把变量从⼯作内存同 步回主内存，就要按顺序执⾏ store 和 write 操作。 上诉 8 种基本操作必须满⾜的规则： 不允许 read 和 load、store 和 write 操作之⼀单独出现； 不允许⼀个线程丢弃它的最近的 assign 操作，即变量在⼯作内存中改变之后必须把该变化同步回主内存； 不允许⼀个线程⽆原因地（没有发⽣过任何 assign 操作）把数据从线程的⼯作内存同步回主内存中； ⼀个新的变量只能在主内存中“诞⽣”，不允许在⼯作内存中直接使⽤⼀个未被初始化（load 或 assign）的变 量，换句话说就是对⼀个变量实施 use 和 store 操作之前，必须执⾏过了 assign 和 load 操作； ⼀个变量在同⼀时刻只允许⼀条线程对其进⾏ lock 操作，但 lock 操作可以被同⼀线程᯿复执⾏多次，多次执 ⾏ lock 后，只有执⾏相同次数的 unlock，变量才会被解锁； 如果对⼀个变量执⾏ lock 操作，将会清空⼯作内存中此变量的值，在执⾏引擎使⽤这个变量前，需要᯿新执 ⾏ load 或 assign 操作初始化变量的值； 如果⼀个变量事先没有被 lock 操作锁定，则不允许对它执⾏ unlock 操作，也不允许去 unlock ⼀个被其他线 程锁定主的变量； 对⼀个变量执⾏ unlock 操作之前，必须先把此变量同步回主内存中（执⾏ store 和 write 操作）","categories":[{"name":"基础知识","slug":"基础知识","permalink":"https://hideincode.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://hideincode.github.io/tags/JVM/"}]}],"categories":[{"name":"基础知识","slug":"基础知识","permalink":"https://hideincode.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"开发部署","slug":"开发部署","permalink":"https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"},{"name":"解题技巧","slug":"解题技巧","permalink":"https://hideincode.github.io/categories/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"},{"name":"系统设计","slug":"系统设计","permalink":"https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"},{"name":"源码分析","slug":"源码分析","permalink":"https://hideincode.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"name":"问题排查","slug":"问题排查","permalink":"https://hideincode.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"}],"tags":[{"name":"safe","slug":"safe","permalink":"https://hideincode.github.io/tags/safe/"},{"name":"devops","slug":"devops","permalink":"https://hideincode.github.io/tags/devops/"},{"name":"threads","slug":"threads","permalink":"https://hideincode.github.io/tags/threads/"},{"name":"concurrent","slug":"concurrent","permalink":"https://hideincode.github.io/tags/concurrent/"},{"name":"algo","slug":"algo","permalink":"https://hideincode.github.io/tags/algo/"},{"name":"socket","slug":"socket","permalink":"https://hideincode.github.io/tags/socket/"},{"name":"system design","slug":"system-design","permalink":"https://hideincode.github.io/tags/system-design/"},{"name":"code","slug":"code","permalink":"https://hideincode.github.io/tags/code/"},{"name":"error","slug":"error","permalink":"https://hideincode.github.io/tags/error/"},{"name":"design pattern","slug":"design-pattern","permalink":"https://hideincode.github.io/tags/design-pattern/"},{"name":"OS","slug":"OS","permalink":"https://hideincode.github.io/tags/OS/"},{"name":"JVM","slug":"JVM","permalink":"https://hideincode.github.io/tags/JVM/"}]}