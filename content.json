{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://hideincode.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2024-05-06T16:42:16.766Z","updated":"2024-05-06T16:42:16.766Z","comments":false,"path":"/404.html","permalink":"https://hideincode.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2024-05-06T16:42:16.766Z","updated":"2024-05-06T16:42:16.766Z","comments":false,"path":"about/index.html","permalink":"https://hideincode.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"文章分类","date":"2024-05-06T17:47:34.535Z","updated":"2024-05-06T17:47:34.535Z","comments":false,"path":"categories/index.html","permalink":"https://hideincode.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2024-05-06T16:42:16.766Z","updated":"2024-05-06T16:42:16.766Z","comments":true,"path":"links/index.html","permalink":"https://hideincode.github.io/links/index.html","excerpt":"","text":""},{"title":"书单","date":"2024-05-06T16:42:16.766Z","updated":"2024-05-06T16:42:16.766Z","comments":false,"path":"books/index.html","permalink":"https://hideincode.github.io/books/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2024-05-06T16:42:16.766Z","updated":"2024-05-06T16:42:16.766Z","comments":false,"path":"repository/index.html","permalink":"https://hideincode.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-05-06T17:48:59.185Z","updated":"2024-05-06T17:48:59.185Z","comments":false,"path":"tags/index.html","permalink":"https://hideincode.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"AC1337","slug":"algo/AC1337","date":"2024-05-06T17:45:50.000Z","updated":"2024-05-06T18:05:35.186Z","comments":true,"path":"2024/05/07/algo/AC1337/","permalink":"https://hideincode.github.io/2024/05/07/algo/AC1337/","excerpt":"","text":"AC1337 用于记录刷题的一些思路和技巧 算法可行性 数据规模 算法可接受时间复杂度 &lt;&#x3D; 10 O(n!) &lt;&#x3D; 20 O(2^n) &lt;&#x3D; 100 O(n^4) &lt;&#x3D; 500 O(n^3) &lt;&#x3D; 2500 O(n^2) &lt;&#x3D; 10^6 O(nlogn) &lt;&#x3D; 10^7 O(n) &lt;&#x3D; 10^14 O(sqrt(n)) - O(logn) - O(1) 线型处理逻辑存储已知情况 栈 单调栈，栈中元素为单调，下一个最大的元素。 成对出现的问题，用栈进行消消乐。 队列 单调队列 优先队列 树型处理逻辑回溯组合问题 无重复元素，可重复选择，组合出一个target; 下一层起点为i，这样保证只会从当前元素后开始往后选。 有重复元素，不可重复选择，组合出一个target; 排序，使得相同元素连在一起。 跳过相同元素。 从i + 1开始进入下层搜索。 排列问题 无重复元素，所有排列情况; 朴素版本(记录决策树): 无需start，需要判断元素使用情况(visited数组&#x2F;基于无重复直接在容器里面判断)。 进阶版本(交换元素): 考虑start后面的每个位置来填充start，知道start到达n;即通过交换i，start; 下一层为start+1，即下一个要填的位置; 这样[0，start]就是统计过的排列，[start+1，n-1]就是待统计的。 有重复元素，排列情况。 子集问题 组合没有顺序上的要求，只是选择上区别;排列是对顺序有要求。 无重复元素，找所有子集。 回溯:记录决策树的每一个结点即可 状态压缩:已知所有可能性，用二进制表示，记录每一这可能性;即二进制每一位表示是否选择。 有重复元素，找所有子集: 回溯:无重复情况+排序判断相邻元素去重。 状态压缩:无重复情况+排序判断相邻元素去重。即前一个元素相同但是没有被选择，那么选择当前情况必定重复。因为当前的情况之前肯定统计过了，考虑[1，2，2]的第二个2。。。 对重复元素排序处理:保证相同情况在同一层出现，出现一次就行了，后面都不再统计。 剪枝:有些时候需要贪心的先解决大的，大的搞不定小的肯定也不行。 递归玩法 定义状态 做出选择 缩小范围 上报结果 数组 前缀和 计数 双指针 二分法 找确定的目标值 猜数字 极大化极小，极小化极大。就是使得每部分的最大值最小。 这种问题的一般结构就是，多种分配情况到达分组目标，每种情况中又会有最大值，判断所有情况中的最小的最大值。 具体题目模型参考: 分割数组的最大值 也可以称之为: 根据答案二分。 旋转有序数组，旋转后分成两部分 两部分都是上升的 后部分小于前部分 利用和mid和left的值的对比，判断target处于哪个部分。 滑动窗口 1234567int i = 0;for (int j = 0; j &lt; n; j++) &#123; while (check()) &#123; i++; //记录结果 &#125;&#125; 原地哈希 O(n)时间内使得数组有序，类似于计数排序，只不过把输入数组本身当成桶。 对于每个nums[i]，放入到对应下标位置。 再次遍历，没有归位的就是缺少的值。 一般有标记法和交换法 标记法 对归位后的数字进行标记，提前把负数改成N+1 把值对应的位置上的值加上负号，即nums[nums[i] - 1] &#x3D; -abs(nums[nums[i] - 1]) 没有标记为负数的就是没有归位的，即为缺失之数 交换法： 通过交换把值放到对应下标上，比如nums[0]放入nums[nums[0]] 再次遍历找出没有放入下标的值即可 动态规划 前缀和: 前缀和其实也是一种动态规划，拥有最优子结构，用于范围求和。而且前缀和中元素一般都是递增的，可以用二分搜索。 后缀和：有些情况需要求i左边的结果和i右边的结果，来简化计算，需要同时求前缀和与后缀和。 背包问题 0-1背包：物品只能用一次，取决于选与不选。 一维空间:想明白遍历顺序，两个循环可否交换。 1234567for(int i=0;i&lt;cnt;i++)&#123; //由大到小，不可与外层交换。 for(int j=cap;i&gt;=0;j--)&#123; //求容量为j时，最大值。 dp[j]=max(dp[j]，dp[j-w[i]]+v[i]); &#125;&#125; 完全背包: 物品可以重复选择，每次选择一个一维空间:遍历顺序，循环可否交换位置。 如果求组合数就是外层for循环遍历物品，内层for遍历背包。 如果求排列数就是外层for遍历背包，内层for循环遍历物品。 123456for(int i=0;i&lt;cnt;i++)&#123; //又小到大，可以交换循环位置。 for(int j=0;j&lt;=cap;j++)&#123; dp[j]=max(dp[j]，dp[j-w[i]]+v[i]); &#125;&#125; 遍历顺序与排列组合的关系：外物内容是组合，外容内物是排列。 如果求组合数就是外层for循环遍历物品个数，内层for遍历背包容量。 如果求排列数就是外层for遍历背包容量，内层for循环遍历物品个数。 多重背包:物品有次数限制 123456789for(int i = 0; i &lt; weight。length; i++) &#123; // 遍历物品 for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量 // 以上为01背包，然后加一个遍历个数 for (int k = 1; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= 0; k++) &#123; // 遍历个数 dp[j] = Math。max(dp[j]， dp[j - k * weight[i]] + k * value[i]); &#125; System。out。println(Arrays。toString(dp)); &#125;&#125; 01背包一维化理解 一维化的本质:就是把二维的每一行依次用一行表示。用新一行的结果覆盖老的结果。由于二维情况可以，计算当前行需要上一行的值。如果只保留一行的话，那么新计算的结果就要重新写入数组。这时候不能覆盖上一行已经计算好的。从左往右的覆盖的话，那么计算下个j用的就是当前的i，而非i-1。从右往左的覆盖:用的还是上一行的数据。 分组背包：每组只能选一个 回文串问题 差分数组：解决频繁范围修改，但是不用频繁查询的问题。 [i， j]范围内全部+1，使用额外数组dif[i]+1，dif[j+1]-1。 用dif数组还原修改结果。 不需要首项 123for(int i=1;i&lt;diff。length;i++)&#123; dif[i]+=dif[i-1];&#125; 需要首项 1234dif[0]=nums[0];for(int i=1;i&lt;diff。length;i++)&#123; dif[i]=dif[i-1]+nums[i];&#125; 链表 dummy节点简化代码。 快慢指针： 环形链表 两链表相交 删除重复值 翻转链表：转化为基础的翻转链表。 树 这里指的是单纯的内存意义上的物理树，和逻辑树不同。 DFS(先序，中序，后序，mirrors)，BFS 二叉搜索树的中序遍历是升序 数的直径 公共祖先问题 树的生成 插入操作基于代码模式 root。next&#x3D;f(root。next，。。。) 一般分治而成，即找到根节点后把区间缩小，逐步生成 ​ 5。 树上dp 图 物理结构 ：邻接表、临界矩阵、边的数组、父结点数组、链式向前星。 求联通分量，并查集、dfs、tarjan、Kosaraju 找环： dfs bfs 拓扑排序：依赖顺序问题 必须是有向无环图(DAG) DFS的逆后序，即把dfs的后序结果用栈保存起来。 BFS:把入度为0的先放入，然后遍历到一个结点就减少这个结点的入度。 最小生成树： Prim：点按照已经生成的森林最近的距离加入树 Kruskal：边按照权重排序加入生成树 最短路： 无权最短路：bfs 非负权重最短路：Dijstra，理解松弛操作，就是bfs加了优先队列。 负权重：Bellman-Ford，复杂度O(VE) 欧拉回路 基环内向树：图中有环，环上有些节点会有分支，形成有一个有环的树。常见解法： 用拓扑排序找出环 判断节点是在链表上，还是在环上 二分图判定 DFS 时间戳，即Tarjan相关算法。 字符串 排序问题 计数排序 分组问题，通过组号分发到数组。 基数排序 LSD 定长字符串，从右往左排序。 MSD 随机字符串，从左往右排序。 三向快排 处理有大量重复键的排序问题 常规比较排序 查询问题 Trie(字典树，前缀树) Map 子串查找 暴力法 滑动窗口 KMP 了解DFA BM RK 正则表达式 了解NFA 数据压缩 (数据都可以转成二进制，二进制流都可以理解为字符串) 双位压缩 对于DNA的4种碱基ACTG，可以用11 00 01 10 四种方式表达，但是只用两位。 游程编码(Run-Length Encoding) 首先转为二进制，将连续相同部分进行编码，如0000000000000001111111000000011111111111记成15个0，7个1，7个0，11个1，由于01交换出现，所以只对长度就行，把15 7 7 1改成二进制1111 0111 0111 1011，完成压缩。 霍夫曼(Huffman) 通过字符出现频率压缩 LZW 位运算 a | b：计算并集 a &amp; b： 求a和b的最长公共前缀后面补齐0。如1010与1000得到1000 a ^ b：不进位相加 汉明距离：x^(x-1) 最低位的1变成0。 如110 ^ (100 - 1)结果为100 lowbit: x &amp; (-x) 截断x最低位的1及其后缀，必定是2的n次幂。 如1100 &amp; (-1100）时结果为100 求子集: 求k的二进制子集，针对中的二进制为1的位开始进行减法，判断数字k的二进制子集， 像枚举(2^k-1) ~ 0一样枚举其子集 12345int sub = k;do &#123; //sub就是一个子集 sub = (sub - 1) &amp; k;&#125; while(sub != k); 去掉最后一位 | (101101-&gt;10110) | x &gt;&gt;1 在最后加一个0 | (101101-&gt;1011010) | x &lt;&lt;1 在最后加一个1 | (101101-&gt;1011011) | x &lt;&lt; 1+1 把最后一位变成1 | (101100-&gt;101101) | x or 1 把最后一位变成0 | (101101-&gt;101100) | x or 1-1 最后一位取反 | (101101-&gt;101100) | x xor 1 把右数第k位变成1 | (101001-&gt;101101，k&#x3D;3) | x or (1 &lt;&lt; (k-1)) 把右数第k位变成0 | (101101-&gt;101001，k&#x3D;3) | x and not(1 &lt;&lt; (k-1)) 右数第k位取反 | (101001-&gt;101101，k&#x3D;3) | x xor (1 &lt;&lt; (k-1)) 取末三位 | (1101101-&gt;101) | x and 7 取末k位 | (1101101-&gt;1101，k&#x3D;5) | x and (1 &lt;&lt; k-1) 取右数第k位 | (1101101-&gt;1，k&#x3D;4) | x &gt;&gt; (k-1) and 1 把末k位变成1 | (101001-&gt;101111，k&#x3D;4) | x or (1 &lt;&lt; k-1) 末k位取反 | (101001-&gt;100110，k&#x3D;4) | x xor (1 &lt;&lt; k-1) 把右边连续的1变成0 | (100101111-&gt;100100000) | x and (x+1) 把右起第一个0变成1 | (100101111-&gt;100111111) | x or (x+1) 把右边连续的0变成1 | (11011000-&gt;11011111) | x or (x-1) 取右边连续的1 | (100101111-&gt;1111) | (x xor (x+1)) &gt;&gt; 1 数学数论MOD运算 同余定理:a MOD M&#x3D;&#x3D;b MOD M 等价于 (a-b) MOD &#x3D;&#x3D; 0 a + b会溢出: (a + b) mod M &#x3D; (a mod M + b mod M) mod M 防止出现负数 +M:(a - b) % M &#x3D; (a % M - b % M + M) % M (ab)%M &#x3D; (a%M)(b%M)%M 对于MOD除法 这里要求b和M互质，且M是质数。 不能这么玩（a&#x2F;b) % M !&#x3D; ((a%M) &#x2F; (b%M)) % M 正确玩法 求逆元+费马小定理 求（a&#x2F;b) % M问题转化为 求b的逆元，即a*b^(-1)%M，此时只需求b^(-1)的值 b* b^(-1)与1模M同余 费马小定理得：M为质数时，b^(M - 1) 与1模M同余 可得b* b^(M - 2)与1模M同余 取b的逆元为b^(M-2) 最终（a&#x2F;b) % M &#x3D;&#x3D; a * pow(b，M - 2) % M，pow为求幂，可用快速幂实现。 最大公因数与最小公倍数 gcd(a，b) &#x3D;&#x3D; gcd(b，a) gcd(a，b) &#x3D;&#x3D; gcd(a-b， b) (a &gt; b) gcd(a，b) &#x3D;&#x3D; gcd(a%b， b) gcd(a，b，c) &#x3D;&#x3D; gcd(gcd(a，b)，c) gcd(ka，kb) &#x3D;&#x3D; kgcd(a，b) 最小公倍数模板 12345//lcm(a，b) = (a * b) / gcd(a，b)//先乘后除防溢出public long lcm(long a， long b) &#123; return a / gcd(a， b) * b;&#125; 组合数取余 从n中取m个元素，记为C(n， m) &#x3D; n! &#x2F; (m! * (n - m)!)，又知C(n， m) &#x3D; C(n - 1， m - 1) + C(n - 1， m); 求C(n， m) % M O(n^2) 123456789101112int M = (int)1e9+7;long C[1005][1005];void getC(int n)&#123; for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=i;j++)&#123; if(j==0 || j==i) C[i][j]=1; else C[i][j]=(C[i-1][j-1]+C[i-1][j]) % M; &#125; &#125;&#125; O(n) 123456789101112131415//逆元方法int mo = (int)1e9 + 7;long C(long n，long m)&#123; long M=0，inv[N]，mul[N]，invMul[N]; while(M&lt;=n)&#123; if(M)&#123; inv[M]=M==1?1:(mo-mo/M)*inv[mo%M]%mo; mul[M]=mul[M-1]*M%mo; invMul[M]=invMul[M-1]*inv[M]%mo; &#125; else mul[M]=1，invMul[M]=1; M++; &#125; return mul[n]*invMul[m]%mo*invMul[n-m]%mo;&#125; 如果对质数求余，可用Lucas定理在O(n)复杂度解决 12345long Lucas(long n，long m，long p)&#123; long ans=1; while(n|m)ans=ans*C(n%P，m%P)%P，n/=P，m/=P; return ans;&#125; 概率与统计 这类问题离不开随机函数 rand7生成rand10 蒙特卡洛方法之拒绝采样 (randX() - 1)*Y + randY()可以等概率的生成[1， X * Y]范围的随机数 大范围randx生成小范围randy:可用randx%y+1 x必须是y的倍数才能等概率的生成，所以如果不是倍数，那么对于生成的不符合的值要去掉。即一直循环到合适的。 水塘抽样 详见相同概率取元素 数据结构设计 栈生成队列 队列生成栈 LFU LRU 经典算法 线性筛：用于线性速度搜索n以内的质数 扫描线：矩阵相交求面积、周长、点的个数问题。 倍增：快速幂、最近公共祖先 摩尔投票法：消消乐。 计算根号2：牛顿迭代法 TopK问题 堆(优先队列) O(nlogk) 快速选择 O(n) 二叉搜索树O(nlogk) 排序 多路归并问题 快速选择 逆序对","categories":[{"name":"算法","slug":"算法","permalink":"https://hideincode.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://hideincode.github.io/tags/algo/"}]},{"title":"经典问题","slug":"algo/经典例题","date":"2024-05-06T17:45:50.000Z","updated":"2024-05-06T18:06:15.130Z","comments":true,"path":"2024/05/07/algo/经典例题/","permalink":"https://hideincode.github.io/2024/05/07/algo/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/","excerpt":"","text":"经典问题动态规划:求最值: 问题 给定目标，找到达到目标的最小（最大）成本&#x2F;路径&#x2F;总和。 答案 在当前状态之前的所有可能路径中选择最小（最大）路径，然后为当前状态添加值。 //状态转移方程 routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i] 1234567891011* ``` for (int i = 1; i &lt;= target; ++i) &#123; for (int j = 0; j &lt; ways.size(); ++j) &#123; if (ways[j] &lt;= i) &#123; dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ; &#125; &#125; &#125; return dp[target] --- [746. Min Cost Climbing Stairs Easy](https://leetcode-cn.com/problems/min-cost-climbing-stairs) [64. Minimum Path Sum Medium](https://leetcode-cn.com/problems/minimum-path-sum) [322. Coin Change Medium](https://leetcode-cn.com/problems/coin-change) [931. Minimum Falling Path Sum Medium](https://leetcode-cn.com/problems/minimum-falling-path-sum) [983. Minimum Cost For Tickets Medium](https://leetcode-cn.com/problems/minimum-cost-for-tickets) [650. 2 Keys Keyboard Medium](https://leetcode-cn.com/problems/2-keys-keyboard) [279. Perfect Squares Medium](https://leetcode-cn.com/problems/perfect-squares) [1049. Last Stone Weight II Medium](https://leetcode-cn.com/problems/last-stone-weight-ii) [120. Triangle Medium](https://leetcode-cn.com/problems/triangle) [474. Ones and Zeroes Medium](https://leetcode-cn.com/problems/ones-and-zeroes) [221. Maximal Square Medium](https://leetcode-cn.com/problems/maximal-square) [322. Coin Change Medium](https://leetcode-cn.com/problems/coin-change) [1240. Tiling a Rectangle with the Fewest Squares Hard](https://leetcode-cn.com/problems/tiling-a-rectangle-with-the-fewest-squares) [174. Dungeon Game Hard](https://leetcode-cn.com/problems/dungeon-game) [871. Minimum Number of Refueling Stops Hard](https://leetcode-cn.com/problems/minimum-number-of-refueling-stops) --- 方案计数 问题 给定一个目标，找到许多达到目标的独特方法。要分清分类计数原理,分步计数原理; 答案 总结所有可能的方法以达到当前状态。 routes[i] = routes[i-1] + routes[i-2], ... , + routes[i-k] 1234567891011* ```java for (int i = 1; i &lt;= target; ++i) &#123; for (int j = 0; j &lt; ways.size(); ++j) &#123; if (ways[j] &lt;= i) &#123; dp[i] += dp[i - ways[j]]; &#125; &#125; &#125; return dp[target] --- [70. Climbing Stairs easy](https://leetcode-cn.com/problems/climbing-stairs) [62. Unique Paths Medium](https://leetcode-cn.com/problems/unique-paths) [1155. Number of Dice Rolls With Target Sum Medium](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum) [688. Knight Probability in Chessboard Medium](https://leetcode-cn.com/problems/knight-probability-in-chessboard) [494. Target Sum Medium](https://leetcode-cn.com/problems/target-sum) [377. Combination Sum IV Medium](https://leetcode-cn.com/problems/combination-sum-iv) [935. Knight Dialer Medium](https://leetcode-cn.com/problems/knight-dialer) [1223. Dice Roll Simulation Medium](https://leetcode-cn.com/problems/dice-roll-simulation) [416. Partition Equal Subset Sum Medium](https://leetcode-cn.com/problems/partition-equal-subset-sum) [808. Soup Servings Medium](https://leetcode-cn.com/problems/soup-servings) [790. Domino and Tromino Tiling Medium](https://leetcode-cn.com/problems/domino-and-tromino-tiling) [801. Minimum Swaps To Make Sequences Increasing](https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences) [673. Number of Longest Increasing Subsequence Medium](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence) [63. Unique Paths II Medium](https://leetcode-cn.com/problems/unique-paths-ii) [576. Out of Boundary Paths Medium](https://leetcode-cn.com/problems/out-of-boundary-paths) [1269. Number of Ways to Stay in the Same Place After Some Steps Hard](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps) [1220. Count Vowels Permutation Hard](https://leetcode-cn.com/problems/count-vowels-permutation) --- 区间DP 问题 给定一组数字，考虑到当前数字以及从左侧和右侧可获得的最佳值，可以找到问题的最佳解决方案。 答案 找到每个间隔的所有最佳解决方案，并返回最佳答案。 dp[i][j] = dp[i][k] + result[k] + dp[k+1][j] 123456789101112* ```java for(int l = 1; l&lt;n; l++) &#123; for(int i = 0; i&lt;n-l; i++) &#123; int j = i+l; for(int k = i; k&lt;j; k++) &#123; dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]); &#125; &#125; &#125; return dp[0][n-1] --- [1130. Minimum Cost Tree From Leaf Values Medium](https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values) [96. Unique Binary Search Trees Medium](https://leetcode-cn.com/problems/unique-binary-search-trees) [1039. Minimum Score Triangulation of Polygon Medium](https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon) [546. Remove Boxes Medium](https://leetcode-cn.com/problems/remove-boxes) [1000. Minimum Cost to Merge Stones Medium](https://leetcode-cn.com/problems/minimum-cost-to-merge-stones) [312. Burst Balloons Hard](https://leetcode-cn.com/problems/burst-balloons) [375. Guess Number Higher or Lower II Medium](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii) --- 字符串上的DP 问题 此模式的一般问题陈述可能会有所不同，但大多数情况下会给您两个字符串，这些字符串的长度不大. 答案 这种模式中的大多数问题都需要一种可以接受O（n ^ 2）复杂度的解决方案。 // i - indexing string s1 // j - indexing string s2 for (int i = 1; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= m; ++j) &#123; if (s1[i-1] == s2[j-1]) &#123; dp[i][j] = /*code*/; &#125; else &#123; dp[i][j] = /*code*/; &#125; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637 --- [1143. Longest Common Subsequence Medium](https://leetcode-cn.com/problems/longest-common-subsequence) [647. Palindromic Substrings Medium](https://leetcode-cn.com/problems/palindromic-substrings) [516. Longest Palindromic Subsequence Medium](https://leetcode-cn.com/problems/longest-palindromic-subsequence) [1092. Shortest Common Supersequence Medium](https://leetcode-cn.com/problems/shortest-common-supersequence) [72. Edit Distance Hard](https://leetcode-cn.com/problems/edit-distance) [115. Distinct Subsequences Hard](https://leetcode-cn.com/problems/distinct-subsequences) [712. Minimum ASCII Delete Sum for Two Strings Medium](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings) [5. Longest Palindromic Substring Medium](https://leetcode-cn.com/problems/longest-palindromic-substring) --- ### 0-1背包问题* 问题 * 考虑使用和不使用当前状态的,做出你的选择* 答案 * 如果决定选择当前值，请使用先前的结果（忽略该值）； 反之亦然，如果您决定忽略当前值，请使用使用值的先前结果。 * ```java // i - indexing a set of values // j - options to ignore j values for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt;= k; ++j) &#123; dp[i][j] = max(&#123;dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]&#125;); dp[i][j-1] = max(&#123;dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]&#125;); &#125; &#125; --- [198. House Robber Easy](https://leetcode-cn.com/problems/house-robber) [121. Best Time to Buy and Sell Stock Easy](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock) [714. Best Time to Buy and Sell Stock with Transaction Fee Medium](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) [309. Best Time to Buy and Sell Stock with Cooldown Medium](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown) [123. Best Time to Buy and Sell Stock III Hard](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii) [188. Best Time to Buy and Sell Stock IV Hard](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv) --- 经典例题LIS：最长递增子序列 LCS：最长公共子串 MSA：最大和子数组 LPS：最长回文子串 ​ 常见面试思路题目 如何从大量的 URL 中找出相同的 URL？ 如何从大量数据中找出高频词？ 如何找出某一天访问百度网站最多的 IP？ 如何在大量的数据中找出不重复的整数？ 如何在大量的数据中判断一个数是否存在？ 如何查询最热门的查询串？ 如何统计不同电话号码的个数？ 如何从 5 亿个数中找出中位数？ 如何按照 query 的频度排序？ 如何找出排名前 500 的数？ 讲讲大数据中 TopK 问题的常用套路？","categories":[{"name":"算法","slug":"算法","permalink":"https://hideincode.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://hideincode.github.io/tags/algo/"}]},{"title":"模板","slug":"algo/模板","date":"2024-05-06T17:45:50.000Z","updated":"2024-05-06T18:04:02.085Z","comments":true,"path":"2024/05/07/algo/模板/","permalink":"https://hideincode.github.io/2024/05/07/algo/%E6%A8%A1%E6%9D%BF/","excerpt":"","text":"模板距离与个数 计算数组中i到j的距离:i - j 计算数组中i到j的元素个数: i - j + 1 前缀和一维 123456//对nums.length=n求前缀和//sum[i]:[0,i-1]的和int[] sum = new int[n+1]for(int i=0;i&lt;n;i++)&#123; sum[i+1]=sum[i]+nums[i];&#125; 二维 123456//对grid[][]求前缀和,grid.length=m,grid[0].length=nfor(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; sum[i+1][j+1]=sum[i][j+1]+sum[i+1][j]-sum[i][j]+grid[i][j]; &#125;&#125; 二维异或 12345678int m = matrix.length;int n = matrix[0].length;int[][] sum = new int[m+1][n+1];for(int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; sum[i+1][j+1]=sum[i][j+1]^sum[i+1][j]^sum[i][j]^matrix[i][j]; &#125;&#125; 连续值分组循环模板 哨兵法: 开头定义一个哨兵,相邻比较。 1234567891011int i = 0;while(i &lt; n) &#123; int start = i; int cnt = 0 while (i &lt; n - 1 &amp;&amp; nums[i] == nums[i + 1])&#123; i++; &#125; dist= i-start; cnt = i-start+1; i += 1&#125; 标记法: 12345678//相同的标记一下for(int i=0;i&lt;n;i++)&#123; if(nums[i]%2==0)&#123; cnt++; &#125;else&#123; cnt=0; &#125;&#125; 归并排序的merge操作:合并两个有序数组123456789101112131415161718int[] aux;void merge(int[] nums,int lo,int mid,int hi)&#123; int p = lo; int q = mid+1; System.arraycopy(nums,lo,aux,lo,hi-lo+1); for(int i=lo;i&lt;hi;i++)&#123; if(p&gt;mid)&#123; nums[i]=aux[q++]; &#125;else if(q&gt;hi)&#123; nums[i]=aux[p++]; &#125;else if(nums[p]&lt;nums[q])&#123; nums[i]=nums[p]; &#125;else &#123; nums[i]=nums[q]; &#125; &#125;&#125; 辗转相除法求最大公约数123456int gcd(int p,int q) &#123; if(q == 0)&#123; return p; &#125; return gcd(q, p % q);&#125; partition操作：用于O(n)求topK或者快排。123456789101112131415//跑的快的版本,使用快慢指针.int partition(int[] a,int lo, int hi)&#123; int pivot = a[lo]; //j指向处理好的小范围. int j=lo; for(int i=lo+1;i&lt;=hi;i++)&#123; //把小的调换到前面去,i一直标记大的 if(a[i]&lt;pivot)&#123; swap(a,++j,i); &#125; &#125; //把轴放中间 swap(a,lo,j); return j;&#125; 12345678910111213141516171819//好理解的版本,使用双向指针.int partition(int[] a, int lo,int hi)&#123; int pivot = a[lo]; int i=lo+1,j=hi; while(i&lt;=j)&#123; if(a[i]&lt;=pivot)&#123; i++; continue; &#125; if(a[j]&gt;=pivot)&#123; j--; continue; &#125; swap(a,i,j); &#125; swap(a,lo,j); return j;&#125; 堆排序的heapify操作:把输入的数组构建成一个完全二叉树堆是一个选择器,能在O(logN)时间选出最值 sink(k)把下标k的元素下沉到合适位置,swim(k)把下标为k的元素上浮到合适位置，这个过程叫做堆化（heapify) 一个堆只有n&#x2F;2个父节点. buildHeap就是把小堆合成大堆的过程 insert:加到数组结尾后swim delete最大值:swap(a[0],a[n-1]),把a[n-1]删除,a[0]进行sink. 123456789101112131415161718192021222324252627282930313233//构建大根堆:把数组a构建成a[0]为最大值的堆.public void buildMaxHeap(int[] a, int n) &#123; for (int i = n / 2; i &gt;= 0; i--) &#123; //每个父节点都要尝试调整 sink(a, i, n); &#125; &#125;//自底向上堆化.private void swim(int[] a,int k)&#123; while (k &gt; 0 &amp;&amp; a[(k-1)/2]&lt;a[k]) &#123; swap(a,(k-1)/2, k); k = (k-1)/2; &#125;&#125;//自顶向下堆化: 父,左,右,选出最大为新的父节点.private void sink(int[] a, int i, int n) &#123; int l = i * 2 + 1, r = i * 2 + 2, max = i; //找出父节点,左子节点,右子节点中的最大值的下标max. if (l &lt; n &amp;&amp; a[l] &gt; a[max]) &#123; max = l; &#125; if (r &lt; n &amp;&amp; a[r] &gt; a[max]) &#123; max = r; &#125; //当前父节点不是最大值,那么就要下沉 if (max != i) &#123; swap(a, i, max); sink(a, max, n); &#125;&#125; 树状数组:单点修改与区间查询 数组的区间查询首先考虑用前缀和,但是如果修改多于查询,那么就就要用到读和写都是O(n)的树状数组. 内存中的数据结构是数组,逻辑上是一棵树. x&amp;(-x):求x的最低位的1和后面0组成的数字,俗称lowbit操作. 1234567891011121314151617181920212223242526272829//原始数组长度int n;//逻辑树int[] tree;init(int n)&#123; this.n = n; tree = new int[n+1];&#125;//求最低位1和后面的0构成的数int lowbit(n)&#123; return n &amp; (-n);&#125;//把i处值增加dvoid update(int i,int d)&#123; while(i&lt;=n)&#123; tree[i]+=d; //所有父结点都要修改 i += lowbit(i); &#125;&#125;//查询tree中[1,i]的前缀和,即原数组中[0,i-1]的和int sum(int i)&#123; int sum = 0; while(i&gt;0)&#123; sum+=tree[i]; i-=lowbit[i]; &#125;&#125; 线段树: 区间修改与区间查询1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 /** * 线段树（动态开点）、区间修改 **/public class SegmentTreeDynamic &#123; class Node &#123; Node left, right; //val是子节点的和，add该节点所有对应的孩子节点都应该有此更新 int val, add; &#125; private Node root = new Node(); //// 在区间 [start, end] 中更新区间 [l, r] 的值，将区间 [l, r] ➕ val public void update(Node node, int start, int end, int l, int r, int val) &#123; if (l &lt;= start &amp;&amp; end &lt;= r) &#123; node.val += (end - start + 1) * val; node.add += val; return ; &#125; int mid = (start + end) &gt;&gt; 1; pushDown(node, mid - start + 1, end - mid); if (l &lt;= mid) update(node.left, start, mid, l, r, val); if (r &gt; mid) update(node.right, mid + 1, end, l, r, val); pushUp(node); &#125; //在[start, end]中搜[l, r]的和 public int query(Node node, int start, int end, int l, int r) &#123; if (l &lt;= start &amp;&amp; end &lt;= r) return node.val; int mid = (start + end) &gt;&gt; 1, ans = 0; pushDown(node, mid - start + 1, end - mid); if (l &lt;= mid) ans += query(node.left, start, mid, l, r); if (r &gt; mid) ans += query(node.right, mid + 1, end, l, r); return ans; &#125; //修改时，自上而下修改值。 private void pushUp(Node node) &#123; node.val = node.left.val + node.right.val; &#125; //查与改时，自上而下创建和修改节点。 //leftNum表示左节点为根的子树个数，rightNum同理。 private void pushDown(Node node, int leftNum, int rightNum) &#123; if (node.left == null) &#123; node.left = new Node(); &#125; if (node.right == null) &#123; node.right = new Node(); &#125; // 根据标记add修改 if (node.add == 0) &#123; return; &#125; //左节点和 = 左节点的标记 x 节点个数 node.left.val += node.add * leftNum; //同理 node.right.val += node.add * rightNum; // 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖 node.left.add += node.add; node.right.add += node.add; //标记下传完成，删除标记。 node.add = 0; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//单点修改的线段树class SegmentTree &#123; private int[] tree; private int[] arr; public SegmentTree(int[] nums) &#123; this.arr = nums; this.tree = new int[4 * nums.length]; if(arr.length!=0)&#123; buildTree(0,arr.length-1,0); &#125; &#125; private void buildTree(int start,int end,int root)&#123; if(start==end)&#123; tree[root]=arr[start]; return; &#125; int mid = (start + end) &gt;&gt;&gt; 1; int left = 2 * root + 1; int right = 2 * root + 2; buildTree(start,mid,left); buildTree(mid+1,end,right); tree[root]=tree[left]+tree[right]; &#125; public void update(int i, int val) &#123; update(0,arr.length-1,i,val,0); &#125; private void update(int start,int end,int idx, int val, int root)&#123; if(start==end)&#123; tree[root]=val; arr[idx] = val; return; &#125; int mid = (start + end) &gt;&gt;&gt; 1; int left = 2 * root + 1; int right = 2 * root + 2; if(idx&lt;=mid)&#123; update(start,mid,idx,val,left); &#125;else&#123; update(mid+1,end,idx,val,right); &#125; tree[root]=tree[left]+tree[right]; &#125; public int sumRange(int i, int j) &#123; return sum(0,arr.length-1,0,i,j); &#125; private int sum(int start,int end,int root, int l,int r)&#123; if(l&gt;end||r&lt;start)&#123; return 0; &#125; if(l&lt;=start&amp;&amp;r&gt;=end)&#123; return tree[root]; &#125; if(start==end)&#123; return tree[root]; &#125; int mid = (start + end) &gt;&gt;&gt; 1; int left = 2 * root + 1; int right = 2 * root + 2; int left_sum=sum(start,mid,left,l,r); int right_sum = sum(mid+1,end,right,l,r); return left_sum+right_sum; &#125;&#125; 快速乘: 计算x*n12345678910111213141516private long mul(int x, int n) &#123; long result = 0; while (n &gt; 0) &#123; //最低位是1,是有用的数字,放入结果 if ((n &amp; 1) == 1) &#123; //累计结果 result += x; &#125; //计算下一位 n &gt;&gt;= 1; //x翻倍 x += x; &#125; return result;&#125; 快速幂: 计算x^n123456789101112131415161718 private long pow(int x, int n) &#123; if (n == 0) &#123; return 1; &#125; int ans = 1; while (n &gt; 0) &#123; //最低位是1,是有用的数字,放入结果 if ((n &amp; 1) == 1) &#123; //累计结果 ans *= x; &#125; n &gt;&gt;= 1;//x取平方 x *= x; &#125; return ans; &#125; 简单解释: *快速乘: ** 53 &#x3D; 5 * (11)2 &#x3D; 5 * ( (10)2 + (1)2) &#x3D; 5 * (10)2 + 5*1 &#x3D; (5 * 21 * 1 + 5 * 20 * 0) + 5 * 1&#x3D; ((5+5) * 1 + (5) * 0) +5 &#x3D; 15 快速幂: 5^3 &#x3D; 5 ^ (11)2 &#x3D; 5 ^ ( (10)2 + (1)2) &#x3D; 5^ (10)2 * 5^1 &#x3D; 5 ^ (2 * 1 + 1 * 0) * 5 &#x3D; 5 * 5 * 5 &#x3D; 125 一般用于防止爆数据,加快计算速度. 二维数组遍历方向问题 a b c d e f g h i j k l 从对角线开始,斜向遍历 ↘ ↘ ↘ 123456789101112131415161718192021222324252627public static void main(String[] args) &#123; int m = 3; int n = 8; char[][] cs = new char[m][n]; for (int i = 0; i &lt; m * n; i++) &#123; cs[i / n][i % n] = (char) (&#x27;a&#x27; + i); &#125; for (char[] c : cs) &#123; System.out.println(c); &#125; //斜线序号,给每条斜线标个序号 for (int k = 0; k &lt; n; k++) &#123; //行坐标,每条斜线的行坐标越来越小;由于输出第一行(abc),所以是n-k; //不能是m-k,m-k只会输出m个,如果m&gt;n还好,如果m&lt;n将输出不完整. for (int i = 0; i &lt; n - k; i++) &#123; //列坐标,行坐标+斜线序号 int j = k + i; //越界检查 if (i&gt;=m||j &gt;= n) &#123; continue; &#125; System.out.print(cs[i][j]); &#125; System.out.println(); &#125;&#125; 摩尔投票法12345678910111213141516int pre = nums[0];int cnt=1;int n = nums.length;for(int i=1;i&lt;n;i++)&#123; if(nums[i]==pre)&#123; cnt++; &#125;else&#123; if(cnt==0)&#123; pre=nums[i]; cnt=1; &#125; cnt--; &#125;&#125; 二分法 存在一个数target,返回下标. 闭区间法 [left,right] 123456789101112int left=0,right=nums.length-1,mid;while(left&lt;=right)&#123; mid=(left+right)&gt;&gt;&gt;1; if(nums[mid]==target)&#123; return mid; &#125;else if(target&lt;nums[mid])&#123; right=mid-1; &#125;else&#123; left=mid+1; &#125; &#125;return -1; 返回&gt;&#x3D;target的最左位置，用于求&lt;target的个数,. 开区间法 [left,right) 1234567891011121314//第一个&gt;=target的值//返回结果可以表示有多少个元素比target小private int lowerBound(int[] arr,int target)&#123; int left=0,right=arr.length,mid; while(left&lt;right)&#123; mid=(left+right)&gt;&gt;&gt;1; if(target&lt;=arr[mid])&#123; right=mid; &#125;else&#123; left=mid+1; &#125; &#125; return left;&#125; 返回&gt;target的最左位置，用于求&lt;&#x3D;target的个数。 开区间法 [left,right) 12345678910111213//第一个&gt;target的元素.private int upperBound(int[] arr,int target)&#123; int left=0,right=arr.length,mid; while(left&lt;right)&#123; mid=(left+right)&gt;&gt;&gt;1; if(target&gt;=arr[mid])&#123; left=mid+1; &#125;else&#123; right=mid; &#125; &#125; return left;&#125; 永远有两个值的方式,用法不明待开发. 1234567891011121314151617181920212223int binarySearch(int[] nums, int target) &#123; if (nums == null || nums.length == 0) return -1; int left = 0, right = nums.length - 1; while (left + 1 &lt; right)&#123; // Prevent (left + right) overflow int mid = left + (right - left) / 2; if (nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &lt; target) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; // Post-processing: // End Condition: left + 1 == right if(nums[left] == target) return left; if(nums[right] == target) return right; return -1;&#125; 数组的一一映射问题比如长度为n的数组里面只有[0,n-1]的元素,如果有重复的,给出重复的. 映射问题:由一一映射变成1对多映射; 利用数组能直接根据下标查询和修改值得特性,把元素归位. 重复的元素的位置不够用,只要发现已经被占,那肯定重复. 对于有序数组,删除重复元素,最多保留k位重复值问题,快慢指针.慢指针会在k+1处等着新的不同值来覆盖. 1234567int process(int[] nums, int k) &#123; int idx = 0; for (int x : nums) &#123; if (idx &lt; k || nums[idx - k] != x) nums[idx++] = x; &#125; return idx;&#125; 线性筛：O(n)筛选质数1234567891011121314151617181920212223public static List&lt;Integer&gt; getPrimes(int n) &#123; //非素数标记 boolean[] isnp = new boolean[n + 1]; List&lt;Integer&gt; primes = new ArrayList&lt;&gt;(); //只能从2开始 for (int i = 2; i &lt;= n; i++) &#123; if (!isnp[i])&#123; primes.add(i); &#125; for (int p : primes) &#123; if (p * i &gt; n) &#123; break; &#125; isnp[p * i] = true; if (i % p == 0) &#123; break; &#125; &#125; &#125; return primes;&#125; 并查集：用于连通性问题1234567891011121314151617181920212223242526272829303132333435363738394041424344public static class UF&#123; private int[] parent; private int[] size; private int count; public UF(int n)&#123; parent = new int[n]; size = new int[n]; count=n; for(int i=0;i&lt;n;i++)&#123; parent[i]=i; size[i]=1; &#125; &#125; public void union(int p,int q)&#123; int proot = find(p); int qroot= find(q); if(proot==qroot)&#123; return ; &#125; //平衡节点个数 if(size[proot]&gt;size[qroot])&#123; parent[qroot]=proot; size[proot]+=size[qroot]; &#125;else&#123; parent[proot]=qroot; size[qroot]+=size[proot]; &#125; count--; &#125; public int find(int p)&#123; while(p!=parent[p])&#123; //路径压缩 parent[p]=parent[parent[p]]; p=parent[p]; &#125; return p; &#125; public boolean connected(int p,int q)&#123; return find(p)==find(q); &#125; public int count()&#123; return count; &#125; &#125; 字典树: 用于具有相同前缀的字符串123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class Trie &#123; private static class Node &#123; private boolean val; private Node[] next = new Node[26]; &#125; private Node root; public void put(String key) &#123; if (root == null) &#123; root = new Node(); &#125; Node cur = root; for (int i = 0; i &lt; key.length(); i++) &#123; char c = key.charAt(i); if (cur.next[c - &#x27;a&#x27;] == null) &#123; cur.next[c - &#x27;a&#x27;] = new Node(); &#125; cur = cur.next[c - &#x27;a&#x27;]; &#125; cur.val = true; &#125; public boolean get(String key) &#123; Node cur = root; for (int i = 0; i &lt; key.length(); i++) &#123; char c = key.charAt(i); if (cur.next[c - &#x27;a&#x27;] == null) &#123; return false; &#125; cur = cur.next[c - &#x27;a&#x27;]; &#125; return cur.val; &#125; public String longestPrefixOf(String s) &#123; Node cur = root; int end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; char c = s.charAt(i); if (cur.next[c - &#x27;a&#x27;] == null) &#123; break; &#125; if (cur.val) &#123; end = i; &#125; cur = cur.next[c - &#x27;a&#x27;]; &#125; return s.substring(0, end); &#125; private String shortestPrefixOf(String s)&#123; Node cur=root; for(int i=0;i&lt;s.length();i++)&#123; char c = s.charAt(i); if(cur.next[c-&#x27;a&#x27;]==null)&#123; break; &#125; cur=cur.next[c-&#x27;a&#x27;]; if(cur.val)&#123; return s.substring(0,i+1); &#125; &#125; return s; &#125; /** * 先找到prefix的结点,再以此节点开始探索所有可能. * * @param prefix * @return */ public Set&lt;String&gt; startsWith(String prefix) &#123; Set&lt;String&gt; set = new HashSet&lt;&gt;(); if (root == null) &#123; return set; &#125; Node cur = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; char c = prefix.charAt(i); if (cur.next[c - &#x27;a&#x27;] == null) &#123; return set; &#125; cur = cur.next[c - &#x27;a&#x27;]; &#125; startsWith(cur, prefix, set); return list; &#125; private void startsWith(Node cur, String prefix, List&lt;String&gt; trace) &#123; if (cur == null) &#123; return; &#125; if (cur.val) &#123; trace.add(prefix); &#125; //每一个字符有26种选择. for (int j = 0; j &lt; 26; j++) &#123; startsWith(cur.next[j], prefix + ((char) (j + &#x27;a&#x27;)), trace); &#125; &#125; public List&lt;String&gt; keys() &#123; return startsWith(&quot;&quot;); &#125; //s中含有通配符.,配置符合要求的值. public List&lt;String&gt; keysMatch(String s) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); keysMatch(root, &quot;&quot;, s, list); return list; &#125; private void keysMatch(Node root, String pre, String pat, List&lt;String&gt; trace) &#123; if (root == null) &#123; return; &#125; //完成匹配 if (pre.length() == pat.length()) &#123; if (root.val) &#123; trace.add(pre); &#125; return; &#125; char next = pat.charAt(pre.length()); for (int i = 0; i &lt; 26; i++) &#123; if (next == &#x27;.&#x27; || (next - &#x27;a&#x27;) == i) &#123; keysMatch(root.next[i], pre + ((char) (&#x27;a&#x27; + i)), pat, trace); &#125; &#125; &#125; public void delete(String key) &#123; delete(root, key, 0); &#125; private Node delete(Node root, String key, int d) &#123; if (root == null) &#123; return null; &#125; if (d == key.length()) &#123; root.val = false; &#125; else &#123; char c = key.charAt(d); root.next[c - &#x27;a&#x27;] = delete(root.next[c - &#x27;a&#x27;], key, d + 1); &#125; if (root.val) &#123; return root; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (root.next[i] != null) &#123; return root; &#125; &#125; return null; &#125; public int size() &#123; return size(root); &#125; private int size(Node root) &#123; if (root == null) &#123; return 0; &#125; int cnt = 0; if (root.val) &#123; cnt++; &#125; for (int i = 0; i &lt; 26; i++) &#123; cnt += size(root.next[i]); &#125; return cnt; &#125;&#125; 求子集: 二进制状态压缩后，求出所有子集。123456//求mask的二进制子集int sub = mask;while (sub ! = 0) &#123; //这个sub就是子集之一 sub = (sub - 1) &amp; mask;&#125; 求所有情况子集：对于2^n种情况遍历,根据题目描述过滤12345678for(int mask=0;mask&lt;(1&lt;&lt;n);mask++)&#123; for(int i=0;i&lt;n;i++)&#123; //根据mask判断当前情况,即检查mask每一位的情况. if(((mask&gt;&gt;i)&amp; 1) !=0)&#123; //符合mask状态 &#125; &#125;&#125; LFU Least Frequently Used,淘汰频率最少使用的,最少使用次数相同,淘汰最旧的. 要统计频率,定义一个freq变量, put或者get时+1 缓存满了,删除freq最小的key,若有多个,删除最旧的 建立freq到key的映射关系,方便根据freq找key 使用minFreq记录最小次数,方便删除 freq和key是一对多的,且key列表存在时序 删除一个key时freq+1,就是把当前key放到freq+1里面去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394class LFUCache &#123; // key 到 val 的映射，我们后文称为 KV 表 HashMap&lt;Integer, Integer&gt; keyToVal; // key 到 freq 的映射，我们后文称为 KF 表 HashMap&lt;Integer, Integer&gt; keyToFreq; // freq 到 key 列表的映射，我们后文称为 FK 表 HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys; // 记录最小的频次 int minFreq; // 记录 LFU 缓存的最大容量 int cap; public LFUCache(int capacity) &#123; keyToVal = new HashMap&lt;&gt;(); keyToFreq = new HashMap&lt;&gt;(); freqToKeys = new HashMap&lt;&gt;(); this.cap = capacity; this.minFreq = 0; &#125; public int get(int key) &#123; if (!keyToVal.containsKey(key)) &#123; return -1; &#125; // 增加 key 对应的 freq increaseFreq(key); return keyToVal.get(key); &#125; public void put(int key, int val) &#123; if (this.cap &lt;= 0) return; /* 若 key 已存在，修改对应的 val 即可 */ if (keyToVal.containsKey(key)) &#123; keyToVal.put(key, val); // key 对应的 freq 加一 increaseFreq(key); return; &#125; /* key 不存在，需要插入 */ /* 容量已满的话需要淘汰一个 freq 最小的 key */ if (this.cap &lt;= keyToVal.size()) &#123; removeMinFreqKey(); &#125; /* 插入 key 和 val，对应的 freq 为 1 */ // 插入 KV 表 keyToVal.put(key, val); // 插入 KF 表 keyToFreq.put(key, 1); // 插入 FK 表 freqToKeys.putIfAbsent(1, new LinkedHashSet&lt;&gt;()); freqToKeys.get(1).add(key); // 插入新 key 后最小的 freq 肯定是 1 this.minFreq = 1; &#125; private void increaseFreq(int key) &#123; int freq = keyToFreq.get(key); /* 更新 KF 表 */ keyToFreq.put(key, freq + 1); /* 更新 FK 表 */ // 将 key 从 freq 对应的列表中删除 freqToKeys.get(freq).remove(key); // 将 key 加入 freq + 1 对应的列表中 freqToKeys.putIfAbsent(freq + 1, new LinkedHashSet&lt;&gt;()); freqToKeys.get(freq + 1).add(key); // 如果 freq 对应的列表空了，移除这个 freq if (freqToKeys.get(freq).isEmpty()) &#123; freqToKeys.remove(freq); // 如果这个 freq 恰好是 minFreq，更新 minFreq if (freq == this.minFreq) &#123; this.minFreq++; &#125; &#125; &#125; private void removeMinFreqKey() &#123; // freq 最小的 key 列表 LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(this.minFreq); // 其中最先被插入的那个 key 就是该被淘汰的 key int deletedKey = keyList.iterator().next(); /* 更新 FK 表 */ keyList.remove(deletedKey); if (keyList.isEmpty()) &#123; freqToKeys.remove(this.minFreq); // 问：这里需要更新 minFreq 的值吗？ &#125; /* 更新 KV 表 */ keyToVal.remove(deletedKey); /* 更新 KF 表 */ keyToFreq.remove(deletedKey); &#125;&#125; LRU Least Recently Used,淘汰最近最少使用 缓存中的数据要有时序,考虑链表或者说队列 要能快速找到key对应的val,那么就是hashmap 上面两者结合,就是LinkedHashMap 1234567891011121314151617181920212223242526272829303132333435363738394041class LRUCache &#123; int cap; LinkedHashMap&lt;Integer, Integer&gt; cache = new LinkedHashMap&lt;&gt;(); public LRUCache(int capacity) &#123; this.cap = capacity; &#125; public int get(int key) &#123; if (!cache.containsKey(key)) &#123; return -1; &#125; // 将 key 变为最近使用 makeRecently(key); return cache.get(key); &#125; public void put(int key, int val) &#123; if (cache.containsKey(key)) &#123; // 修改 key 的值 cache.put(key, val); // 将 key 变为最近使用 makeRecently(key); return; &#125; if (cache.size() &gt;= this.cap) &#123; // 链表头部就是最久未使用的 key int oldestKey = cache.keySet().iterator().next(); cache.remove(oldestKey); &#125; // 将新的 key 添加链表尾部 cache.put(key, val); &#125; private void makeRecently(int key) &#123; int val = cache.get(key); // 删除 key，重新插入到队尾 cache.remove(key); cache.put(key, val); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://hideincode.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://hideincode.github.io/tags/algo/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://hideincode.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"algo","slug":"algo","permalink":"https://hideincode.github.io/tags/algo/"}]}