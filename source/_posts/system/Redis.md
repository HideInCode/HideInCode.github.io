---
title: Redis
date: 2021-04-08
categories:
- 系统设计
tags:
- system design
---



# Redis

## 数据类型

* Strings

* Hash

* Lists

  > 粉丝列表,文章评论;基于缓存分页lrange

* Sets

  >求交并补

* Sorted Sets

## 缓存与数据库数据一致性问题

1. CAP 读的时候先读缓存,写时先写库.

   ---

   * 问题:如果删除缓存失败,那么就会读到旧数据.

   * 解决方案:

     * 先删除缓存在更新库.
     * 延时双删,利用队列 DelayQueue MQ

   * 高并发情况下的问题：

     > A线程先删除了缓存，再去改数据，此时B线程读取数据会直接读取数据库旧数据，然后写入缓存。等到A修改完成，那么缓存与库数据不一致情况就会出现。

     解决方案，利用jvm本身的队列，进行串行化操作.

## 经典问题

1. **雪崩**：雪崩指的是大量的缓存失效（一般由于过期），大量查询直接到数据库，导致数据库爆炸。

   预防：利用redis的高可用，就是主从+哨兵，集群；

   正在发生：本地ehcache缓存+hystrix限流降级，避免mysql挂掉；

   事后：redis持久化，之后再去重启redis就直接从磁盘拿数据。

2. 穿透：高并发查询缓存和数据库中都没有的数据，例如查询id=-1，致使所有的请求都打到数据库，数据库爆炸。因为视缓存为无物，所以叫做穿透。

   解决方案：从数据库中查询不到的值，也要在缓存中设置一个空值，设置一个过期时间。	

   如果使用不同的负数查询，那么用布隆过滤器，把所有数据放到布隆hash中，利用布隆过滤器筛选，减少压力；

3. **击穿**： 热点数据的key在缓存失效瞬间，全部请求到数据库，导致数据库爆炸。

   解决方案：

   * 对于不怎么更新的数据，设置成永不过期。

   * 更新不频繁的，耗时较短的数据，利用分布式锁，让少量请求更新缓存，其余的在锁释放后读取缓存即可；
   * 若缓存更新频繁或者耗时较长，利用定时任务在过期前主动重新构建缓存或者延后缓存过期时间，保证所有请求都能访问对应的缓存；


## Redis并发竞争问题

> 并发写，由于顺序问题，导致数据出错。利用分布式锁和数据库中的时间戳（更新时间），利用锁一个个写，利用时间戳比对数据是否是最新的。

## 技术选型为啥用Redis

> redis支持复杂的数据结构,相比于memcached,redis支持集群,数据量多的情况下,还是redis更好用.redis内部使用文件事件处理器.比较复杂,todo

## **为啥单线程的redis这么快 **

1. 纯内存操作
2. 基于非阻塞的IO多路复用机制
3. 采用了C语言这种更加接近底层的语言
4. 单线程避免了多线程的上下文频繁切换.也不会出现redis本身的资源竞争问题.

## **redis是有多线程的,自6.0以后**

> 因为某些方面,单线程已经没有太大优势了,读写网络的Read和Write系统在调用redis执行期间占用了大部分cpu时间,这种地方使用多线程对性能更友好.

## redis的过期策略

1. 定期删除+惰性删除

   >每过100ms就随机抽查一部分`设置了过期时间`的key,如果过期就删除;
   >
   >查询key的时候也会检查,如果key已经过期,那么直接删除;
   >
   >**此时大量过期key堆积,导致内存不够用,该如何是好**
   >
   >答案:内存淘汰机制


   ​	2. Redis 内存淘汰机制有以下几个：

- noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。

- **allkeys-lru**：当内存不足以容纳新写入数据时，在**键空间**中，移除最近最少使用的 key（这个是**最常用**的）。

- allkeys-random：当内存不足以容纳新写入数据时，在**键空间**中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。

- volatile-lru：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，移除最近最少使用的 key（这个一般不太合适）。

- volatile-random：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，**随机移除**某个 key。

- volatile-ttl：当内存不足以容纳新写入数据时，在**设置了过期时间的键空间**中，有**更早过期时间**的 key 优先移除。

   **考点: LRU算法**



###    Redis通过哨兵集群实现高可用

- 集群监控：负责监控 Redis master 和 slave 进程是否正常工作。
- 消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。
- 故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。
- 配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。

哨兵本身也是分布式的,可以做集群部署.

+ 故障转移需要大部分的哨兵同意.
+ 哨兵至少需要三个实例.
+ 哨兵+Redis的主从部署,不保证数据零丢失,只能保证Redis集群的高可用.
+ 复杂部署架构,需要在测试环境和生产环境做够充足演练.

### Redis的持久化

> + RDB持久化机制,对Redis中的数据执行周期性的持久化
> + AOF记录日志,类似于Mysql的binlog,追加的形式到日志文件,重启时通过回放日志文件来重新构建数据集.

**RDB优缺点**

+ 会生成多个文件,适合存储云端服务器做冷备份.
+ 对redis的对外读写影响很小,让redis保持高性能.
+ 比AOF更快的持久化
+ 由于周期型的,所以数据完整性不如AOF.
+ 持久化的文件特别大时,会导致对客户端的服务暂停数毫秒到几秒.

**AOF优缺点**

+ 数据完整性更可靠
+ 写入性能高,直接追加.
+ 日志文件过大也不会影响客户端的使用.
+ 利用可读性较强的方式记录,适合做灾难性误删除的恢复.
+ 开启后,支持写redis操作的QPS会降低
+ 出现数据丢失

可以同时开启两者。



