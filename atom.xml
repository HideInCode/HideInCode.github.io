<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://hideincode.github.io/atom.xml" rel="self"/>
  
  <link href="https://hideincode.github.io/"/>
  <updated>2024-05-06T18:05:35.186Z</updated>
  <id>https://hideincode.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AC1337</title>
    <link href="https://hideincode.github.io/2024/05/07/algo/AC1337/"/>
    <id>https://hideincode.github.io/2024/05/07/algo/AC1337/</id>
    <published>2024-05-06T17:45:50.000Z</published>
    <updated>2024-05-06T18:05:35.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AC1337"><a href="#AC1337" class="headerlink" title="AC1337"></a>AC1337</h1><blockquote><p>用于记录刷题的一些思路和技巧</p></blockquote><h2 id="算法可行性"><a href="#算法可行性" class="headerlink" title="算法可行性"></a>算法可行性</h2><table><thead><tr><th>数据规模</th><th>算法可接受时间复杂度</th></tr></thead><tbody><tr><td>&lt;&#x3D; 10</td><td>O(n!)</td></tr><tr><td>&lt;&#x3D; 20</td><td>O(2^n)</td></tr><tr><td>&lt;&#x3D; 100</td><td>O(n^4)</td></tr><tr><td>&lt;&#x3D; 500</td><td>O(n^3)</td></tr><tr><td>&lt;&#x3D; 2500</td><td>O(n^2)</td></tr><tr><td>&lt;&#x3D; 10^6</td><td>O(nlogn)</td></tr><tr><td>&lt;&#x3D; 10^7</td><td>O(n)</td></tr><tr><td>&lt;&#x3D; 10^14</td><td>O(sqrt(n))</td></tr><tr><td>-</td><td>O(logn)</td></tr><tr><td>-</td><td>O(1)</td></tr></tbody></table><h2 id="线型处理逻辑"><a href="#线型处理逻辑" class="headerlink" title="线型处理逻辑"></a>线型处理逻辑</h2><p>存储已知情况</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>单调栈，栈中元素为单调，<a href="https://leetcode-cn.com/problems/next-greater-element-i/">下一个最大的元素</a>。</li><li>成对出现的问题，用栈进行消消乐。</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>单调队列</li><li>优先队列</li></ul><h2 id="树型处理逻辑"><a href="#树型处理逻辑" class="headerlink" title="树型处理逻辑"></a>树型处理逻辑</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><ol><li><p>无重复元素，可重复选择，组合出一个target; </p><ul><li>下一层起点为i，这样保证只会从当前元素后开始往后选。</li></ul></li><li><p>有重复元素，不可重复选择，组合出一个target;</p><ol><li>排序，使得相同元素连在一起。</li><li>跳过相同元素。</li><li>从i + 1开始进入下层搜索。</li></ol></li></ol><h4 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h4><ol><li>无重复元素，所有排列情况;<ul><li>朴素版本(记录决策树):<ul><li>无需start，需要判断元素使用情况(visited数组&#x2F;基于无重复直接在容器里面判断)。</li></ul></li><li>进阶版本(交换元素):<ul><li>考虑start后面的每个位置来填充start，知道start到达n;即通过交换i，start;</li><li>下一层为start+1，即下一个要填的位置;</li><li>这样[0，start]就是统计过的排列，[start+1，n-1]就是待统计的。</li></ul></li></ul></li><li>有重复元素，排列情况。</li></ol><h4 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h4><blockquote><p>组合没有顺序上的要求，只是选择上区别;排列是对顺序有要求。</p></blockquote><ol><li>无重复元素，找所有子集。<ol><li>回溯:记录决策树的每一个结点即可</li><li>状态压缩:已知所有可能性，用二进制表示，记录每一这可能性;即二进制每一位表示是否选择。</li></ol></li><li>有重复元素，找所有子集:<ol><li>回溯:无重复情况+排序判断相邻元素去重。</li><li>状态压缩:无重复情况+排序判断相邻元素去重。即前一个元素相同但是没有被选择，那么选择当前情况必定重复。因为当前的情况之前肯定统计过了，考虑[1，2，2]的第二个2。。。</li><li>对重复元素排序处理:保证相同情况在同一层出现，出现一次就行了，后面都不再统计。</li><li>剪枝:有些时候需要贪心的先解决大的，大的搞不定小的肯定也不行。</li></ol></li></ol><h3 id="递归玩法"><a href="#递归玩法" class="headerlink" title="递归玩法"></a>递归玩法</h3><ul><li>定义状态</li><li>做出选择</li><li>缩小范围</li><li>上报结果</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>前缀和</p></li><li><p>计数</p></li><li><p>双指针</p></li><li><p>二分法</p><ol><li><p>找确定的目标值</p></li><li><p>猜数字</p></li><li><p>极大化极小，极小化极大。就是使得每部分的最大值最小。</p><blockquote><p>这种问题的一般结构就是，多种分配情况到达分组目标，每种情况中又会有最大值，判断所有情况中的最小的最大值。</p><p>具体题目模型参考: <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a></p><p>也可以称之为: 根据答案二分。</p></blockquote></li><li><p>旋转有序数组，旋转后分成两部分</p><ol><li>两部分都是上升的</li><li>后部分小于前部分</li><li>利用和mid和left的值的对比，判断target处于哪个部分。</li></ol></li></ol></li><li><p>滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (check()) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>原地哈希</p><blockquote><p>O(n)时间内使得数组有序，类似于计数排序，只不过把输入数组本身当成桶。</p></blockquote><ol><li>对于每个nums[i]，放入到对应下标位置。</li><li>再次遍历，没有归位的就是缺少的值。</li><li>一般有标记法和交换法</li><li>标记法<ol><li>对归位后的数字进行标记，提前把负数改成N+1</li><li>把值对应的位置上的值加上负号，即nums[nums[i] - 1] &#x3D; -abs(nums[nums[i] - 1])</li><li>没有标记为负数的就是没有归位的，即为缺失之数</li></ol></li><li>交换法：<ol><li>通过交换把值放到对应下标上，比如nums[0]放入nums[nums[0]]</li><li>再次遍历找出没有放入下标的值即可</li></ol></li></ol></li><li><p>动态规划</p><ul><li><p>前缀和:</p><blockquote><p>前缀和其实也是一种动态规划，拥有最优子结构，用于范围求和。而且前缀和中元素一般都是递增的，可以用二分搜索。</p></blockquote></li><li><p>后缀和：有些情况需要求<code>i</code>左边的结果和<code>i</code>右边的结果，来简化计算，需要同时求前缀和与后缀和。</p></li><li><p>背包问题<img src="/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB%E5%9B%BE.png" alt="分类"></p><ul><li><p>0-1背包：物品只能用一次，取决于选与不选。</p><p>一维空间:想明白遍历顺序，两个循环可否交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">    <span class="comment">//由大到小，不可与外层交换。</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=cap;i&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="comment">//求容量为j时，最大值。</span></span><br><span class="line">        dp[j]=max(dp[j]，dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完全背包: 物品可以重复选择，每次选择一个<br>一维空间:遍历顺序，循环可否交换位置。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">    <span class="comment">//又小到大，可以交换循环位置。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=cap;j++)&#123;</span><br><span class="line">        dp[j]=max(dp[j]，dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历顺序与排列组合的关系：外物内容是组合，外容内物是排列。</p><p><strong>如果求组合数就是外层for循环遍历物品个数，内层for遍历背包容量</strong>。</p><p><strong>如果求排列数就是外层for遍历背包容量，内层for循环遍历物品个数</strong>。</p></li><li><p>多重背包:物品有次数限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight。length; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="comment">// 以上为01背包，然后加一个遍历个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= <span class="number">0</span>; k++) &#123; <span class="comment">// 遍历个数</span></span><br><span class="line">            dp[j] = Math。max(dp[j]， dp[j - k * weight[i]] + k * value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System。out。println(Arrays。toString(dp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>01背包一维化理解</strong></p><blockquote><p>一维化的本质:就是把二维的每一行依次用一行表示。用新一行的结果覆盖老的结果。<br>由于二维情况可以，计算当前行需要上一行的值。<br>如果只保留一行的话，那么新计算的结果就要重新写入数组。<br>这时候不能覆盖上一行已经计算好的。<br>从左往右的覆盖的话，那么计算下个j用的就是当前的i，而非i-1。<br>从右往左的覆盖:用的还是上一行的数据。</p></blockquote></li><li><p>分组背包：每组只能选一个</p></li><li><p>回文串问题</p></li></ul></li></ul></li><li><p>差分数组：解决频繁<strong>范围</strong>修改，但是不用频繁查询的问题。</p><ol><li>[i， j]范围内全部+1，使用额外数组<code>dif[i]+1</code>，<code>dif[j+1]-1</code>。</li><li>用dif数组还原修改结果。</li></ol><blockquote><p>不需要首项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;diff。length;i++)&#123;</span><br><span class="line">dif[i]+=dif[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要首项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dif[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;diff。length;i++)&#123;</span><br><span class="line">dif[i]=dif[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>dummy节点简化代码。</li><li>快慢指针：<ol><li>环形链表</li><li>两链表相交</li><li>删除重复值</li></ol></li><li>翻转链表：转化为基础的翻转链表。</li></ol><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote><p>这里指的是单纯的内存意义上的物理树，和逻辑树不同。</p></blockquote><ol><li><p>DFS(先序，中序，后序，mirrors)，BFS</p></li><li><p>二叉搜索树的中序遍历是升序</p></li><li><p>数的直径</p></li><li><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">公共祖先问题</a></p></li><li><p>树的生成</p><blockquote><ul><li>插入操作基于代码模式 root。next&#x3D;f(root。next，。。。)</li><li>一般分治而成，即找到根节点后把区间缩小，逐步生成</li></ul></blockquote></li></ol><p>​5。 树上dp</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ol><li><p>物理结构 ：邻接表、临界矩阵、边的数组、父结点数组、链式向前星。</p></li><li><p>求联通分量，并查集、dfs、tarjan、Kosaraju</p></li><li><p>找环：</p><ol><li>dfs</li><li>bfs</li></ol></li><li><p>拓扑排序：依赖顺序问题</p><ol><li>必须是有向无环图(DAG)</li><li>DFS的逆后序，即把dfs的后序结果用栈保存起来。</li><li>BFS:把入度为0的先放入，然后遍历到一个结点就减少这个结点的入度。</li></ol></li><li><p>最小生成树：</p><ol><li>Prim：点按照已经生成的森林最近的距离加入树</li><li>Kruskal：边按照权重排序加入生成树</li></ol></li><li><p>最短路：</p><ol><li>无权最短路：bfs</li><li>非负权重最短路：Dijstra，理解松弛操作，就是bfs加了优先队列。</li><li>负权重：Bellman-Ford，复杂度O(VE)</li></ol></li><li><p>欧拉回路</p></li><li><p>基环内向树：图中有环，环上有些节点会有分支，形成有一个有环的树。常见解法：</p><ol><li>用拓扑排序找出环</li><li>判断节点是在链表上，还是在环上</li></ol></li><li><p>二分图判定</p></li><li><p>DFS 时间戳，即Tarjan相关算法。</p></li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>排序问题<ul><li>计数排序 分组问题，通过组号分发到数组。</li><li>基数排序 <ul><li>LSD 定长字符串，从右往左排序。</li><li>MSD 随机字符串，从左往右排序。</li></ul></li><li>三向快排 处理有大量重复键的排序问题</li><li>常规比较排序</li></ul></li><li>查询问题<ul><li>Trie(字典树，前缀树)</li><li>Map</li></ul></li><li>子串查找<ul><li>暴力法</li><li>滑动窗口</li><li>KMP 了解DFA</li><li>BM</li><li>RK</li></ul></li><li>正则表达式 了解NFA</li><li>数据压缩 (数据都可以转成二进制，二进制流都可以理解为字符串)<ul><li>双位压缩 对于DNA的4种碱基ACTG，可以用11 00 01 10 四种方式表达，但是只用两位。</li><li>游程编码(Run-Length Encoding) 首先转为二进制，将连续相同部分进行编码，如<code>0000000000000001111111000000011111111111</code>记成15个0，7个1，7个0，11个1，由于01交换出现，所以只对长度就行，把15 7 7 1改成二进制1111 0111 0111 1011，完成压缩。</li><li>霍夫曼(Huffman) 通过字符出现频率压缩</li><li>LZW</li></ul></li></ul><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul><li><p>a | b：计算并集</p></li><li><p>a &amp; b： 求a和b的最长公共前缀后面补齐0。如1010与1000得到1000</p></li><li><p>a ^ b：不进位相加</p></li><li><p>汉明距离：x^(x-1) 最低位的1变成0。 如110 ^ (100 - 1)结果为100</p></li><li><p>lowbit: x &amp; (-x) 截断x最低位的1及其后缀，必定是2的n次幂。 如1100 &amp; (-1100）时结果为100</p></li><li><p>求子集: 求k的二进制子集，针对中的二进制为1的位开始进行减法，判断数字k的二进制子集， 像枚举(2^k-1) ~ 0一样枚举其子集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> k;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//sub就是一个子集</span></span><br><span class="line">    sub = (sub - <span class="number">1</span>) &amp; k;</span><br><span class="line">&#125; <span class="keyword">while</span>(sub != k);</span><br></pre></td></tr></table></figure></li><li><p>去掉最后一位 | (101101-&gt;10110) | x &gt;&gt;1</p></li><li><p>在最后加一个0 | (101101-&gt;1011010) | x &lt;&lt;1 </p></li><li><p>在最后加一个1 | (101101-&gt;1011011) | x &lt;&lt; 1+1 </p></li><li><p>把最后一位变成1 | (101100-&gt;101101) | x or 1 </p></li><li><p>把最后一位变成0 | (101101-&gt;101100) | x or 1-1 </p></li><li><p>最后一位取反 | (101101-&gt;101100) | x xor 1 </p></li><li><p>把右数第k位变成1 | (101001-&gt;101101，k&#x3D;3) | x or (1 &lt;&lt; (k-1)) </p></li><li><p>把右数第k位变成0 | (101101-&gt;101001，k&#x3D;3) | x and not(1 &lt;&lt; (k-1)) </p></li><li><p>右数第k位取反 | (101001-&gt;101101，k&#x3D;3) | x xor (1 &lt;&lt; (k-1)) </p></li><li><p>取末三位 | (1101101-&gt;101) | x and 7 </p></li><li><p>取末k位 | (1101101-&gt;1101，k&#x3D;5) | x and (1 &lt;&lt; k-1) </p></li><li><p>取右数第k位 | (1101101-&gt;1，k&#x3D;4) | x &gt;&gt; (k-1) and 1 </p></li><li><p>把末k位变成1 | (101001-&gt;101111，k&#x3D;4) | x or (1 &lt;&lt; k-1) </p></li><li><p>末k位取反 | (101001-&gt;100110，k&#x3D;4) | x xor (1 &lt;&lt; k-1) </p></li><li><p>把右边连续的1变成0 | (100101111-&gt;100100000) | x and (x+1) </p></li><li><p>把右起第一个0变成1 | (100101111-&gt;100111111) | x or (x+1) </p></li><li><p>把右边连续的0变成1 | (11011000-&gt;11011111) | x or (x-1) </p></li><li><p>取右边连续的1 | (100101111-&gt;1111) | (x xor (x+1)) &gt;&gt; 1</p></li></ul><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><h4 id="MOD运算"><a href="#MOD运算" class="headerlink" title="MOD运算"></a>MOD运算</h4><ul><li><p>同余定理:a MOD M&#x3D;&#x3D;b MOD M  等价于 (a-b) MOD &#x3D;&#x3D; 0</p></li><li><p>a + b会溢出: (a + b) mod M &#x3D; (a mod M + b mod M) mod M</p></li><li><p>防止出现负数 +M:(a - b) % M &#x3D; (a % M - b % M + M) % M</p></li><li><p>(ab)%M &#x3D; (a%M)(b%M)%M</p></li><li><p>对于MOD除法 这里要求b和M互质，且M是质数。</p><ul><li><p>不能这么玩（a&#x2F;b) % M !&#x3D; ((a%M) &#x2F; (b%M)) % M</p></li><li><p>正确玩法 求逆元+费马小定理 </p><blockquote><p>求（a&#x2F;b) % M问题转化为 求b的逆元，即a*b^(-1)%M，此时只需求b^(-1)的值</p><p>b* b^(-1)与1模M同余</p><p>费马小定理得：M为质数时，b^(M - 1) 与1模M同余</p><p>可得b* b^(M - 2)与1模M同余</p><p>取b的逆元为b^(M-2)</p><p>最终（a&#x2F;b) % M &#x3D;&#x3D; a * pow(b，M - 2) % M，pow为求幂，可用快速幂实现。</p></blockquote></li></ul></li></ul><h4 id="最大公因数与最小公倍数"><a href="#最大公因数与最小公倍数" class="headerlink" title="最大公因数与最小公倍数"></a>最大公因数与最小公倍数</h4><ul><li><p>gcd(a，b) &#x3D;&#x3D; gcd(b，a)</p></li><li><p>gcd(a，b) &#x3D;&#x3D; gcd(a-b， b) (a &gt; b)</p></li><li><p>gcd(a，b) &#x3D;&#x3D; gcd(a%b， b)</p></li><li><p>gcd(a，b，c) &#x3D;&#x3D; gcd(gcd(a，b)，c)</p></li><li><p>gcd(ka，kb) &#x3D;&#x3D;  kgcd(a，b)</p></li><li><p>最小公倍数模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lcm(a，b) = (a * b) / gcd(a，b)</span></span><br><span class="line"><span class="comment">//先乘后除防溢出</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lcm</span><span class="params">(<span class="type">long</span> a， <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / gcd(a， b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="组合数取余"><a href="#组合数取余" class="headerlink" title="组合数取余"></a>组合数取余</h4><blockquote><p>从n中取m个元素，记为C(n， m) &#x3D; n! &#x2F; (m! * (n - m)!)，又知C(n， m) &#x3D; C(n - 1， m - 1) + C(n - 1， m);</p></blockquote><ul><li><p>求C(n， m) % M</p><ul><li><p>O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">long</span> C[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getC</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span> || j==i)</span><br><span class="line">                C[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i][j]=(C[i-<span class="number">1</span>][j-<span class="number">1</span>]+C[i-<span class="number">1</span>][j]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆元方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mo</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">C</span><span class="params">(<span class="type">long</span> n，<span class="type">long</span> m)</span>&#123;</span><br><span class="line">    <span class="type">long</span> M=<span class="number">0</span>，inv[N]，mul[N]，invMul[N];</span><br><span class="line">    <span class="keyword">while</span>(M&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M)&#123;</span><br><span class="line">            inv[M]=M==<span class="number">1</span>?<span class="number">1</span>:(mo-mo/M)*inv[mo%M]%mo;</span><br><span class="line">            mul[M]=mul[M-<span class="number">1</span>]*M%mo;</span><br><span class="line">            invMul[M]=invMul[M-<span class="number">1</span>]*inv[M]%mo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> mul[M]=<span class="number">1</span>，invMul[M]=<span class="number">1</span>;</span><br><span class="line">        M++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mul[n]*invMul[m]%mo*invMul[n-m]%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果对质数求余，可用Lucas定理在O(n)复杂度解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Lucas</span><span class="params">(<span class="type">long</span> n，<span class="type">long</span> m，<span class="type">long</span> p)</span>&#123;</span><br><span class="line"><span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n|m)ans=ans*C(n%P，m%P)%P，n/=P，m/=P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="概率与统计"><a href="#概率与统计" class="headerlink" title="概率与统计"></a>概率与统计</h3><blockquote><p>这类问题离不开随机函数</p></blockquote><p><strong>rand7生成rand10</strong></p><ul><li>蒙特卡洛方法之拒绝采样</li><li>(randX() - 1)*Y + randY()可以等概率的生成[1， X * Y]范围的随机数</li><li>大范围randx生成小范围randy:可用randx%y+1</li><li>x必须是y的倍数才能等概率的生成，所以如果不是倍数，那么对于生成的不符合的值要去掉。即一直循环到合适的。</li></ul><p><strong>水塘抽样</strong></p><ul><li>详见<a href="https://leetcode.cn/problems/linked-list-random-node/submissions/357625015/">相同概率取元素</a></li></ul><h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><ul><li>栈生成队列</li><li>队列生成栈</li><li>LFU</li><li>LRU</li></ul><h2 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h2><ul><li>线性筛：用于线性速度搜索n以内的质数</li><li>扫描线：矩阵相交求面积、周长、点的个数问题。</li><li>倍增：快速幂、最近公共祖先</li><li>摩尔投票法：消消乐。</li><li>计算根号2：牛顿迭代法</li><li>TopK问题<ul><li>堆(优先队列) O(nlogk)</li><li>快速选择 O(n)</li><li>二叉搜索树O(nlogk)</li><li>排序</li></ul></li><li>多路归并问题</li><li>快速选择</li><li>逆序对</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AC1337&quot;&gt;&lt;a href=&quot;#AC1337&quot; class=&quot;headerlink&quot; title=&quot;AC1337&quot;&gt;&lt;/a&gt;AC1337&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;用于记录刷题的一些思路和技巧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="算法" scheme="https://hideincode.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="algo" scheme="https://hideincode.github.io/tags/algo/"/>
    
  </entry>
  
  <entry>
    <title>经典问题</title>
    <link href="https://hideincode.github.io/2024/05/07/algo/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/"/>
    <id>https://hideincode.github.io/2024/05/07/algo/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/</id>
    <published>2024-05-06T17:45:50.000Z</published>
    <updated>2024-05-06T18:06:15.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h2><h3 id="求最值"><a href="#求最值" class="headerlink" title="求最值:"></a>求最值:</h3><ul><li><p>问题</p><ul><li>给定目标，找到达到目标的最小（最大）成本&#x2F;路径&#x2F;总和。</li></ul></li><li><p>答案</p><ul><li><p>在当前状态之前的所有可能路径中选择最小（最大）路径，然后为当前状态添加值。</p></li><li><pre><code class="java">//状态转移方程routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  for (int i = 1; i &lt;= target; ++i) &#123;</span><br><span class="line">     for (int j = 0; j &lt; ways.size(); ++j) &#123;</span><br><span class="line">         if (ways[j] &lt;= i) &#123;</span><br><span class="line">             dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  return dp[target]</span><br></pre></td></tr></table></figure>---[746. Min Cost Climbing Stairs Easy](https://leetcode-cn.com/problems/min-cost-climbing-stairs)[64. Minimum Path Sum Medium](https://leetcode-cn.com/problems/minimum-path-sum)[322. Coin Change Medium](https://leetcode-cn.com/problems/coin-change)[931. Minimum Falling Path Sum Medium](https://leetcode-cn.com/problems/minimum-falling-path-sum)[983. Minimum Cost For Tickets Medium](https://leetcode-cn.com/problems/minimum-cost-for-tickets)[650. 2 Keys Keyboard Medium](https://leetcode-cn.com/problems/2-keys-keyboard)[279. Perfect Squares Medium](https://leetcode-cn.com/problems/perfect-squares)[1049. Last Stone Weight II Medium](https://leetcode-cn.com/problems/last-stone-weight-ii)[120. Triangle Medium](https://leetcode-cn.com/problems/triangle)[474. Ones and Zeroes Medium](https://leetcode-cn.com/problems/ones-and-zeroes)[221. Maximal Square Medium](https://leetcode-cn.com/problems/maximal-square)[322. Coin Change Medium](https://leetcode-cn.com/problems/coin-change)[1240. Tiling a Rectangle with the Fewest Squares Hard](https://leetcode-cn.com/problems/tiling-a-rectangle-with-the-fewest-squares)[174. Dungeon Game Hard](https://leetcode-cn.com/problems/dungeon-game)[871. Minimum Number of Refueling Stops Hard](https://leetcode-cn.com/problems/minimum-number-of-refueling-stops)---</code></pre></li></ul></li></ul><h3 id="方案计数"><a href="#方案计数" class="headerlink" title="方案计数"></a>方案计数</h3><ul><li><p>问题</p><ul><li>给定一个目标，找到许多达到目标的独特方法。要分清分类计数原理,分步计数原理;</li></ul></li><li><p>答案</p><ul><li><p>总结所有可能的方法以达到当前状态。</p></li><li><pre><code class="java">routes[i] = routes[i-1] + routes[i-2], ... , + routes[i-k]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  for (int i = 1; i &lt;= target; ++i) &#123;</span><br><span class="line">     for (int j = 0; j &lt; ways.size(); ++j) &#123;</span><br><span class="line">         if (ways[j] &lt;= i) &#123;</span><br><span class="line">             dp[i] += dp[i - ways[j]];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  return dp[target]</span><br></pre></td></tr></table></figure>---[70. Climbing Stairs easy](https://leetcode-cn.com/problems/climbing-stairs)[62. Unique Paths Medium](https://leetcode-cn.com/problems/unique-paths)[1155. Number of Dice Rolls With Target Sum Medium](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum)[688. Knight Probability in Chessboard Medium](https://leetcode-cn.com/problems/knight-probability-in-chessboard)[494. Target Sum Medium](https://leetcode-cn.com/problems/target-sum)[377. Combination Sum IV Medium](https://leetcode-cn.com/problems/combination-sum-iv)[935. Knight Dialer Medium](https://leetcode-cn.com/problems/knight-dialer)[1223. Dice Roll Simulation Medium](https://leetcode-cn.com/problems/dice-roll-simulation)[416. Partition Equal Subset Sum Medium](https://leetcode-cn.com/problems/partition-equal-subset-sum)[808. Soup Servings Medium](https://leetcode-cn.com/problems/soup-servings)[790. Domino and Tromino Tiling Medium](https://leetcode-cn.com/problems/domino-and-tromino-tiling)[801. Minimum Swaps To Make Sequences Increasing](https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences)[673. Number of Longest Increasing Subsequence Medium](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence)[63. Unique Paths II Medium](https://leetcode-cn.com/problems/unique-paths-ii)[576. Out of Boundary Paths Medium](https://leetcode-cn.com/problems/out-of-boundary-paths)[1269. Number of Ways to Stay in the Same Place After Some Steps Hard](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps)[1220. Count Vowels Permutation Hard](https://leetcode-cn.com/problems/count-vowels-permutation)---</code></pre></li></ul></li></ul><h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><ul><li><p>问题</p><ul><li>给定一组数字，考虑到当前数字以及从左侧和右侧可获得的最佳值，可以找到问题的最佳解决方案。</li></ul></li><li><p>答案</p><ul><li><p>找到每个间隔的所有最佳解决方案，并返回最佳答案。</p></li><li><pre><code class="java">dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  for(int l = 1; l&lt;n; l++) &#123;</span><br><span class="line">     for(int i = 0; i&lt;n-l; i++) &#123;</span><br><span class="line">         int j = i+l;</span><br><span class="line">         for(int k = i; k&lt;j; k++) &#123;</span><br><span class="line">             dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  return dp[0][n-1]</span><br></pre></td></tr></table></figure>---[1130. Minimum Cost Tree From Leaf Values Medium](https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values)[96. Unique Binary Search Trees Medium](https://leetcode-cn.com/problems/unique-binary-search-trees)[1039. Minimum Score Triangulation of Polygon Medium](https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon)[546. Remove Boxes Medium](https://leetcode-cn.com/problems/remove-boxes)[1000. Minimum Cost to Merge Stones Medium](https://leetcode-cn.com/problems/minimum-cost-to-merge-stones)[312. Burst Balloons Hard](https://leetcode-cn.com/problems/burst-balloons)[375. Guess Number Higher or Lower II Medium](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii)---</code></pre></li></ul></li></ul><h3 id="字符串上的DP"><a href="#字符串上的DP" class="headerlink" title="字符串上的DP"></a>字符串上的DP</h3><ul><li><p>问题</p><ul><li>此模式的一般问题陈述可能会有所不同，但大多数情况下会给您两个字符串，这些字符串的长度不大.</li></ul></li><li><p>答案</p><ul><li><p>这种模式中的大多数问题都需要一种可以接受O（n ^ 2）复杂度的解决方案。</p></li><li><pre><code class="java">// i - indexing string s1// j - indexing string s2for (int i = 1; i &lt;= n; ++i) &#123;   for (int j = 1; j &lt;= m; ++j) &#123;       if (s1[i-1] == s2[j-1]) &#123;           dp[i][j] = /*code*/;       &#125; else &#123;           dp[i][j] = /*code*/;       &#125;   &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ---</span><br><span class="line"></span><br><span class="line">    [1143. Longest Common Subsequence Medium](https://leetcode-cn.com/problems/longest-common-subsequence)</span><br><span class="line">    [647. Palindromic Substrings Medium](https://leetcode-cn.com/problems/palindromic-substrings)</span><br><span class="line">    [516. Longest Palindromic Subsequence Medium](https://leetcode-cn.com/problems/longest-palindromic-subsequence)</span><br><span class="line">    [1092. Shortest Common Supersequence Medium](https://leetcode-cn.com/problems/shortest-common-supersequence)</span><br><span class="line">    [72. Edit Distance Hard](https://leetcode-cn.com/problems/edit-distance)</span><br><span class="line">    [115. Distinct Subsequences Hard](https://leetcode-cn.com/problems/distinct-subsequences)</span><br><span class="line">    [712. Minimum ASCII Delete Sum for Two Strings Medium](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings)</span><br><span class="line">    [5. Longest Palindromic Substring Medium](https://leetcode-cn.com/problems/longest-palindromic-substring)</span><br><span class="line"></span><br><span class="line">    ---</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 0-1背包问题</span><br><span class="line"></span><br><span class="line">* 问题</span><br><span class="line"></span><br><span class="line">  * 考虑使用和不使用当前状态的,做出你的选择</span><br><span class="line"></span><br><span class="line">* 答案</span><br><span class="line"></span><br><span class="line">  * 如果决定选择当前值，请使用先前的结果（忽略该值）； 反之亦然，如果您决定忽略当前值，请使用使用值的先前结果。</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    // i - indexing a set of values</span><br><span class="line">    // j - options to ignore j values</span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">       for (int j = 1; j &lt;= k; ++j) &#123;</span><br><span class="line">           dp[i][j] = max(&#123;dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]&#125;);</span><br><span class="line">           dp[i][j-1] = max(&#123;dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>---[198. House Robber Easy](https://leetcode-cn.com/problems/house-robber)[121. Best Time to Buy and Sell Stock Easy](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)[714. Best Time to Buy and Sell Stock with Transaction Fee Medium](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)[309. Best Time to Buy and Sell Stock with Cooldown Medium](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)[123. Best Time to Buy and Sell Stock III Hard](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)[188. Best Time to Buy and Sell Stock IV Hard](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv)---</code></pre></li></ul></li></ul><h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><p>LIS：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></p><p>LCS：<a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子串</a></p><p>MSA：<a href="https://leetcode.cn/problems/maximum-subarray/">最大和子数组</a></p><p>LPS：<a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a></p><p>​</p><h2 id="常见面试思路题目"><a href="#常见面试思路题目" class="headerlink" title="常见面试思路题目"></a>常见面试思路题目</h2><ul><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-common-urls.md">如何从大量的 URL 中找出相同的 URL？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-top-100-words.md">如何从大量数据中找出高频词？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-top-1-ip.md">如何找出某一天访问百度网站最多的 IP？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-no-repeat-number.md">如何在大量的数据中找出不重复的整数？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-a-number-if-exists.md">如何在大量的数据中判断一个数是否存在？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-hotest-query-string.md">如何查询最热门的查询串？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/count-different-phone-numbers.md">如何统计不同电话号码的个数？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-mid-value-in-500-millions.md">如何从 5 亿个数中找出中位数？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/sort-the-query-strings-by-counts.md">如何按照 query 的频度排序？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-rank-top-500-numbers.md">如何找出排名前 500 的数？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/topk-problems-and-solutions.md">讲讲大数据中 TopK 问题的常用套路？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经典问题&quot;&gt;&lt;a href=&quot;#经典问题&quot; class=&quot;headerlink&quot; title=&quot;经典问题&quot;&gt;&lt;/a&gt;经典问题&lt;/h1&gt;&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划:&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="算法" scheme="https://hideincode.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="algo" scheme="https://hideincode.github.io/tags/algo/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="https://hideincode.github.io/2024/05/07/algo/%E6%A8%A1%E6%9D%BF/"/>
    <id>https://hideincode.github.io/2024/05/07/algo/%E6%A8%A1%E6%9D%BF/</id>
    <published>2024-05-06T17:45:50.000Z</published>
    <updated>2024-05-06T18:04:02.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="距离与个数"><a href="#距离与个数" class="headerlink" title="距离与个数"></a>距离与个数</h2><blockquote><p>计算数组中<code>i</code>到<code>j</code>的距离:<code>i - j</code></p><p>计算数组中<code>i</code>到<code>j</code>的元素个数: <code>i - j + 1</code></p></blockquote><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p><strong>一维</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对nums.length=n求前缀和</span></span><br><span class="line"><span class="comment">//sum[i]:[0,i-1]的和</span></span><br><span class="line"><span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    sum[i+<span class="number">1</span>]=sum[i]+nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对grid[][]求前缀和,grid.length=m,grid[0].length=n</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        sum[i+<span class="number">1</span>][j+<span class="number">1</span>]=sum[i][j+<span class="number">1</span>]+sum[i+<span class="number">1</span>][j]-sum[i][j]+grid[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维异或</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span>[][] sum = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        sum[i+<span class="number">1</span>][j+<span class="number">1</span>]=sum[i][j+<span class="number">1</span>]^sum[i+<span class="number">1</span>][j]^sum[i][j]^matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连续值分组循环模板"><a href="#连续值分组循环模板" class="headerlink" title="连续值分组循环模板"></a>连续值分组循环模板</h2><ol><li><p>哨兵法: 开头定义一个哨兵,相邻比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    dist= i-start;</span><br><span class="line">cnt = i-start+<span class="number">1</span>;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标记法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同的标记一下</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="归并排序的merge操作-合并两个有序数组"><a href="#归并排序的merge操作-合并两个有序数组" class="headerlink" title="归并排序的merge操作:合并两个有序数组"></a>归并排序的merge操作:合并两个有序数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] aux;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> lo,<span class="type">int</span> mid,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">    System.arraycopy(nums,lo,aux,lo,hi-lo+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lo;i&lt;hi;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&gt;mid)&#123;</span><br><span class="line">            nums[i]=aux[q++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(q&gt;hi)&#123;</span><br><span class="line">            nums[i]=aux[p++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[p]&lt;nums[q])&#123;</span><br><span class="line">            nums[i]=nums[p];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i]=nums[q];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辗转相除法求最大公约数"><a href="#辗转相除法求最大公约数" class="headerlink" title="辗转相除法求最大公约数"></a>辗转相除法求最大公约数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(q, p % q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="partition操作：用于O-n-求topK或者快排。"><a href="#partition操作：用于O-n-求topK或者快排。" class="headerlink" title="partition操作：用于O(n)求topK或者快排。"></a>partition操作：用于O(n)求topK或者快排。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跑的快的版本,使用快慢指针.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[lo];</span><br><span class="line">    <span class="comment">//j指向处理好的小范围.</span></span><br><span class="line">    <span class="type">int</span> j=lo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lo+<span class="number">1</span>;i&lt;=hi;i++)&#123;</span><br><span class="line"><span class="comment">//把小的调换到前面去,i一直标记大的</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;pivot)&#123;</span><br><span class="line">            swap(a,++j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把轴放中间</span></span><br><span class="line">    swap(a,lo,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//好理解的版本,使用双向指针.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> lo,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[lo];</span><br><span class="line">    <span class="type">int</span> i=lo+<span class="number">1</span>,j=hi;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=pivot)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&gt;=pivot)&#123;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a,i,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(a,lo,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序的heapify操作-把输入的数组构建成一个完全二叉树"><a href="#堆排序的heapify操作-把输入的数组构建成一个完全二叉树" class="headerlink" title="堆排序的heapify操作:把输入的数组构建成一个完全二叉树"></a>堆排序的heapify操作:把输入的数组构建成一个完全二叉树</h2><p>堆是一个选择器,能在<code>O(logN)</code>时间选出最值</p><ol><li><p><code>sink(k)</code>把下标k的元素下沉到合适位置,<code>swim(k)</code>把下标为k的元素上浮到合适位置，这个过程叫做堆化（heapify)</p></li><li><p>一个堆只有n&#x2F;2个父节点.</p></li><li><p>buildHeap就是把小堆合成大堆的过程</p></li><li><p>insert:加到数组结尾后swim</p></li><li><p>delete最大值:swap(a[0],a[n-1]),把a[n-1]删除,a[0]进行sink.</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建大根堆:把数组a构建成a[0]为最大值的堆.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//每个父节点都要尝试调整</span></span><br><span class="line">        sink(a, i, n);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自底向上堆化.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; a[(k-<span class="number">1</span>)/<span class="number">2</span>]&lt;a[k])</span><br><span class="line">     &#123;</span><br><span class="line">         swap(a,(k-<span class="number">1</span>)/<span class="number">2</span>, k);</span><br><span class="line">         k = (k-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自顶向下堆化: 父,左,右,选出最大为新的父节点.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, max = i;</span><br><span class="line">    <span class="comment">//找出父节点,左子节点,右子节点中的最大值的下标max.</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; a[l] &gt; a[max]) &#123;</span><br><span class="line">        max = l;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; a[r] &gt; a[max]) &#123;</span><br><span class="line">        max = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前父节点不是最大值,那么就要下沉</span></span><br><span class="line">    <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">        swap(a, i, max);</span><br><span class="line">        sink(a, max, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组-单点修改与区间查询"><a href="#树状数组-单点修改与区间查询" class="headerlink" title="树状数组:单点修改与区间查询"></a>树状数组:单点修改与区间查询</h2><ul><li>数组的区间查询首先考虑用前缀和,但是如果<strong>修改多于查询</strong>,那么就就要用到读和写都是<code>O(n)</code>的树状数组.</li><li>内存中的数据结构是数组,<strong>逻辑上是一棵树</strong>.</li><li>x&amp;(-x):求x的最低位的1和后面0组成的数字,俗称<code>lowbit</code>操作.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始数组长度</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//逻辑树</span></span><br><span class="line"><span class="type">int</span>[] tree;</span><br><span class="line"></span><br><span class="line">init(<span class="type">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">    tree = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最低位1和后面的0构成的数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把i处值增加d</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        tree[i]+=d;</span><br><span class="line">        <span class="comment">//所有父结点都要修改</span></span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询tree中[1,i]的前缀和,即原数组中[0,i-1]的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum+=tree[i];</span><br><span class="line">        i-=lowbit[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树-区间修改与区间查询"><a href="#线段树-区间修改与区间查询" class="headerlink" title="线段树: 区间修改与区间查询"></a>线段树: 区间修改与区间查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线段树（动态开点）、区间修改</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTreeDynamic</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node left, right;</span><br><span class="line">        <span class="comment">//val是子节点的和，add该节点所有对应的孩子节点都应该有此更新</span></span><br><span class="line">        <span class="type">int</span> val, add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">//// 在区间 [start, end] 中更新区间 [l, r] 的值，将区间 [l, r] ➕ val</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            node.val += (end - start + <span class="number">1</span>) * val;</span><br><span class="line">            node.add += val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        pushDown(node, mid - start + <span class="number">1</span>, end - mid);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) update(node.left, start, mid, l, r, val);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) update(node.right, mid + <span class="number">1</span>, end, l, r, val);</span><br><span class="line">        pushUp(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在[start, end]中搜[l, r]的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) <span class="keyword">return</span> node.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        pushDown(node, mid - start + <span class="number">1</span>, end - mid);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) ans += query(node.left, start, mid, l, r);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) ans += query(node.right, mid + <span class="number">1</span>, end, l, r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改时，自上而下修改值。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.val = node.left.val + node.right.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查与改时，自上而下创建和修改节点。</span></span><br><span class="line">    <span class="comment">//leftNum表示左节点为根的子树个数，rightNum同理。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(Node node, <span class="type">int</span> leftNum, <span class="type">int</span> rightNum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据标记add修改</span></span><br><span class="line">        <span class="keyword">if</span> (node.add == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左节点和 = 左节点的标记 x 节点个数</span></span><br><span class="line">        node.left.val += node.add * leftNum;</span><br><span class="line">        <span class="comment">//同理</span></span><br><span class="line">        node.right.val += node.add * rightNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖</span></span><br><span class="line">        node.left.add += node.add;</span><br><span class="line">        node.right.add += node.add;</span><br><span class="line">        <span class="comment">//标记下传完成，删除标记。</span></span><br><span class="line">        node.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单点修改的线段树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = nums;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * nums.length];</span><br><span class="line">        <span class="keyword">if</span>(arr.length!=<span class="number">0</span>)&#123;</span><br><span class="line">            buildTree(<span class="number">0</span>,arr.length-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            tree[root]=arr[start];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        buildTree(start,mid,left);</span><br><span class="line">        buildTree(mid+<span class="number">1</span>,end,right);</span><br><span class="line">        tree[root]=tree[left]+tree[right];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        update(<span class="number">0</span>,arr.length-<span class="number">1</span>,i,val,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> idx, <span class="type">int</span> val, <span class="type">int</span> root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            tree[root]=val;</span><br><span class="line">            arr[idx] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx&lt;=mid)&#123;</span><br><span class="line">            update(start,mid,idx,val,left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            update(mid+<span class="number">1</span>,end,idx,val,right);</span><br><span class="line">        &#125;</span><br><span class="line">        tree[root]=tree[left]+tree[right];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum(<span class="number">0</span>,arr.length-<span class="number">1</span>,<span class="number">0</span>,i,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> root, <span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;end||r&lt;start)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=start&amp;&amp;r&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span> tree[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> tree[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> left_sum=sum(start,mid,left,l,r);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right_sum</span> <span class="operator">=</span> sum(mid+<span class="number">1</span>,end,right,l,r);</span><br><span class="line">        <span class="keyword">return</span> left_sum+right_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="快速乘-计算x-n"><a href="#快速乘-计算x-n" class="headerlink" title="快速乘: 计算x*n"></a>快速乘: 计算x*n</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//最低位是1,是有用的数字,放入结果</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//累计结果</span></span><br><span class="line">            result += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算下一位</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//x翻倍</span></span><br><span class="line">        x += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂-计算x-n"><a href="#快速幂-计算x-n" class="headerlink" title="快速幂: 计算x^n"></a>快速幂: 计算x^n</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//最低位是1,是有用的数字,放入结果</span></span><br><span class="line">         <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="comment">//累计结果</span></span><br><span class="line">             ans *= x;</span><br><span class="line">         &#125;</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="comment">//x取平方            </span></span><br><span class="line">         x *= x;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>简单解释:</p><blockquote><p>*<em>快速乘: ** 5</em>3 &#x3D; 5 * (11)<sub>2</sub> &#x3D; 5 * ( (10)<sub>2</sub> + (1)<sub>2</sub>) &#x3D; 5 * (10)<sub>2</sub> + 5*1 &#x3D; (5 * 2<sup>1</sup> * 1 + 5 * 2<sup>0</sup> * 0) + 5 * 1&#x3D; ((5+5) * 1 + (5) * 0) +5 &#x3D; 15</p><p><strong>快速幂:</strong>  5^3 &#x3D; 5 ^ (11)<sub>2</sub> &#x3D; 5 ^ ( (10)<sub>2</sub> + (1)<sub>2</sub>) &#x3D; 5^ (10)<sub>2</sub> * 5^1 &#x3D; 5 ^ (2 * 1 + 1 * 0) * 5 &#x3D; 5 * 5 * 5 &#x3D; 125</p></blockquote><p>一般用于防止爆数据,加快计算速度. </p><h2 id="二维数组遍历方向问题"><a href="#二维数组遍历方向问题" class="headerlink" title="二维数组遍历方向问题"></a>二维数组遍历方向问题</h2><table><thead><tr><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>d</td><td>e</td><td>f</td></tr><tr><td>g</td><td>h</td><td>i</td></tr><tr><td>j</td><td>k</td><td>l</td></tr></tbody></table><ul><li><p>从对角线开始,斜向遍历 ↘ ↘ ↘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[][] cs = <span class="keyword">new</span> <span class="title class_">char</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m * n; i++) &#123;</span><br><span class="line">            cs[i / n][i % n] = (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] c : cs) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//斜线序号,给每条斜线标个序号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            <span class="comment">//行坐标,每条斜线的行坐标越来越小;由于输出第一行(abc),所以是n-k;</span></span><br><span class="line">            <span class="comment">//不能是m-k,m-k只会输出m个,如果m&gt;n还好,如果m&lt;n将输出不完整.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - k; i++) &#123;</span><br><span class="line">                <span class="comment">//列坐标,行坐标+斜线序号</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> k + i;</span><br><span class="line">                <span class="comment">//越界检查</span></span><br><span class="line">                <span class="keyword">if</span> (i&gt;=m||j &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(cs[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]==pre)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">            pre=nums[i];</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><ol><li><p>存在一个数target,返回下标.</p><blockquote><p>闭区间法 [left,right]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>,mid;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">    mid=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid])&#123;</span><br><span class="line">        right=mid-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>返回&gt;&#x3D;target的最左位置，用于求&lt;target的个数,.</p><blockquote><p>开区间法 [left,right)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个&gt;=target的值</span></span><br><span class="line"><span class="comment">//返回结果可以表示有多少个元素比target小</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=arr.length,mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=arr[mid])&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回&gt;target的最左位置，用于求&lt;&#x3D;target的个数。</p><blockquote><p>开区间法 [left,right)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个&gt;target的元素.</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">upperBound</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=arr.length,mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target&gt;=arr[mid])&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>永远有两个值的方式,用法不明待开发.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数组的一一映射问题"><a href="#数组的一一映射问题" class="headerlink" title="数组的一一映射问题"></a>数组的一一映射问题</h2><p>比如长度为n的数组里面只有[0,n-1]的元素,如果有重复的,给出重复的.</p><ol><li><p>映射问题:由一一映射变成1对多映射;</p></li><li><p>利用数组能直接<strong>根据下标查询和修改值</strong>得特性,把元素归位.</p></li><li><p>重复的元素的位置不够用,只要发现已经被占,那肯定重复.</p></li><li><p>对于有序数组,删除重复元素,最多保留k位重复值问题,快慢指针.慢指针会在k+1处等着新的不同值来覆盖.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; k || nums[idx - k] != x) nums[idx++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="线性筛：O-n-筛选质数"><a href="#线性筛：O-n-筛选质数" class="headerlink" title="线性筛：O(n)筛选质数"></a>线性筛：O(n)筛选质数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  List&lt;Integer&gt; <span class="title function_">getPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//非素数标记</span></span><br><span class="line">    <span class="type">boolean</span>[] isnp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    List&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//只能从2开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnp[i])&#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isnp[p * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集：用于连通性问题"><a href="#并查集：用于连通性问题" class="headerlink" title="并查集：用于连通性问题"></a>并查集：用于连通性问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            count=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                parent[i]=i;</span><br><span class="line">                size[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">proot</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="type">int</span> qroot= find(q);</span><br><span class="line">            <span class="keyword">if</span>(proot==qroot)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//平衡节点个数</span></span><br><span class="line">            <span class="keyword">if</span>(size[proot]&gt;size[qroot])&#123;</span><br><span class="line">                parent[qroot]=proot;</span><br><span class="line">                size[proot]+=size[qroot];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent[proot]=qroot;</span><br><span class="line">                size[qroot]+=size[proot]; </span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(p!=parent[p])&#123;</span><br><span class="line">                <span class="comment">//路径压缩</span></span><br><span class="line">                parent[p]=parent[parent[p]];</span><br><span class="line">                p=parent[p];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="字典树-用于具有相同前缀的字符串"><a href="#字典树-用于具有相同前缀的字符串" class="headerlink" title="字典树: 用于具有相同前缀的字符串"></a>字典树: 用于具有相同前缀的字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> val;</span><br><span class="line">        <span class="keyword">private</span> Node[] next = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.val = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.val) &#123;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">0</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Node cur=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(cur.next[c-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(cur.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> s.substring(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先找到prefix的结点,再以此节点开始探索所有可能.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> set;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> set;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        startsWith(cur, prefix, set);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startsWith</span><span class="params">(Node cur, String prefix, List&lt;String&gt; trace)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.val) &#123;</span><br><span class="line">            trace.add(prefix);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每一个字符有26种选择.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">            startsWith(cur.next[j], prefix + ((<span class="type">char</span>) (j + <span class="string">&#x27;a&#x27;</span>)), trace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startsWith(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s中含有通配符.,配置符合要求的值.</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysMatch</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        keysMatch(root, <span class="string">&quot;&quot;</span>, s, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">keysMatch</span><span class="params">(Node root, String pre, String pat, List&lt;String&gt; trace)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成匹配</span></span><br><span class="line">        <span class="keyword">if</span> (pre.length() == pat.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.val) &#123;</span><br><span class="line">                trace.add(pre);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">next</span> <span class="operator">=</span> pat.charAt(pre.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="string">&#x27;.&#x27;</span> || (next - <span class="string">&#x27;a&#x27;</span>) == i) &#123;</span><br><span class="line">                keysMatch(root.next[i], pre + ((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i)), pat, trace);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        delete(root, key, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node root, String key, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) &#123;</span><br><span class="line">            root.val = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(d);</span><br><span class="line">            root.next[c - <span class="string">&#x27;a&#x27;</span>] = delete(root.next[c - <span class="string">&#x27;a&#x27;</span>], key, d + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.next[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            cnt += size(root.next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求子集-二进制状态压缩后，求出所有子集。"><a href="#求子集-二进制状态压缩后，求出所有子集。" class="headerlink" title="求子集: 二进制状态压缩后，求出所有子集。"></a>求子集: 二进制状态压缩后，求出所有子集。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求mask的二进制子集</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> mask;</span><br><span class="line"><span class="keyword">while</span> (sub ! = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//这个sub就是子集之一</span></span><br><span class="line">    sub = (sub - <span class="number">1</span>) &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求所有情况子集：对于2-n种情况遍历-根据题目描述过滤"><a href="#求所有情况子集：对于2-n种情况遍历-根据题目描述过滤" class="headerlink" title="求所有情况子集：对于2^n种情况遍历,根据题目描述过滤"></a>求所有情况子集：对于2^n种情况遍历,根据题目描述过滤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">0</span>;mask&lt;(<span class="number">1</span>&lt;&lt;n);mask++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//根据mask判断当前情况,即检查mask每一位的情况.</span></span><br><span class="line">        <span class="keyword">if</span>(((mask&gt;&gt;i)&amp; <span class="number">1</span>) !=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//符合mask状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><blockquote><p>Least Frequently Used,淘汰频率最少使用的,最少使用次数相同,淘汰最旧的.</p></blockquote><ol><li><p>要统计频率,定义一个freq变量, put或者get时+1</p></li><li><p>缓存满了,删除freq最小的key,若有多个,删除最旧的</p></li><li><p>建立freq到key的映射关系,方便根据freq找key</p><ol><li>使用minFreq记录最小次数,方便删除</li></ol></li><li><p>freq和key是一对多的,且key列表存在时序</p></li><li><p>删除一个key时freq+1,就是把当前key放到freq+1里面去</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line">    <span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br><span class="line">    <span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="type">int</span> minFreq;</span><br><span class="line">    <span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        keyToVal = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        keyToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!keyToVal.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加 key 对应的 freq</span></span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span> keyToVal.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若 key 已存在，修改对应的 val 即可 */</span></span><br><span class="line">        <span class="keyword">if</span> (keyToVal.containsKey(key)) &#123;</span><br><span class="line">            keyToVal.put(key, val);</span><br><span class="line">            <span class="comment">// key 对应的 freq 加一</span></span><br><span class="line">            increaseFreq(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* key 不存在，需要插入 */</span></span><br><span class="line">        <span class="comment">/* 容量已满的话需要淘汰一个 freq 最小的 key */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cap &lt;= keyToVal.size()) &#123;</span><br><span class="line">            removeMinFreqKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 插入 key 和 val，对应的 freq 为 1 */</span></span><br><span class="line">        <span class="comment">// 插入 KV 表</span></span><br><span class="line">        keyToVal.put(key, val);</span><br><span class="line">        <span class="comment">// 插入 KF 表</span></span><br><span class="line">        keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 插入 FK 表</span></span><br><span class="line">        freqToKeys.putIfAbsent(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">        freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line">        <span class="comment">// 插入新 key 后最小的 freq 肯定是 1</span></span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">increaseFreq</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> keyToFreq.get(key);</span><br><span class="line">        <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">        keyToFreq.put(key, freq + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">        <span class="comment">// 将 key 从 freq 对应的列表中删除</span></span><br><span class="line">        freqToKeys.get(freq).remove(key);</span><br><span class="line">        <span class="comment">// 将 key 加入 freq + 1 对应的列表中</span></span><br><span class="line">        freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">        freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line">        <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;</span><br><span class="line">            freqToKeys.remove(freq);</span><br><span class="line">            <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            <span class="keyword">if</span> (freq == <span class="built_in">this</span>.minFreq) &#123;</span><br><span class="line">                <span class="built_in">this</span>.minFreq++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeMinFreqKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// freq 最小的 key 列表</span></span><br><span class="line">        LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="built_in">this</span>.minFreq);</span><br><span class="line">        <span class="comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">deletedKey</span> <span class="operator">=</span> keyList.iterator().next();</span><br><span class="line">        <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">        keyList.remove(deletedKey);</span><br><span class="line">        <span class="keyword">if</span> (keyList.isEmpty()) &#123;</span><br><span class="line">            freqToKeys.remove(<span class="built_in">this</span>.minFreq);</span><br><span class="line">            <span class="comment">// 问：这里需要更新 minFreq 的值吗？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 更新 KV 表 */</span></span><br><span class="line">        keyToVal.remove(deletedKey);</span><br><span class="line">        <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">        keyToFreq.remove(deletedKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><blockquote><p>Least Recently Used,淘汰最近最少使用</p></blockquote><ol><li><p>缓存中的数据要有时序,考虑链表或者说队列</p></li><li><p>要能快速找到key对应的val,那么就是hashmap</p></li><li><p>上面两者结合,就是LinkedHashMap</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 修改 key 的值</span></span><br><span class="line">            cache.put(key, val);</span><br><span class="line">            <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">            makeRecently(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt;= <span class="built_in">this</span>.cap) &#123;</span><br><span class="line">            <span class="comment">// 链表头部就是最久未使用的 key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">oldestKey</span> <span class="operator">=</span> cache.keySet().iterator().next();</span><br><span class="line">            cache.remove(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的 key 添加链表尾部</span></span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeRecently</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 删除 key，重新插入到队尾</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;&lt;h2 id=&quot;距离与个数&quot;&gt;&lt;a href=&quot;#距离与个数&quot; class=&quot;headerlink&quot; title=&quot;距离与个数&quot;&gt;&lt;/a&gt;距离与个</summary>
      
    
    
    
    <category term="算法" scheme="https://hideincode.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="algo" scheme="https://hideincode.github.io/tags/algo/"/>
    
  </entry>
  
</feed>
