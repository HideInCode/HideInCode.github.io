<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://hideincode.github.io/atom.xml" rel="self"/>
  
  <link href="https://hideincode.github.io/"/>
  <updated>2024-05-07T09:01:42.293Z</updated>
  <id>https://hideincode.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见攻击与漏洞</title>
    <link href="https://hideincode.github.io/2024/05/01/basic/%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%B8%8E%E6%BC%8F%E6%B4%9E/"/>
    <id>https://hideincode.github.io/2024/05/01/basic/%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%B8%8E%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-04-30T16:00:00.000Z</published>
    <updated>2024-05-07T09:01:42.293Z</updated>
    
    
    
    
    <category term="基础知识" scheme="https://hideincode.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="safe" scheme="https://hideincode.github.io/tags/safe/"/>
    
  </entry>
  
  <entry>
    <title>K8S集群搭建</title>
    <link href="https://hideincode.github.io/2023/11/11/devops/k8s/"/>
    <id>https://hideincode.github.io/2023/11/11/devops/k8s/</id>
    <published>2023-11-10T16:00:00.000Z</published>
    <updated>2024-05-07T09:04:03.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K8S集群搭建"><a href="#K8S集群搭建" class="headerlink" title="K8S集群搭建"></a>K8S集群搭建</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;K8S集群搭建&quot;&gt;&lt;a href=&quot;#K8S集群搭建&quot; class=&quot;headerlink&quot; title=&quot;K8S集群搭建&quot;&gt;&lt;/a&gt;K8S集群搭建&lt;/h1&gt;</summary>
      
    
    
    
    <category term="开发部署" scheme="https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="devops" scheme="https://hideincode.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>Docker部署一些组件</title>
    <link href="https://hideincode.github.io/2023/05/07/devops/docker/"/>
    <id>https://hideincode.github.io/2023/05/07/devops/docker/</id>
    <published>2023-05-06T16:00:00.000Z</published>
    <updated>2024-05-07T09:04:51.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker部署"><a href="#docker部署" class="headerlink" title="docker部署"></a>docker部署</h2><h2 id="部署操作"><a href="#部署操作" class="headerlink" title="部署操作"></a>部署操作</h2><ol><li><p>进入官网，查看manu文档</p></li><li><p>按照系统执行命令，本地虚拟机可以先yum update</p></li><li><p>安装好引擎后添加阿里云镜像加速</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://p63g7kqk.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li></ol><p>​4. 设置开机自启动：<code>sudo systemctl enable docker</code></p><h2 id="安装docker引擎时出错："><a href="#安装docker引擎时出错：" class="headerlink" title="安装docker引擎时出错："></a>安装docker引擎时出错：</h2><p>重新配置yum源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d</span><br><span class="line"></span><br><span class="line"><span class="built_in">rm</span> -rf  !(CentOS_Base.Repo)</span><br><span class="line"></span><br><span class="line">yum update</span><br></pre></td></tr></table></figure><h2 id="打包成镜像运行"><a href="#打包成镜像运行" class="headerlink" title="打包成镜像运行"></a>打包成镜像运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -f Dockerfile -t docker.io/shh/demo:v1.0 .</span></span><br><span class="line"><span class="comment"># docker run -d --name demo -p 8080:8080 shh/demo:v1.0</span></span><br></pre></td></tr></table></figure><h2 id="Dockfile模板"><a href="#Dockfile模板" class="headerlink" title="Dockfile模板"></a>Dockfile模板</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">EXPOSE 8080</span><br><span class="line"><span class="comment"># VOLUME 指定了临时文件目录为/tmp。</span></span><br><span class="line"><span class="comment"># 其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp</span></span><br><span class="line">VOLUME /tmp</span><br><span class="line"><span class="comment"># 将jar包添加到容器中并更名为app.jar</span></span><br><span class="line">ADD HelloDocker-0.0.1-SNAPSHOT.jar /app.jar</span><br><span class="line"><span class="comment"># 运行jar包</span></span><br><span class="line">RUN bash -c <span class="string">&#x27;touch /app.jar&#x27;</span></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>,<span class="string">&quot;/app.jar&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h2><ol><li><p>下载镜像：<code>docker pull mysql:5.7</code></p></li><li><p>指定端口映射、文件挂载、密码后启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /mydata/mysql/log:/var/log/mysql \</span><br><span class="line">-v /mydata/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /mydata/mysql/conf:/etc/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure></li><li><p>修改配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vi /mydata/mysql/conf/my.cnf</span><br><span class="line"></span><br><span class="line">[client]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">init_connect=<span class="string">&#x27;SET collation_connection = utf8_unicode_ci&#x27;</span> init_connect=<span class="string">&#x27;SET NAMES utf8&#x27;</span> character-set-server=utf8</span><br><span class="line">collation-server=utf8_unicode_ci</span><br><span class="line">skip-character-set-client-handshake</span><br><span class="line">skip-name-resolve</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><ol><li><p>下载镜像：<code>docker pull redis</code></p></li><li><p>启动：要先在本机生成文件后，才能挂载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mydata/redis/conf</span><br><span class="line"><span class="built_in">touch</span> /mydata/redis/conf/redis.conf</span><br><span class="line"></span><br><span class="line">docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data \</span><br><span class="line">-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-d redis redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure></li></ol><h2 id="安装ES"><a href="#安装ES" class="headerlink" title="安装ES"></a>安装ES</h2><ol><li><p>镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull elasticsearch:7.4.2</span><br><span class="line">docker pull kibana:7.4.2 </span><br></pre></td></tr></table></figure></li><li><p>创建实例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mydata/elasticsearch/config</span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/elasticsearch/data</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;http.host: 0.0.0.0&quot;</span> &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> -R 777 /mydata/elasticsearch/</span><br><span class="line"></span><br><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e <span class="string">&quot;discovery.type=single-node&quot;</span> \</span><br><span class="line">-e ES_JAVA_OPTS=<span class="string">&quot;-Xms64m -Xmx512m&quot;</span> \</span><br><span class="line">-v /mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># kibibna 地址要改</span></span><br><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.56.10:9200 -p 5601:5601 \</span><br><span class="line">-d kibana:7.4.2</span><br></pre></td></tr></table></figure></li></ol><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><ol><li><p>下载镜像：docker pull rabbitmq</p></li><li><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</span><br></pre></td></tr></table></figure></li><li><p>端口解释：</p><ul><li>4369, 25672 (Erlang发现&amp;集群端口)</li><li>5672, 5671 (AMQP端口)</li><li>15672 (web管理后台端口) </li><li>61613, 61614 (STOMP协议端口) </li><li>1883, 8883 (MQTT协议端口) <a href="https://www.rabbitmq.com/networking.html">https://www.rabbitmq.com/networking.html</a></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;docker部署&quot;&gt;&lt;a href=&quot;#docker部署&quot; class=&quot;headerlink&quot; title=&quot;docker部署&quot;&gt;&lt;/a&gt;docker部署&lt;/h2&gt;&lt;h2 id=&quot;部署操作&quot;&gt;&lt;a href=&quot;#部署操作&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="开发部署" scheme="https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="devops" scheme="https://hideincode.github.io/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>并发编程</title>
    <link href="https://hideincode.github.io/2023/05/01/basic/%E5%B9%B6%E5%8F%91/"/>
    <id>https://hideincode.github.io/2023/05/01/basic/%E5%B9%B6%E5%8F%91/</id>
    <published>2023-04-30T16:00:00.000Z</published>
    <updated>2024-05-07T09:32:15.376Z</updated>
    
    
    
    
    <category term="基础知识" scheme="https://hideincode.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="threads" scheme="https://hideincode.github.io/tags/threads/"/>
    
    <category term="concurrent" scheme="https://hideincode.github.io/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>AC1337</title>
    <link href="https://hideincode.github.io/2022/08/08/algo/AC1337/"/>
    <id>https://hideincode.github.io/2022/08/08/algo/AC1337/</id>
    <published>2022-08-07T16:00:00.000Z</published>
    <updated>2024-05-07T10:39:18.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AC1337"><a href="#AC1337" class="headerlink" title="AC1337"></a>AC1337</h1><blockquote><p>用于记录刷题的一些思路和技巧</p></blockquote><h2 id="算法可行性"><a href="#算法可行性" class="headerlink" title="算法可行性"></a>算法可行性</h2><table><thead><tr><th>数据规模</th><th>算法可接受时间复杂度</th></tr></thead><tbody><tr><td>&lt;&#x3D; 10</td><td>O(n!)</td></tr><tr><td>&lt;&#x3D; 20</td><td>O(2^n)</td></tr><tr><td>&lt;&#x3D; 100</td><td>O(n^4)</td></tr><tr><td>&lt;&#x3D; 500</td><td>O(n^3)</td></tr><tr><td>&lt;&#x3D; 2500</td><td>O(n^2)</td></tr><tr><td>&lt;&#x3D; 10^6</td><td>O(nlogn)</td></tr><tr><td>&lt;&#x3D; 10^7</td><td>O(n)</td></tr><tr><td>&lt;&#x3D; 10^14</td><td>O(sqrt(n))</td></tr><tr><td>-</td><td>O(logn)</td></tr><tr><td>-</td><td>O(1)</td></tr></tbody></table><h2 id="线型处理逻辑"><a href="#线型处理逻辑" class="headerlink" title="线型处理逻辑"></a>线型处理逻辑</h2><p>存储已知情况</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><ul><li>单调栈，栈中元素为单调，<a href="https://leetcode-cn.com/problems/next-greater-element-i/">下一个最大的元素</a>。</li><li>成对出现的问题，用栈进行消消乐。</li></ul><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>单调队列</li><li>优先队列</li></ul><h2 id="树型处理逻辑"><a href="#树型处理逻辑" class="headerlink" title="树型处理逻辑"></a>树型处理逻辑</h2><h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><h4 id="组合问题"><a href="#组合问题" class="headerlink" title="组合问题"></a>组合问题</h4><ol><li><p>无重复元素，可重复选择，组合出一个target; </p><ul><li>下一层起点为i，这样保证只会从当前元素后开始往后选。</li></ul></li><li><p>有重复元素，不可重复选择，组合出一个target;</p><ol><li>排序，使得相同元素连在一起。</li><li>跳过相同元素。</li><li>从i + 1开始进入下层搜索。</li></ol></li></ol><h4 id="排列问题"><a href="#排列问题" class="headerlink" title="排列问题"></a>排列问题</h4><ol><li>无重复元素，所有排列情况;<ul><li>朴素版本(记录决策树):<ul><li>无需start，需要判断元素使用情况(visited数组&#x2F;基于无重复直接在容器里面判断)。</li></ul></li><li>进阶版本(交换元素):<ul><li>考虑start后面的每个位置来填充start，知道start到达n;即通过交换i，start;</li><li>下一层为start+1，即下一个要填的位置;</li><li>这样[0，start]就是统计过的排列，[start+1，n-1]就是待统计的。</li></ul></li></ul></li><li>有重复元素，排列情况。</li></ol><h4 id="子集问题"><a href="#子集问题" class="headerlink" title="子集问题"></a>子集问题</h4><blockquote><p>组合没有顺序上的要求，只是选择上区别;排列是对顺序有要求。</p></blockquote><ol><li>无重复元素，找所有子集。<ol><li>回溯:记录决策树的每一个结点即可</li><li>状态压缩:已知所有可能性，用二进制表示，记录每一这可能性;即二进制每一位表示是否选择。</li></ol></li><li>有重复元素，找所有子集:<ol><li>回溯:无重复情况+排序判断相邻元素去重。</li><li>状态压缩:无重复情况+排序判断相邻元素去重。即前一个元素相同但是没有被选择，那么选择当前情况必定重复。因为当前的情况之前肯定统计过了，考虑[1，2，2]的第二个2。。。</li><li>对重复元素排序处理:保证相同情况在同一层出现，出现一次就行了，后面都不再统计。</li><li>剪枝:有些时候需要贪心的先解决大的，大的搞不定小的肯定也不行。</li></ol></li></ol><h3 id="递归玩法"><a href="#递归玩法" class="headerlink" title="递归玩法"></a>递归玩法</h3><ul><li>定义状态</li><li>做出选择</li><li>缩小范围</li><li>上报结果</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>前缀和</p></li><li><p>计数</p></li><li><p>双指针</p></li><li><p>二分法</p><ol><li><p>找确定的目标值</p></li><li><p>猜数字</p></li><li><p>极大化极小，极小化极大。就是使得每部分的最大值最小。</p><blockquote><p>这种问题的一般结构就是，多种分配情况到达分组目标，每种情况中又会有最大值，判断所有情况中的最小的最大值。</p><p>具体题目模型参考: <a href="https://leetcode-cn.com/problems/split-array-largest-sum/">分割数组的最大值</a></p><p>也可以称之为: 根据答案二分。</p></blockquote></li><li><p>旋转有序数组，旋转后分成两部分</p><ol><li>两部分都是上升的</li><li>后部分小于前部分</li><li>利用和mid和left的值的对比，判断target处于哪个部分。</li></ol></li></ol></li><li><p>滑动窗口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (check()) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>原地哈希</p><blockquote><p>O(n)时间内使得数组有序，类似于计数排序，只不过把输入数组本身当成桶。</p></blockquote><ol><li>对于每个nums[i]，放入到对应下标位置。</li><li>再次遍历，没有归位的就是缺少的值。</li><li>一般有标记法和交换法</li><li>标记法<ol><li>对归位后的数字进行标记，提前把负数改成N+1</li><li>把值对应的位置上的值加上负号，即nums[nums[i] - 1] &#x3D; -abs(nums[nums[i] - 1])</li><li>没有标记为负数的就是没有归位的，即为缺失之数</li></ol></li><li>交换法：<ol><li>通过交换把值放到对应下标上，比如nums[0]放入nums[nums[0]]</li><li>再次遍历找出没有放入下标的值即可</li></ol></li></ol></li><li><p>动态规划</p><ul><li><p>前缀和:</p><blockquote><p>前缀和其实也是一种动态规划，拥有最优子结构，用于范围求和。而且前缀和中元素一般都是递增的，可以用二分搜索。</p></blockquote></li><li><p>后缀和：有些情况需要求<code>i</code>左边的结果和<code>i</code>右边的结果，来简化计算，需要同时求前缀和与后缀和。</p></li><li><p>背包问题<img src="/images/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB%E5%9B%BE.png" alt="分类"></p><ul><li><p>0-1背包：物品只能用一次，取决于选与不选。</p><p>一维空间:想明白遍历顺序，两个循环可否交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">    <span class="comment">//由大到小，不可与外层交换。</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j=cap;i&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="comment">//求容量为j时，最大值。</span></span><br><span class="line">        dp[j]=max(dp[j]，dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>完全背包: 物品可以重复选择，每次选择一个<br>一维空间:遍历顺序，循环可否交换位置。</p><p><strong>如果求组合数就是外层for循环遍历物品，内层for遍历背包</strong>。</p><p><strong>如果求排列数就是外层for遍历背包，内层for循环遍历物品</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">    <span class="comment">//又小到大，可以交换循环位置。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=cap;j++)&#123;</span><br><span class="line">        dp[j]=max(dp[j]，dp[j-w[i]]+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遍历顺序与排列组合的关系：外物内容是组合，外容内物是排列。</p><p><strong>如果求组合数就是外层for循环遍历物品个数，内层for遍历背包容量</strong>。</p><p><strong>如果求排列数就是外层for遍历背包容量，内层for循环遍历物品个数</strong>。</p></li><li><p>多重背包:物品有次数限制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; weight。length; i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">        <span class="comment">// 以上为01背包，然后加一个遍历个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= nums[i] &amp;&amp; (j - k * weight[i]) &gt;= <span class="number">0</span>; k++) &#123; <span class="comment">// 遍历个数</span></span><br><span class="line">            dp[j] = Math。max(dp[j]， dp[j - k * weight[i]] + k * value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System。out。println(Arrays。toString(dp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>01背包一维化理解</strong></p><blockquote><p>一维化的本质:就是把二维的每一行依次用一行表示。用新一行的结果覆盖老的结果。<br>由于二维情况可以，计算当前行需要上一行的值。<br>如果只保留一行的话，那么新计算的结果就要重新写入数组。<br>这时候不能覆盖上一行已经计算好的。<br>从左往右的覆盖的话，那么计算下个j用的就是当前的i，而非i-1。<br>从右往左的覆盖:用的还是上一行的数据。</p></blockquote></li><li><p>分组背包：每组只能选一个</p></li><li><p>回文串问题</p></li></ul></li></ul></li><li><p>差分数组：解决频繁<strong>范围</strong>修改，但是不用频繁查询的问题。</p><ol><li>[i， j]范围内全部+1，使用额外数组<code>dif[i]+1</code>，<code>dif[j+1]-1</code>。</li><li>用dif数组还原修改结果。</li></ol><blockquote><p>不需要首项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;diff。length;i++)&#123;</span><br><span class="line">dif[i]+=dif[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要首项</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dif[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;diff。length;i++)&#123;</span><br><span class="line">dif[i]=dif[i-<span class="number">1</span>]+nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><ol><li>dummy节点简化代码。</li><li>快慢指针：<ol><li>环形链表</li><li>两链表相交</li><li>删除重复值</li></ol></li><li>翻转链表：转化为基础的翻转链表。</li></ol><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><blockquote><p>这里指的是单纯的内存意义上的物理树，和逻辑树不同。</p></blockquote><ol><li><p>DFS(先序，中序，后序，mirrors)，BFS</p></li><li><p>二叉搜索树的中序遍历是升序</p></li><li><p>数的直径</p></li><li><p><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">公共祖先问题</a></p></li><li><p>树的生成</p><blockquote><ul><li>插入操作基于代码模式 root。next&#x3D;f(root。next，。。。)</li><li>一般分治而成，即找到根节点后把区间缩小，逐步生成</li></ul></blockquote></li></ol><p>​5。 树上dp</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ol><li><p>物理结构 ：邻接表、临界矩阵、边的数组、父结点数组、链式向前星。</p></li><li><p>求联通分量，并查集、dfs、tarjan、Kosaraju</p></li><li><p>找环：</p><ol><li>dfs</li><li>bfs</li></ol></li><li><p>拓扑排序：依赖顺序问题</p><ol><li>必须是有向无环图(DAG)</li><li>DFS的逆后序，即把dfs的后序结果用栈保存起来。</li><li>BFS:把入度为0的先放入，然后遍历到一个结点就减少这个结点的入度。</li></ol></li><li><p>最小生成树：</p><ol><li>Prim：点按照已经生成的森林最近的距离加入树</li><li>Kruskal：边按照权重排序加入生成树</li></ol></li><li><p>最短路：</p><ol><li>无权最短路：bfs</li><li>非负权重最短路：Dijstra，理解松弛操作，就是bfs加了优先队列。</li><li>负权重：Bellman-Ford，复杂度O(VE)</li></ol></li><li><p>欧拉回路</p></li><li><p>基环内向树：图中有环，环上有些节点会有分支，形成有一个有环的树。常见解法：</p><ol><li>用拓扑排序找出环</li><li>判断节点是在链表上，还是在环上</li></ol></li><li><p>二分图判定</p></li><li><p>DFS 时间戳，即Tarjan相关算法。</p></li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>排序问题<ul><li>计数排序 分组问题，通过组号分发到数组。</li><li>基数排序 <ul><li>LSD 定长字符串，从右往左排序。</li><li>MSD 随机字符串，从左往右排序。</li></ul></li><li>三向快排 处理有大量重复键的排序问题</li><li>常规比较排序</li></ul></li><li>查询问题<ul><li>Trie(字典树，前缀树)</li><li>Map</li></ul></li><li>子串查找<ul><li>暴力法</li><li>滑动窗口</li><li>KMP 了解DFA</li><li>BM</li><li>RK</li></ul></li><li>正则表达式 了解NFA</li><li>数据压缩 (数据都可以转成二进制，二进制流都可以理解为字符串)<ul><li>双位压缩 对于DNA的4种碱基ACTG，可以用11 00 01 10 四种方式表达，但是只用两位。</li><li>游程编码(Run-Length Encoding) 首先转为二进制，将连续相同部分进行编码，如<code>0000000000000001111111000000011111111111</code>记成15个0，7个1，7个0，11个1，由于01交换出现，所以只对长度就行，把15 7 7 1改成二进制1111 0111 0111 1011，完成压缩。</li><li>霍夫曼(Huffman) 通过字符出现频率压缩</li><li>LZW</li></ul></li></ul><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul><li><p>a | b：计算并集</p></li><li><p>a &amp; b： 求a和b的最长公共前缀后面补齐0。如1010与1000得到1000</p></li><li><p>a ^ b：不进位相加</p></li><li><p>汉明距离：x^(x-1) 最低位的1变成0。 如110 ^ (100 - 1)结果为100</p></li><li><p>lowbit: x &amp; (-x) 截断x最低位的1及其后缀，必定是2的n次幂。 如1100 &amp; (-1100）时结果为100</p></li><li><p>求子集: 求k的二进制子集，针对中的二进制为1的位开始进行减法，判断数字k的二进制子集， 像枚举(2^k-1) ~ 0一样枚举其子集</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> k;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">//sub就是一个子集</span></span><br><span class="line">    sub = (sub - <span class="number">1</span>) &amp; k;</span><br><span class="line">&#125; <span class="keyword">while</span>(sub != k);</span><br></pre></td></tr></table></figure></li><li><p>去掉最后一位 | (101101-&gt;10110) | x &gt;&gt;1</p></li><li><p>在最后加一个0 | (101101-&gt;1011010) | x &lt;&lt;1 </p></li><li><p>在最后加一个1 | (101101-&gt;1011011) | x &lt;&lt; 1+1 </p></li><li><p>把最后一位变成1 | (101100-&gt;101101) | x or 1 </p></li><li><p>把最后一位变成0 | (101101-&gt;101100) | x or 1-1 </p></li><li><p>最后一位取反 | (101101-&gt;101100) | x xor 1 </p></li><li><p>把右数第k位变成1 | (101001-&gt;101101，k&#x3D;3) | x or (1 &lt;&lt; (k-1)) </p></li><li><p>把右数第k位变成0 | (101101-&gt;101001，k&#x3D;3) | x and not(1 &lt;&lt; (k-1)) </p></li><li><p>右数第k位取反 | (101001-&gt;101101，k&#x3D;3) | x xor (1 &lt;&lt; (k-1)) </p></li><li><p>取末三位 | (1101101-&gt;101) | x and 7 </p></li><li><p>取末k位 | (1101101-&gt;1101，k&#x3D;5) | x and (1 &lt;&lt; k-1) </p></li><li><p>取右数第k位 | (1101101-&gt;1，k&#x3D;4) | x &gt;&gt; (k-1) and 1 </p></li><li><p>把末k位变成1 | (101001-&gt;101111，k&#x3D;4) | x or (1 &lt;&lt; k-1) </p></li><li><p>末k位取反 | (101001-&gt;100110，k&#x3D;4) | x xor (1 &lt;&lt; k-1) </p></li><li><p>把右边连续的1变成0 | (100101111-&gt;100100000) | x and (x+1) </p></li><li><p>把右起第一个0变成1 | (100101111-&gt;100111111) | x or (x+1) </p></li><li><p>把右边连续的0变成1 | (11011000-&gt;11011111) | x or (x-1) </p></li><li><p>取右边连续的1 | (100101111-&gt;1111) | (x xor (x+1)) &gt;&gt; 1</p></li></ul><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><h4 id="MOD运算"><a href="#MOD运算" class="headerlink" title="MOD运算"></a>MOD运算</h4><ul><li><p>同余定理:a MOD M&#x3D;&#x3D;b MOD M  等价于 (a-b) MOD &#x3D;&#x3D; 0</p></li><li><p>a + b会溢出: (a + b) mod M &#x3D; (a mod M + b mod M) mod M</p></li><li><p>防止出现负数 +M:(a - b) % M &#x3D; (a % M - b % M + M) % M</p></li><li><p>(ab)%M &#x3D; (a%M)(b%M)%M</p></li><li><p>对于MOD除法 这里要求b和M互质，且M是质数。</p><ul><li><p>不能这么玩（a&#x2F;b) % M !&#x3D; ((a%M) &#x2F; (b%M)) % M</p></li><li><p>正确玩法 求逆元+费马小定理 </p><blockquote><p>求（a&#x2F;b) % M问题转化为 求b的逆元，即a*b^(-1)%M，此时只需求b^(-1)的值</p><p>b* b^(-1)与1模M同余</p><p>费马小定理得：M为质数时，b^(M - 1) 与1模M同余</p><p>可得b* b^(M - 2)与1模M同余</p><p>取b的逆元为b^(M-2)</p><p>最终（a&#x2F;b) % M &#x3D;&#x3D; a * pow(b，M - 2) % M，pow为求幂，可用快速幂实现。</p></blockquote></li></ul></li></ul><h4 id="最大公因数与最小公倍数"><a href="#最大公因数与最小公倍数" class="headerlink" title="最大公因数与最小公倍数"></a>最大公因数与最小公倍数</h4><ul><li><p>gcd(a，b) &#x3D;&#x3D; gcd(b，a)</p></li><li><p>gcd(a，b) &#x3D;&#x3D; gcd(a-b， b) (a &gt; b)</p></li><li><p>gcd(a，b) &#x3D;&#x3D; gcd(a%b， b)</p></li><li><p>gcd(a，b，c) &#x3D;&#x3D; gcd(gcd(a，b)，c)</p></li><li><p>gcd(ka，kb) &#x3D;&#x3D;  kgcd(a，b)</p></li><li><p>最小公倍数模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lcm(a，b) = (a * b) / gcd(a，b)</span></span><br><span class="line"><span class="comment">//先乘后除防溢出</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lcm</span><span class="params">(<span class="type">long</span> a， <span class="type">long</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / gcd(a， b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="组合数取余"><a href="#组合数取余" class="headerlink" title="组合数取余"></a>组合数取余</h4><blockquote><p>从n中取m个元素，记为C(n， m) &#x3D; n! &#x2F; (m! * (n - m)!)，又知C(n， m) &#x3D; C(n - 1， m - 1) + C(n - 1， m);</p></blockquote><ul><li><p>求C(n， m) % M</p><ul><li><p>O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">long</span> C[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">getC</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">0</span> || j==i)</span><br><span class="line">                C[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C[i][j]=(C[i-<span class="number">1</span>][j-<span class="number">1</span>]+C[i-<span class="number">1</span>][j]) % M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>O(n)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆元方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">mo</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">long</span> <span class="title function_">C</span><span class="params">(<span class="type">long</span> n，<span class="type">long</span> m)</span>&#123;</span><br><span class="line">    <span class="type">long</span> M=<span class="number">0</span>，inv[N]，mul[N]，invMul[N];</span><br><span class="line">    <span class="keyword">while</span>(M&lt;=n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(M)&#123;</span><br><span class="line">            inv[M]=M==<span class="number">1</span>?<span class="number">1</span>:(mo-mo/M)*inv[mo%M]%mo;</span><br><span class="line">            mul[M]=mul[M-<span class="number">1</span>]*M%mo;</span><br><span class="line">            invMul[M]=invMul[M-<span class="number">1</span>]*inv[M]%mo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> mul[M]=<span class="number">1</span>，invMul[M]=<span class="number">1</span>;</span><br><span class="line">        M++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mul[n]*invMul[m]%mo*invMul[n-m]%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果对质数求余，可用Lucas定理在O(n)复杂度解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">Lucas</span><span class="params">(<span class="type">long</span> n，<span class="type">long</span> m，<span class="type">long</span> p)</span>&#123;</span><br><span class="line"><span class="type">long</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n|m)ans=ans*C(n%P，m%P)%P，n/=P，m/=P;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="概率与统计"><a href="#概率与统计" class="headerlink" title="概率与统计"></a>概率与统计</h3><blockquote><p>这类问题离不开随机函数</p></blockquote><p><strong>rand7生成rand10</strong></p><ul><li>蒙特卡洛方法之拒绝采样</li><li>(randX() - 1)*Y + randY()可以等概率的生成[1， X * Y]范围的随机数</li><li>大范围randx生成小范围randy:可用randx%y+1</li><li>x必须是y的倍数才能等概率的生成，所以如果不是倍数，那么对于生成的不符合的值要去掉。即一直循环到合适的。</li></ul><p><strong>水塘抽样</strong></p><ul><li>详见<a href="https://leetcode.cn/problems/linked-list-random-node/submissions/357625015/">相同概率取元素</a></li></ul><h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><ul><li>栈生成队列</li><li>队列生成栈</li><li>LFU</li><li>LRU</li></ul><h2 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h2><ul><li>线性筛：用于线性速度搜索n以内的质数</li><li>扫描线：矩阵相交求面积、周长、点的个数问题。</li><li>倍增：快速幂、最近公共祖先</li><li>摩尔投票法：消消乐。</li><li>计算根号2：牛顿迭代法</li><li>TopK问题<ul><li>堆(优先队列) O(nlogk)</li><li>快速选择 O(n)</li><li>二叉搜索树O(nlogk)</li><li>排序</li></ul></li><li>多路归并问题</li><li>快速选择</li><li>逆序对</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AC1337&quot;&gt;&lt;a href=&quot;#AC1337&quot; class=&quot;headerlink&quot; title=&quot;AC1337&quot;&gt;&lt;/a&gt;AC1337&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;用于记录刷题的一些思路和技巧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="解题技巧" scheme="https://hideincode.github.io/categories/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="algo" scheme="https://hideincode.github.io/tags/algo/"/>
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="https://hideincode.github.io/2022/08/08/algo/%E6%A8%A1%E6%9D%BF/"/>
    <id>https://hideincode.github.io/2022/08/08/algo/%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-08-07T16:00:00.000Z</published>
    <updated>2024-05-07T08:46:03.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="距离与个数"><a href="#距离与个数" class="headerlink" title="距离与个数"></a>距离与个数</h2><blockquote><p>计算数组中<code>i</code>到<code>j</code>的距离:<code>i - j</code></p><p>计算数组中<code>i</code>到<code>j</code>的元素个数: <code>i - j + 1</code></p></blockquote><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p><strong>一维</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对nums.length=n求前缀和</span></span><br><span class="line"><span class="comment">//sum[i]:[0,i-1]的和</span></span><br><span class="line"><span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    sum[i+<span class="number">1</span>]=sum[i]+nums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对grid[][]求前缀和,grid.length=m,grid[0].length=n</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        sum[i+<span class="number">1</span>][j+<span class="number">1</span>]=sum[i][j+<span class="number">1</span>]+sum[i+<span class="number">1</span>][j]-sum[i][j]+grid[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二维异或</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line"><span class="type">int</span>[][] sum = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">        sum[i+<span class="number">1</span>][j+<span class="number">1</span>]=sum[i][j+<span class="number">1</span>]^sum[i+<span class="number">1</span>][j]^sum[i][j]^matrix[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连续值分组循环模板"><a href="#连续值分组循环模板" class="headerlink" title="连续值分组循环模板"></a>连续值分组循环模板</h2><ol><li><p>哨兵法: 开头定义一个哨兵,相邻比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; n) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; nums[i] == nums[i + <span class="number">1</span>])&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    dist= i-start;</span><br><span class="line">cnt = i-start+<span class="number">1</span>;</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>标记法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相同的标记一下</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="归并排序的merge操作-合并两个有序数组"><a href="#归并排序的merge操作-合并两个有序数组" class="headerlink" title="归并排序的merge操作:合并两个有序数组"></a>归并排序的merge操作:合并两个有序数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] aux;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> lo,<span class="type">int</span> mid,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> lo;</span><br><span class="line">    <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> mid+<span class="number">1</span>;</span><br><span class="line">    System.arraycopy(nums,lo,aux,lo,hi-lo+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lo;i&lt;hi;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&gt;mid)&#123;</span><br><span class="line">            nums[i]=aux[q++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(q&gt;hi)&#123;</span><br><span class="line">            nums[i]=aux[p++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[p]&lt;nums[q])&#123;</span><br><span class="line">            nums[i]=nums[p];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            nums[i]=nums[q];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辗转相除法求最大公约数"><a href="#辗转相除法求最大公约数" class="headerlink" title="辗转相除法求最大公约数"></a>辗转相除法求最大公约数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(q, p % q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="partition操作：用于O-n-求topK或者快排。"><a href="#partition操作：用于O-n-求topK或者快排。" class="headerlink" title="partition操作：用于O(n)求topK或者快排。"></a>partition操作：用于O(n)求topK或者快排。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//跑的快的版本,使用快慢指针.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[lo];</span><br><span class="line">    <span class="comment">//j指向处理好的小范围.</span></span><br><span class="line">    <span class="type">int</span> j=lo;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=lo+<span class="number">1</span>;i&lt;=hi;i++)&#123;</span><br><span class="line"><span class="comment">//把小的调换到前面去,i一直标记大的</span></span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;pivot)&#123;</span><br><span class="line">            swap(a,++j,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把轴放中间</span></span><br><span class="line">    swap(a,lo,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//好理解的版本,使用双向指针.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> lo,<span class="type">int</span> hi)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> a[lo];</span><br><span class="line">    <span class="type">int</span> i=lo+<span class="number">1</span>,j=hi;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=pivot)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[j]&gt;=pivot)&#123;</span><br><span class="line">            j--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a,i,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(a,lo,j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序的heapify操作-把输入的数组构建成一个完全二叉树"><a href="#堆排序的heapify操作-把输入的数组构建成一个完全二叉树" class="headerlink" title="堆排序的heapify操作:把输入的数组构建成一个完全二叉树"></a>堆排序的heapify操作:把输入的数组构建成一个完全二叉树</h2><p>堆是一个选择器,能在<code>O(logN)</code>时间选出最值</p><ol><li><p><code>sink(k)</code>把下标k的元素下沉到合适位置,<code>swim(k)</code>把下标为k的元素上浮到合适位置，这个过程叫做堆化（heapify)</p></li><li><p>一个堆只有n&#x2F;2个父节点.</p></li><li><p>buildHeap就是把小堆合成大堆的过程</p></li><li><p>insert:加到数组结尾后swim</p></li><li><p>delete最大值:swap(a[0],a[n-1]),把a[n-1]删除,a[0]进行sink.</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建大根堆:把数组a构建成a[0]为最大值的堆.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//每个父节点都要尝试调整</span></span><br><span class="line">        sink(a, i, n);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自底向上堆化.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span>[] a,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span> (k &gt; <span class="number">0</span> &amp;&amp; a[(k-<span class="number">1</span>)/<span class="number">2</span>]&lt;a[k])</span><br><span class="line">     &#123;</span><br><span class="line">         swap(a,(k-<span class="number">1</span>)/<span class="number">2</span>, k);</span><br><span class="line">         k = (k-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自顶向下堆化: 父,左,右,选出最大为新的父节点.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, max = i;</span><br><span class="line">    <span class="comment">//找出父节点,左子节点,右子节点中的最大值的下标max.</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; a[l] &gt; a[max]) &#123;</span><br><span class="line">        max = l;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; a[r] &gt; a[max]) &#123;</span><br><span class="line">        max = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前父节点不是最大值,那么就要下沉</span></span><br><span class="line">    <span class="keyword">if</span> (max != i) &#123;</span><br><span class="line">        swap(a, i, max);</span><br><span class="line">        sink(a, max, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组-单点修改与区间查询"><a href="#树状数组-单点修改与区间查询" class="headerlink" title="树状数组:单点修改与区间查询"></a>树状数组:单点修改与区间查询</h2><ul><li>数组的区间查询首先考虑用前缀和,但是如果<strong>修改多于查询</strong>,那么就就要用到读和写都是<code>O(n)</code>的树状数组.</li><li>内存中的数据结构是数组,<strong>逻辑上是一棵树</strong>.</li><li>x&amp;(-x):求x的最低位的1和后面0组成的数字,俗称<code>lowbit</code>操作.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始数组长度</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//逻辑树</span></span><br><span class="line"><span class="type">int</span>[] tree;</span><br><span class="line"></span><br><span class="line">init(<span class="type">int</span> n)&#123;</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">    tree = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求最低位1和后面的0构成的数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">lowbit</span><span class="params">(n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &amp; (-n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把i处值增加d</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> d)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        tree[i]+=d;</span><br><span class="line">        <span class="comment">//所有父结点都要修改</span></span><br><span class="line">        i += lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询tree中[1,i]的前缀和,即原数组中[0,i-1]的和</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        sum+=tree[i];</span><br><span class="line">        i-=lowbit[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线段树-区间修改与区间查询"><a href="#线段树-区间修改与区间查询" class="headerlink" title="线段树: 区间修改与区间查询"></a>线段树: 区间修改与区间查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线段树（动态开点）、区间修改</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SegmentTreeDynamic</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node left, right;</span><br><span class="line">        <span class="comment">//val是子节点的和，add该节点所有对应的孩子节点都应该有此更新</span></span><br><span class="line">        <span class="type">int</span> val, add;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">//// 在区间 [start, end] 中更新区间 [l, r] 的值，将区间 [l, r] ➕ val</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) &#123;</span><br><span class="line">            node.val += (end - start + <span class="number">1</span>) * val;</span><br><span class="line">            node.add += val;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        pushDown(node, mid - start + <span class="number">1</span>, end - mid);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) update(node.left, start, mid, l, r, val);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) update(node.right, mid + <span class="number">1</span>, end, l, r, val);</span><br><span class="line">        pushUp(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在[start, end]中搜[l, r]的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(Node node, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= start &amp;&amp; end &lt;= r) <span class="keyword">return</span> node.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        pushDown(node, mid - start + <span class="number">1</span>, end - mid);</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= mid) ans += query(node.left, start, mid, l, r);</span><br><span class="line">        <span class="keyword">if</span> (r &gt; mid) ans += query(node.right, mid + <span class="number">1</span>, end, l, r);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改时，自上而下修改值。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushUp</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        node.val = node.left.val + node.right.val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查与改时，自上而下创建和修改节点。</span></span><br><span class="line">    <span class="comment">//leftNum表示左节点为根的子树个数，rightNum同理。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushDown</span><span class="params">(Node node, <span class="type">int</span> leftNum, <span class="type">int</span> rightNum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.left = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            node.right = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据标记add修改</span></span><br><span class="line">        <span class="keyword">if</span> (node.add == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左节点和 = 左节点的标记 x 节点个数</span></span><br><span class="line">        node.left.val += node.add * leftNum;</span><br><span class="line">        <span class="comment">//同理</span></span><br><span class="line">        node.right.val += node.add * rightNum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对区间进行「加减」的更新操作，下推懒惰标记时需要累加起来，不能直接覆盖</span></span><br><span class="line">        node.left.add += node.add;</span><br><span class="line">        node.right.add += node.add;</span><br><span class="line">        <span class="comment">//标记下传完成，删除标记。</span></span><br><span class="line">        node.add = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单点修改的线段树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] tree;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SegmentTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = nums;</span><br><span class="line">        <span class="built_in">this</span>.tree = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span> * nums.length];</span><br><span class="line">        <span class="keyword">if</span>(arr.length!=<span class="number">0</span>)&#123;</span><br><span class="line">            buildTree(<span class="number">0</span>,arr.length-<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            tree[root]=arr[start];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        buildTree(start,mid,left);</span><br><span class="line">        buildTree(mid+<span class="number">1</span>,end,right);</span><br><span class="line">        tree[root]=tree[left]+tree[right];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        update(<span class="number">0</span>,arr.length-<span class="number">1</span>,i,val,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> idx, <span class="type">int</span> val, <span class="type">int</span> root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            tree[root]=val;</span><br><span class="line">            arr[idx] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(idx&lt;=mid)&#123;</span><br><span class="line">            update(start,mid,idx,val,left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            update(mid+<span class="number">1</span>,end,idx,val,right);</span><br><span class="line">        &#125;</span><br><span class="line">        tree[root]=tree[left]+tree[right];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sum(<span class="number">0</span>,arr.length-<span class="number">1</span>,<span class="number">0</span>,i,j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,<span class="type">int</span> root, <span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;end||r&lt;start)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;=start&amp;&amp;r&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span> tree[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(start==end)&#123;</span><br><span class="line">            <span class="keyword">return</span> tree[root];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (start + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * root + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> left_sum=sum(start,mid,left,l,r);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right_sum</span> <span class="operator">=</span> sum(mid+<span class="number">1</span>,end,right,l,r);</span><br><span class="line">        <span class="keyword">return</span> left_sum+right_sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="快速乘-计算x-n"><a href="#快速乘-计算x-n" class="headerlink" title="快速乘: 计算x*n"></a>快速乘: 计算x*n</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//最低位是1,是有用的数字,放入结果</span></span><br><span class="line">        <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//累计结果</span></span><br><span class="line">            result += x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算下一位</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//x翻倍</span></span><br><span class="line">        x += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂-计算x-n"><a href="#快速幂-计算x-n" class="headerlink" title="快速幂: 计算x^n"></a>快速幂: 计算x^n</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">pow</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="comment">//最低位是1,是有用的数字,放入结果</span></span><br><span class="line">         <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">             <span class="comment">//累计结果</span></span><br><span class="line">             ans *= x;</span><br><span class="line">         &#125;</span><br><span class="line">         n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"><span class="comment">//x取平方            </span></span><br><span class="line">         x *= x;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ans;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>简单解释:</p><blockquote><p>*<em>快速乘: ** 5</em>3 &#x3D; 5 * (11)<sub>2</sub> &#x3D; 5 * ( (10)<sub>2</sub> + (1)<sub>2</sub>) &#x3D; 5 * (10)<sub>2</sub> + 5*1 &#x3D; (5 * 2<sup>1</sup> * 1 + 5 * 2<sup>0</sup> * 0) + 5 * 1&#x3D; ((5+5) * 1 + (5) * 0) +5 &#x3D; 15</p><p><strong>快速幂:</strong>  5^3 &#x3D; 5 ^ (11)<sub>2</sub> &#x3D; 5 ^ ( (10)<sub>2</sub> + (1)<sub>2</sub>) &#x3D; 5^ (10)<sub>2</sub> * 5^1 &#x3D; 5 ^ (2 * 1 + 1 * 0) * 5 &#x3D; 5 * 5 * 5 &#x3D; 125</p></blockquote><p>一般用于防止爆数据,加快计算速度. </p><h2 id="二维数组遍历方向问题"><a href="#二维数组遍历方向问题" class="headerlink" title="二维数组遍历方向问题"></a>二维数组遍历方向问题</h2><table><thead><tr><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>d</td><td>e</td><td>f</td></tr><tr><td>g</td><td>h</td><td>i</td></tr><tr><td>j</td><td>k</td><td>l</td></tr></tbody></table><ul><li><p>从对角线开始,斜向遍历 ↘ ↘ ↘</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>[][] cs = <span class="keyword">new</span> <span class="title class_">char</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m * n; i++) &#123;</span><br><span class="line">            cs[i / n][i % n] = (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] c : cs) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//斜线序号,给每条斜线标个序号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">            <span class="comment">//行坐标,每条斜线的行坐标越来越小;由于输出第一行(abc),所以是n-k;</span></span><br><span class="line">            <span class="comment">//不能是m-k,m-k只会输出m个,如果m&gt;n还好,如果m&lt;n将输出不完整.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - k; i++) &#123;</span><br><span class="line">                <span class="comment">//列坐标,行坐标+斜线序号</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> k + i;</span><br><span class="line">                <span class="comment">//越界检查</span></span><br><span class="line">                <span class="keyword">if</span> (i&gt;=m||j &gt;= n) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(cs[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]==pre)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">0</span>)&#123;</span><br><span class="line">            pre=nums[i];</span><br><span class="line">            cnt=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><ol><li><p>存在一个数target,返回下标.</p><blockquote><p>闭区间法 [left,right]</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>,mid;</span><br><span class="line"><span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">    mid=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;nums[mid])&#123;</span><br><span class="line">        right=mid-<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        left=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;         </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>返回&gt;&#x3D;target的最左位置，用于求&lt;target的个数,.</p><blockquote><p>开区间法 [left,right)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个&gt;=target的值</span></span><br><span class="line"><span class="comment">//返回结果可以表示有多少个元素比target小</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowerBound</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=arr.length,mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target&lt;=arr[mid])&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回&gt;target的最左位置，用于求&lt;&#x3D;target的个数。</p><blockquote><p>开区间法 [left,right)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个&gt;target的元素.</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">upperBound</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">0</span>,right=arr.length,mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(target&gt;=arr[mid])&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>永远有两个值的方式,用法不明待开发.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right)&#123;</span><br><span class="line">        <span class="comment">// Prevent (left + right) overflow</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post-processing:</span></span><br><span class="line">    <span class="comment">// End Condition: left + 1 == right</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] == target) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span>(nums[right] == target) <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="数组的一一映射问题"><a href="#数组的一一映射问题" class="headerlink" title="数组的一一映射问题"></a>数组的一一映射问题</h2><p>比如长度为n的数组里面只有[0,n-1]的元素,如果有重复的,给出重复的.</p><ol><li><p>映射问题:由一一映射变成1对多映射;</p></li><li><p>利用数组能直接<strong>根据下标查询和修改值</strong>得特性,把元素归位.</p></li><li><p>重复的元素的位置不够用,只要发现已经被占,那肯定重复.</p></li><li><p>对于有序数组,删除重复元素,最多保留k位重复值问题,快慢指针.慢指针会在k+1处等着新的不同值来覆盖.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; k || nums[idx - k] != x) nums[idx++] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="线性筛：O-n-筛选质数"><a href="#线性筛：O-n-筛选质数" class="headerlink" title="线性筛：O(n)筛选质数"></a>线性筛：O(n)筛选质数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  List&lt;Integer&gt; <span class="title function_">getPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//非素数标记</span></span><br><span class="line">    <span class="type">boolean</span>[] isnp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">    List&lt;Integer&gt; primes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//只能从2开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isnp[i])&#123;</span><br><span class="line">            primes.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p : primes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p * i &gt; n) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            isnp[p * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % p == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集：用于连通性问题"><a href="#并查集：用于连通性问题" class="headerlink" title="并查集：用于连通性问题"></a>并查集：用于连通性问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UF</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] size;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UF</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            size = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            count=n;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                parent[i]=i;</span><br><span class="line">                size[i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">proot</span> <span class="operator">=</span> find(p);</span><br><span class="line">            <span class="type">int</span> qroot= find(q);</span><br><span class="line">            <span class="keyword">if</span>(proot==qroot)&#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//平衡节点个数</span></span><br><span class="line">            <span class="keyword">if</span>(size[proot]&gt;size[qroot])&#123;</span><br><span class="line">                parent[qroot]=proot;</span><br><span class="line">                size[proot]+=size[qroot];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                parent[proot]=qroot;</span><br><span class="line">                size[qroot]+=size[proot]; </span><br><span class="line">            &#125;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(p!=parent[p])&#123;</span><br><span class="line">                <span class="comment">//路径压缩</span></span><br><span class="line">                parent[p]=parent[parent[p]];</span><br><span class="line">                p=parent[p];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">connected</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> q)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> find(p)==find(q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="字典树-用于具有相同前缀的字符串"><a href="#字典树-用于具有相同前缀的字符串" class="headerlink" title="字典树: 用于具有相同前缀的字符串"></a>字典树: 用于具有相同前缀的字符串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">boolean</span> val;</span><br><span class="line">        <span class="keyword">private</span> Node[] next = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.next[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.val = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; key.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPrefixOf</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.val) &#123;</span><br><span class="line">                end = i;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(<span class="number">0</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">shortestPrefixOf</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        Node cur=root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(cur.next[c-<span class="string">&#x27;a&#x27;</span>]==<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=cur.next[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(cur.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> s.substring(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先找到prefix的结点,再以此节点开始探索所有可能.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> set;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.next[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> set;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        startsWith(cur, prefix, set);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">startsWith</span><span class="params">(Node cur, String prefix, List&lt;String&gt; trace)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.val) &#123;</span><br><span class="line">            trace.add(prefix);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每一个字符有26种选择.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">            startsWith(cur.next[j], prefix + ((<span class="type">char</span>) (j + <span class="string">&#x27;a&#x27;</span>)), trace);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keys</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> startsWith(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s中含有通配符.,配置符合要求的值.</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">keysMatch</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        keysMatch(root, <span class="string">&quot;&quot;</span>, s, list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">keysMatch</span><span class="params">(Node root, String pre, String pat, List&lt;String&gt; trace)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//完成匹配</span></span><br><span class="line">        <span class="keyword">if</span> (pre.length() == pat.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.val) &#123;</span><br><span class="line">                trace.add(pre);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span> <span class="variable">next</span> <span class="operator">=</span> pat.charAt(pre.length());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="string">&#x27;.&#x27;</span> || (next - <span class="string">&#x27;a&#x27;</span>) == i) &#123;</span><br><span class="line">                keysMatch(root.next[i], pre + ((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i)), pat, trace);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        delete(root, key, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">delete</span><span class="params">(Node root, String key, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d == key.length()) &#123;</span><br><span class="line">            root.val = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> key.charAt(d);</span><br><span class="line">            root.next[c - <span class="string">&#x27;a&#x27;</span>] = delete(root.next[c - <span class="string">&#x27;a&#x27;</span>], key, d + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.next[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            cnt += size(root.next[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求子集-二进制状态压缩后，求出所有子集。"><a href="#求子集-二进制状态压缩后，求出所有子集。" class="headerlink" title="求子集: 二进制状态压缩后，求出所有子集。"></a>求子集: 二进制状态压缩后，求出所有子集。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求mask的二进制子集</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sub</span> <span class="operator">=</span> mask;</span><br><span class="line"><span class="keyword">while</span> (sub ! = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//这个sub就是子集之一</span></span><br><span class="line">    sub = (sub - <span class="number">1</span>) &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求所有情况子集：对于2-n种情况遍历-根据题目描述过滤"><a href="#求所有情况子集：对于2-n种情况遍历-根据题目描述过滤" class="headerlink" title="求所有情况子集：对于2^n种情况遍历,根据题目描述过滤"></a>求所有情况子集：对于2^n种情况遍历,根据题目描述过滤</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">0</span>;mask&lt;(<span class="number">1</span>&lt;&lt;n);mask++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//根据mask判断当前情况,即检查mask每一位的情况.</span></span><br><span class="line">        <span class="keyword">if</span>(((mask&gt;&gt;i)&amp; <span class="number">1</span>) !=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//符合mask状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><blockquote><p>Least Frequently Used,淘汰频率最少使用的,最少使用次数相同,淘汰最旧的.</p></blockquote><ol><li><p>要统计频率,定义一个freq变量, put或者get时+1</p></li><li><p>缓存满了,删除freq最小的key,若有多个,删除最旧的</p></li><li><p>建立freq到key的映射关系,方便根据freq找key</p><ol><li>使用minFreq记录最小次数,方便删除</li></ol></li><li><p>freq和key是一对多的,且key列表存在时序</p></li><li><p>删除一个key时freq+1,就是把当前key放到freq+1里面去</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line">    <span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br><span class="line">    <span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="type">int</span> minFreq;</span><br><span class="line">    <span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        keyToVal = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        keyToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!keyToVal.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 增加 key 对应的 freq</span></span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span> keyToVal.get(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 若 key 已存在，修改对应的 val 即可 */</span></span><br><span class="line">        <span class="keyword">if</span> (keyToVal.containsKey(key)) &#123;</span><br><span class="line">            keyToVal.put(key, val);</span><br><span class="line">            <span class="comment">// key 对应的 freq 加一</span></span><br><span class="line">            increaseFreq(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* key 不存在，需要插入 */</span></span><br><span class="line">        <span class="comment">/* 容量已满的话需要淘汰一个 freq 最小的 key */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.cap &lt;= keyToVal.size()) &#123;</span><br><span class="line">            removeMinFreqKey();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 插入 key 和 val，对应的 freq 为 1 */</span></span><br><span class="line">        <span class="comment">// 插入 KV 表</span></span><br><span class="line">        keyToVal.put(key, val);</span><br><span class="line">        <span class="comment">// 插入 KF 表</span></span><br><span class="line">        keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 插入 FK 表</span></span><br><span class="line">        freqToKeys.putIfAbsent(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">        freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line">        <span class="comment">// 插入新 key 后最小的 freq 肯定是 1</span></span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">increaseFreq</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> keyToFreq.get(key);</span><br><span class="line">        <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">        keyToFreq.put(key, freq + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">        <span class="comment">// 将 key 从 freq 对应的列表中删除</span></span><br><span class="line">        freqToKeys.get(freq).remove(key);</span><br><span class="line">        <span class="comment">// 将 key 加入 freq + 1 对应的列表中</span></span><br><span class="line">        freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">        freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line">        <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">        <span class="keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;</span><br><span class="line">            freqToKeys.remove(freq);</span><br><span class="line">            <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">            <span class="keyword">if</span> (freq == <span class="built_in">this</span>.minFreq) &#123;</span><br><span class="line">                <span class="built_in">this</span>.minFreq++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeMinFreqKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// freq 最小的 key 列表</span></span><br><span class="line">        LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="built_in">this</span>.minFreq);</span><br><span class="line">        <span class="comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">deletedKey</span> <span class="operator">=</span> keyList.iterator().next();</span><br><span class="line">        <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">        keyList.remove(deletedKey);</span><br><span class="line">        <span class="keyword">if</span> (keyList.isEmpty()) &#123;</span><br><span class="line">            freqToKeys.remove(<span class="built_in">this</span>.minFreq);</span><br><span class="line">            <span class="comment">// 问：这里需要更新 minFreq 的值吗？</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 更新 KV 表 */</span></span><br><span class="line">        keyToVal.remove(deletedKey);</span><br><span class="line">        <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">        keyToFreq.remove(deletedKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><blockquote><p>Least Recently Used,淘汰最近最少使用</p></blockquote><ol><li><p>缓存中的数据要有时序,考虑链表或者说队列</p></li><li><p>要能快速找到key对应的val,那么就是hashmap</p></li><li><p>上面两者结合,就是LinkedHashMap</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// 修改 key 的值</span></span><br><span class="line">            cache.put(key, val);</span><br><span class="line">            <span class="comment">// 将 key 变为最近使用</span></span><br><span class="line">            makeRecently(key);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cache.size() &gt;= <span class="built_in">this</span>.cap) &#123;</span><br><span class="line">            <span class="comment">// 链表头部就是最久未使用的 key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">oldestKey</span> <span class="operator">=</span> cache.keySet().iterator().next();</span><br><span class="line">            cache.remove(oldestKey);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新的 key 添加链表尾部</span></span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">makeRecently</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 删除 key，重新插入到队尾</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">        cache.put(key, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h1&gt;&lt;h2 id=&quot;距离与个数&quot;&gt;&lt;a href=&quot;#距离与个数&quot; class=&quot;headerlink&quot; title=&quot;距离与个数&quot;&gt;&lt;/a&gt;距离与个</summary>
      
    
    
    
    <category term="解题技巧" scheme="https://hideincode.github.io/categories/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="algo" scheme="https://hideincode.github.io/tags/algo/"/>
    
  </entry>
  
  <entry>
    <title>经典问题</title>
    <link href="https://hideincode.github.io/2022/08/08/algo/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/"/>
    <id>https://hideincode.github.io/2022/08/08/algo/%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98/</id>
    <published>2022-08-07T16:00:00.000Z</published>
    <updated>2024-05-07T08:45:58.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划:"></a>动态规划:</h2><h3 id="求最值"><a href="#求最值" class="headerlink" title="求最值:"></a>求最值:</h3><ul><li><p>问题</p><ul><li>给定目标，找到达到目标的最小（最大）成本&#x2F;路径&#x2F;总和。</li></ul></li><li><p>答案</p><ul><li><p>在当前状态之前的所有可能路径中选择最小（最大）路径，然后为当前状态添加值。</p></li><li><pre><code class="java">//状态转移方程routes[i] = min(routes[i-1], routes[i-2], ... , routes[i-k]) + cost[i]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```</span><br><span class="line">  for (int i = 1; i &lt;= target; ++i) &#123;</span><br><span class="line">     for (int j = 0; j &lt; ways.size(); ++j) &#123;</span><br><span class="line">         if (ways[j] &lt;= i) &#123;</span><br><span class="line">             dp[i] = min(dp[i], dp[i - ways[j]] + cost / path / sum) ;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  return dp[target]</span><br></pre></td></tr></table></figure>---[746. Min Cost Climbing Stairs Easy](https://leetcode-cn.com/problems/min-cost-climbing-stairs)[64. Minimum Path Sum Medium](https://leetcode-cn.com/problems/minimum-path-sum)[322. Coin Change Medium](https://leetcode-cn.com/problems/coin-change)[931. Minimum Falling Path Sum Medium](https://leetcode-cn.com/problems/minimum-falling-path-sum)[983. Minimum Cost For Tickets Medium](https://leetcode-cn.com/problems/minimum-cost-for-tickets)[650. 2 Keys Keyboard Medium](https://leetcode-cn.com/problems/2-keys-keyboard)[279. Perfect Squares Medium](https://leetcode-cn.com/problems/perfect-squares)[1049. Last Stone Weight II Medium](https://leetcode-cn.com/problems/last-stone-weight-ii)[120. Triangle Medium](https://leetcode-cn.com/problems/triangle)[474. Ones and Zeroes Medium](https://leetcode-cn.com/problems/ones-and-zeroes)[221. Maximal Square Medium](https://leetcode-cn.com/problems/maximal-square)[322. Coin Change Medium](https://leetcode-cn.com/problems/coin-change)[1240. Tiling a Rectangle with the Fewest Squares Hard](https://leetcode-cn.com/problems/tiling-a-rectangle-with-the-fewest-squares)[174. Dungeon Game Hard](https://leetcode-cn.com/problems/dungeon-game)[871. Minimum Number of Refueling Stops Hard](https://leetcode-cn.com/problems/minimum-number-of-refueling-stops)---</code></pre></li></ul></li></ul><h3 id="方案计数"><a href="#方案计数" class="headerlink" title="方案计数"></a>方案计数</h3><ul><li><p>问题</p><ul><li>给定一个目标，找到许多达到目标的独特方法。要分清分类计数原理,分步计数原理;</li></ul></li><li><p>答案</p><ul><li><p>总结所有可能的方法以达到当前状态。</p></li><li><pre><code class="java">routes[i] = routes[i-1] + routes[i-2], ... , + routes[i-k]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  for (int i = 1; i &lt;= target; ++i) &#123;</span><br><span class="line">     for (int j = 0; j &lt; ways.size(); ++j) &#123;</span><br><span class="line">         if (ways[j] &lt;= i) &#123;</span><br><span class="line">             dp[i] += dp[i - ways[j]];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  return dp[target]</span><br></pre></td></tr></table></figure>---[70. Climbing Stairs easy](https://leetcode-cn.com/problems/climbing-stairs)[62. Unique Paths Medium](https://leetcode-cn.com/problems/unique-paths)[1155. Number of Dice Rolls With Target Sum Medium](https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum)[688. Knight Probability in Chessboard Medium](https://leetcode-cn.com/problems/knight-probability-in-chessboard)[494. Target Sum Medium](https://leetcode-cn.com/problems/target-sum)[377. Combination Sum IV Medium](https://leetcode-cn.com/problems/combination-sum-iv)[935. Knight Dialer Medium](https://leetcode-cn.com/problems/knight-dialer)[1223. Dice Roll Simulation Medium](https://leetcode-cn.com/problems/dice-roll-simulation)[416. Partition Equal Subset Sum Medium](https://leetcode-cn.com/problems/partition-equal-subset-sum)[808. Soup Servings Medium](https://leetcode-cn.com/problems/soup-servings)[790. Domino and Tromino Tiling Medium](https://leetcode-cn.com/problems/domino-and-tromino-tiling)[801. Minimum Swaps To Make Sequences Increasing](https://leetcode-cn.com/problems/minimum-swaps-to-make-sequences)[673. Number of Longest Increasing Subsequence Medium](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence)[63. Unique Paths II Medium](https://leetcode-cn.com/problems/unique-paths-ii)[576. Out of Boundary Paths Medium](https://leetcode-cn.com/problems/out-of-boundary-paths)[1269. Number of Ways to Stay in the Same Place After Some Steps Hard](https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps)[1220. Count Vowels Permutation Hard](https://leetcode-cn.com/problems/count-vowels-permutation)---</code></pre></li></ul></li></ul><h3 id="区间DP"><a href="#区间DP" class="headerlink" title="区间DP"></a>区间DP</h3><ul><li><p>问题</p><ul><li>给定一组数字，考虑到当前数字以及从左侧和右侧可获得的最佳值，可以找到问题的最佳解决方案。</li></ul></li><li><p>答案</p><ul><li><p>找到每个间隔的所有最佳解决方案，并返回最佳答案。</p></li><li><pre><code class="java">dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* ```java</span><br><span class="line">  for(int l = 1; l&lt;n; l++) &#123;</span><br><span class="line">     for(int i = 0; i&lt;n-l; i++) &#123;</span><br><span class="line">         int j = i+l;</span><br><span class="line">         for(int k = i; k&lt;j; k++) &#123;</span><br><span class="line">             dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  return dp[0][n-1]</span><br></pre></td></tr></table></figure>---[1130. Minimum Cost Tree From Leaf Values Medium](https://leetcode-cn.com/problems/minimum-cost-tree-from-leaf-values)[96. Unique Binary Search Trees Medium](https://leetcode-cn.com/problems/unique-binary-search-trees)[1039. Minimum Score Triangulation of Polygon Medium](https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon)[546. Remove Boxes Medium](https://leetcode-cn.com/problems/remove-boxes)[1000. Minimum Cost to Merge Stones Medium](https://leetcode-cn.com/problems/minimum-cost-to-merge-stones)[312. Burst Balloons Hard](https://leetcode-cn.com/problems/burst-balloons)[375. Guess Number Higher or Lower II Medium](https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii)---</code></pre></li></ul></li></ul><h3 id="字符串上的DP"><a href="#字符串上的DP" class="headerlink" title="字符串上的DP"></a>字符串上的DP</h3><ul><li><p>问题</p><ul><li>此模式的一般问题陈述可能会有所不同，但大多数情况下会给您两个字符串，这些字符串的长度不大.</li></ul></li><li><p>答案</p><ul><li><p>这种模式中的大多数问题都需要一种可以接受O（n ^ 2）复杂度的解决方案。</p></li><li><pre><code class="java">// i - indexing string s1// j - indexing string s2for (int i = 1; i &lt;= n; ++i) &#123;   for (int j = 1; j &lt;= m; ++j) &#123;       if (s1[i-1] == s2[j-1]) &#123;           dp[i][j] = /*code*/;       &#125; else &#123;           dp[i][j] = /*code*/;       &#125;   &#125;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    ---</span><br><span class="line"></span><br><span class="line">    [1143. Longest Common Subsequence Medium](https://leetcode-cn.com/problems/longest-common-subsequence)</span><br><span class="line">    [647. Palindromic Substrings Medium](https://leetcode-cn.com/problems/palindromic-substrings)</span><br><span class="line">    [516. Longest Palindromic Subsequence Medium](https://leetcode-cn.com/problems/longest-palindromic-subsequence)</span><br><span class="line">    [1092. Shortest Common Supersequence Medium](https://leetcode-cn.com/problems/shortest-common-supersequence)</span><br><span class="line">    [72. Edit Distance Hard](https://leetcode-cn.com/problems/edit-distance)</span><br><span class="line">    [115. Distinct Subsequences Hard](https://leetcode-cn.com/problems/distinct-subsequences)</span><br><span class="line">    [712. Minimum ASCII Delete Sum for Two Strings Medium](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings)</span><br><span class="line">    [5. Longest Palindromic Substring Medium](https://leetcode-cn.com/problems/longest-palindromic-substring)</span><br><span class="line"></span><br><span class="line">    ---</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 0-1背包问题</span><br><span class="line"></span><br><span class="line">* 问题</span><br><span class="line"></span><br><span class="line">  * 考虑使用和不使用当前状态的,做出你的选择</span><br><span class="line"></span><br><span class="line">* 答案</span><br><span class="line"></span><br><span class="line">  * 如果决定选择当前值，请使用先前的结果（忽略该值）； 反之亦然，如果您决定忽略当前值，请使用使用值的先前结果。</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    // i - indexing a set of values</span><br><span class="line">    // j - options to ignore j values</span><br><span class="line">    for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">       for (int j = 1; j &lt;= k; ++j) &#123;</span><br><span class="line">           dp[i][j] = max(&#123;dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]&#125;);</span><br><span class="line">           dp[i][j-1] = max(&#123;dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]&#125;);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>---[198. House Robber Easy](https://leetcode-cn.com/problems/house-robber)[121. Best Time to Buy and Sell Stock Easy](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)[714. Best Time to Buy and Sell Stock with Transaction Fee Medium](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)[309. Best Time to Buy and Sell Stock with Cooldown Medium](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)[123. Best Time to Buy and Sell Stock III Hard](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii)[188. Best Time to Buy and Sell Stock IV Hard](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv)---</code></pre></li></ul></li></ul><h2 id="经典例题"><a href="#经典例题" class="headerlink" title="经典例题"></a>经典例题</h2><p>LIS：<a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></p><p>LCS：<a href="https://leetcode.cn/problems/longest-common-subsequence/">最长公共子串</a></p><p>MSA：<a href="https://leetcode.cn/problems/maximum-subarray/">最大和子数组</a></p><p>LPS：<a href="https://leetcode.cn/problems/longest-palindromic-substring/">最长回文子串</a></p><p>​</p><h2 id="常见面试思路题目"><a href="#常见面试思路题目" class="headerlink" title="常见面试思路题目"></a>常见面试思路题目</h2><ul><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-common-urls.md">如何从大量的 URL 中找出相同的 URL？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-top-100-words.md">如何从大量数据中找出高频词？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-top-1-ip.md">如何找出某一天访问百度网站最多的 IP？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-no-repeat-number.md">如何在大量的数据中找出不重复的整数？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-a-number-if-exists.md">如何在大量的数据中判断一个数是否存在？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-hotest-query-string.md">如何查询最热门的查询串？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/count-different-phone-numbers.md">如何统计不同电话号码的个数？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-mid-value-in-500-millions.md">如何从 5 亿个数中找出中位数？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/sort-the-query-strings-by-counts.md">如何按照 query 的频度排序？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/find-rank-top-500-numbers.md">如何找出排名前 500 的数？</a></li><li><a href="https://gitee.com/hideincode/advanced-java/blob/main/docs/big-data/topk-problems-and-solutions.md">讲讲大数据中 TopK 问题的常用套路？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经典问题&quot;&gt;&lt;a href=&quot;#经典问题&quot; class=&quot;headerlink&quot; title=&quot;经典问题&quot;&gt;&lt;/a&gt;经典问题&lt;/h1&gt;&lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划:&quot;&gt;&lt;/</summary>
      
    
    
    
    <category term="解题技巧" scheme="https://hideincode.github.io/categories/%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="algo" scheme="https://hideincode.github.io/tags/algo/"/>
    
  </entry>
  
  <entry>
    <title>网络</title>
    <link href="https://hideincode.github.io/2022/07/07/basic/%E7%BD%91%E7%BB%9C/"/>
    <id>https://hideincode.github.io/2022/07/07/basic/%E7%BD%91%E7%BB%9C/</id>
    <published>2022-07-06T16:00:00.000Z</published>
    <updated>2024-05-07T09:00:24.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="浏览器输入网址到展示内容发生了什么？"><a href="#浏览器输入网址到展示内容发生了什么？" class="headerlink" title="浏览器输入网址到展示内容发生了什么？"></a>浏览器输入网址到展示内容发生了什么？</h2><ol><li>DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索⾃身的 DNS 缓存、搜索操 作系统的 DNS 缓存、读取本地的 Host ⽂件和向本地 DNS 服务器进⾏查询等。对于向本地 DNS 服务器进⾏ 查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有 权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此⽹址映射关系，则调⽤这 个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该⽹址映射关系，那 么将根据其设置发起递归查询或者迭代查询；</li><li>TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建⽴链接，发起三次握⼿； </li><li>发送 HTTP 请求：TCP 连接建⽴起来后，浏览器向服务器发送 HTTP 请求； </li><li>服务器处理请求并返回 HTTP 报⽂：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进⾏处 理，并将处理结果及相应的视图返回给浏览器； </li><li>浏览器解析渲染⻚⾯：浏览器解析并渲染视图，若遇到对 js ⽂件、css ⽂件及图⽚等静态资源的引⽤，则᯿复 上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染⻚⾯，最终向⽤户呈现⼀个完整的 ⻚⾯。 </li><li>连接结束。</li></ol><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><blockquote><p>闭上眼睛再背一边</p></blockquote><h2 id="什么握手要三次？"><a href="#什么握手要三次？" class="headerlink" title="什么握手要三次？"></a>什么握手要三次？</h2><p>需要客户端确认服务端的收发能力</p><p>也需要服务端确认客户端的收发能力</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><blockquote><p>背</p></blockquote><h2 id="为什么要挥手四次？"><a href="#为什么要挥手四次？" class="headerlink" title="为什么要挥手四次？"></a>为什么要挥手四次？</h2><p>需要确认断开</p><p>这里客户端最后一次发送后会进入TIME_WAIT状态，需要保证服务端收到ACK报文。</p><p>没有收到的话服务端会重新发送FIN报文。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="post与get的区别"><a href="#post与get的区别" class="headerlink" title="post与get的区别"></a>post与get的区别</h3><ol><li><p>使用场景：get获取资源，post传输对象</p></li><li><p>参数：get请求需要编码，post可以用中文。</p></li><li><p>安全性：get是安全的，post不是。</p></li><li><p>幂等性：get是幂等的，post不是。</p></li><li><p>可缓存：</p><ol><li>请求报文方法：get可缓存，post多数情况下不可缓存。</li><li>响应报文状态码：可缓存。</li><li>响应报文的Cache-Control首部字段没有指定不进行缓存。</li></ol></li></ol><h3 id="不同版本的区别"><a href="#不同版本的区别" class="headerlink" title="不同版本的区别"></a>不同版本的区别</h3><ul><li><p>http1.0:不能长连接，只能短连接。打开需要connection:keep-alive;</p></li><li><p>http1.1:可以长连接，多个http请求服务器也只能一个个响应。默认长连接，</p></li><li><p>http2.0:多路复用，把报文分解成更小的二进制帧传送，不用http报文可以混合在一个TCP连接上传输。</p></li></ul><h3 id="与HTTPS的区别"><a href="#与HTTPS的区别" class="headerlink" title="与HTTPS的区别"></a>与HTTPS的区别</h3><ul><li>开销：HTTPS要用到CA申请证书，一般免费证书很少，需要花钱。</li><li>资源消耗：HTTP明文传输；HTTPS加密传输，占用更多CPU和内存。</li><li>端口不同：HTTP80；HTTPS443；</li><li>安全性：HTTP简单的无状态协议；HTTPS是TSL+HTTP进行加密传输、身份认证的网络协议、更安全。</li></ul><h2 id="HTTPS的工作流程"><a href="#HTTPS的工作流程" class="headerlink" title="HTTPS的工作流程"></a>HTTPS的工作流程</h2><ul><li>客户端发送加密规则给服务端告诉服务端要进行连接了。</li><li>服务器重中选出一套加密算法和hash算法以及自己的身份信息一证书的形式发送给浏览器。一般包括：服务器信息、加密公钥、整数的办法机构。</li><li>客户端收到证书后<ul><li>验证证书的合法性</li><li>通过后，生成一串随机数，对证书的公钥进行加密。</li><li>用约定好的hash算法计算握手信息，然后用生成的密钥加密，一起发给服务器。</li></ul></li><li>服务接受到信息后<ul><li>用私钥解析处密码，用密码解析握手信息，验证hash和浏览器发来的是否一致</li><li>使用密钥加密</li></ul></li><li>如果hash一致，握手成功。</li></ul><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><p>TCP：</p><ol><li>面向连接的运输层协议：传数据前必须先建立通道。</li><li>一个TCP只能有两个端点，一一映射。</li><li>可靠：不重、不漏、不错、有序。</li><li>双全工通信。</li><li>面向字节流。</li></ol><p>UDP:</p><pre><code>1. 无连接传输层协议1. 尽力而为传输，不可靠。1. 面向报文的，对应用层的报文不合并、不拆分，保留报文边界。1. 没有拥塞机制，不会降低发送效率。1. 可以一对一、一对多、多对多。1. 首部开销小，只有8字节。</code></pre><p>对比：</p><ol><li>TCP可靠，UDP不可靠。</li><li>TCP面向连接，UDP无连接。</li><li>TCP有序，UDP无序。</li><li>TCP不保存数据边界，UDP保存数据边界。</li><li>TCP传输较慢。</li><li>TCP拥有流量控制和拥塞控制，UDP没有。</li><li>TCP比较重量级。</li><li>TCP首部20字节，UDP首部8字节。</li></ol><h2 id="五层网络协议"><a href="#五层网络协议" class="headerlink" title="五层网络协议"></a>五层网络协议</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ol><li>http</li><li>ftp：文件传输</li><li>smtp：简单邮件传输</li><li>dns：域名系统</li><li>ssh：安全外壳</li><li>dhcp：动态主机配置</li><li>telnet：远程登录</li></ol><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ol><li>tcp：传输控制协议</li><li>udp：用户数据报文协议</li></ol><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ol><li><p>ip：网际协议</p></li><li><p>arp：地址转换协议</p><blockquote><p>IP与物理地址的映射，如果发送数据包时能找到此映射就直接使用对应MAC地址，否则就直接广播出去。</p></blockquote></li><li><p>rarp：反向地址转换协议</p></li><li><p>icmp：Internet控制报文协议</p></li><li><p>igmp：Internet组管理协议</p></li><li><p>rip：路由信息协议</p></li><li><p>ospf：分布式链路状态协议</p></li><li><p>bgp：边界网关协议</p></li></ol><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ol><li>arq：自动重传请求协议</li><li>csma&#x2F;cd：停止等待协议</li><li>ppp：点对点协议</li></ol><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ol><li>中继器</li><li>集线器</li><li>网线</li><li>HUB</li></ol><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><p>TCP传输时，一个数据包包含了发送端发送的两个数据包信息，就叫粘包。</p><p>具体的可分为发送方粘包和接收方粘包。</p><ul><li>发送方粘包<ul><li>TCP长连接时，当发送数据包过于小时，会启用Nagle算法，将小包和并发送，在缓冲区进行，发送出来就是粘包的。</li></ul></li><li>接收方粘包<ul><li>接收方接到数据，传输层的TCP会将数据包放到缓冲区，然后由应用层来获取。如果这时候应用层读取函数不能及时把缓冲区数据拿出来，那下一个数据又会补充道缓冲区末尾，形成粘包。</li></ul></li><li>如何解决粘包<ul><li>特殊字符控制</li><li>在包头添加数据包的长度</li><li>如果使用netty的话，可以有专门的编码器和解码器来解决这个问题。</li><li>UDP不会有粘包问题，UDP会丢包和乱序。</li></ul></li></ul><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>为了避免数据在传输过程中被替换，⽐如⿊客修改了你的报⽂内容，但是你并不知道，所以我们让发送端做⼀个数 字签名，把数据的摘要消息进⾏⼀个加密，⽐如 MD5，得到⼀个签名，和数据⼀起发送。然后接收端把数据摘要 进⾏ MD5 加密，如果和签名⼀样，则说明数据确实是真的。</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>对称加密中，双⽅使⽤公钥进⾏解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥 也被替换，则仍然可以伪造数据，因为⽤户不知道对⽅提供的公钥其实是假的。所以为了保证发送⽅的公钥是真 的，CA 证书机构会负责颁发⼀个证书，⾥⾯的公钥保证是真的，⽤户请求服务器时，服务器将证书发给⽤户，这 个证书是经由系统内置证书的备案的。</p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><ol><li>sql注入</li><li>xss</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h1&gt;&lt;h2 id=&quot;浏览器输入网址到展示内容发生了什么？&quot;&gt;&lt;a href=&quot;#浏览器输入网址到展示内容发生了什么？&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="基础知识" scheme="https://hideincode.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="socket" scheme="https://hideincode.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper</title>
    <link href="https://hideincode.github.io/2022/03/01/system/Zookeeper/"/>
    <id>https://hideincode.github.io/2022/03/01/system/Zookeeper/</id>
    <published>2022-02-28T16:00:00.000Z</published>
    <updated>2024-05-07T08:57:47.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><blockquote><p>用于协调分布式组件，包括配置管理、名字服务、分布式锁、集群管理。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Zookeeper&quot;&gt;&lt;a href=&quot;#Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper&quot;&gt;&lt;/a&gt;Zookeeper&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;用于协调分布式组件，包括配置管理、名字服务、分布式锁、集群</summary>
      
    
    
    
    <category term="系统设计" scheme="https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="system design" scheme="https://hideincode.github.io/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://hideincode.github.io/2021/10/24/system/Mysql/"/>
    <id>https://hideincode.github.io/2021/10/24/system/Mysql/</id>
    <published>2021-10-23T16:00:00.000Z</published>
    <updated>2024-05-07T08:56:17.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><blockquote><p>伟大滴麦色可友，养活互联网企业的神器。</p></blockquote><h2 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul><li>server层<ul><li>连接器：管理链接，权限验证</li><li>查询缓存：命中直接返回</li><li>分析器：词法分析，语法分析</li><li>优化器：执行计划生成，索引选择</li><li>执行器：操作引擎，返回结果</li></ul></li><li>引擎层：操作引擎，返回结果。</li></ul><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo-log"></a>redo-log</h3><ul><li>WAL：Write-Ahead Logging</li><li>crash-safe</li><li>innodb</li><li>物理日志：在数据页上做的修改</li><li>循环写</li></ul><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin-log"></a>bin-log</h3><ul><li>server层，意味着所有引擎可以用</li><li>逻辑日志：语句原始逻辑，给ID&#x3D;2的字段c加1</li><li>追加写</li></ul><h3 id="两段式提交"><a href="#两段式提交" class="headerlink" title="两段式提交"></a>两段式提交</h3><ol><li>redolog进入prepare </li><li>写入binlog</li><li>提交事务</li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ul><li><p>为什么选B+树？</p><ul><li>选了B+而不用B树，是因为B树在每个节点都存储数据，而B+树只会在叶子节点存储数据，所以B树IO会更频繁；数据库的索引是存在磁盘上的，当数据量大时，就不能全部加载到内存，只能逐一加载。</li></ul></li><li><p>基于B树实现，具有B树的平衡性；</p></li><li></li></ul><h3 id="索引特性"><a href="#索引特性" class="headerlink" title="索引特性"></a>索引特性</h3><ul><li>回表</li><li>索引覆盖</li><li>最左前缀原则</li><li>索引下推</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ol><li><p>原子性(Atomicity)</p><p>事务的所有操作只有成功和失败,操作期间不会去对数据库数据进行增删改操作,只记录操作,只有commit后才会去修改数据库的数据.事务失败就会rollback,数据不会有任何变化.</p></li><li><p>一致性（Consistency）</p><p>会话的双方要同时进行的DML操作,使得事务执行后数据库从一个一致性状态变到另一个一致性状态.</p></li><li><p>隔离性（Isolation）</p><p>事务之间是相互独立的两个对象,可以设置不同的隔离级别.</p></li><li><p>持久性（Durability）</p><p>事务终结的标志,提交后的事务将会永久性改变数据库的数据.</p></li></ol><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol><li><p>read uncommitted -&gt;脏读</p><blockquote><p>这种隔离级别下 两个事务A B,A 没有提交数据 ,B 读到了A没有commit的数据(事务A正在操作的数据),这种数据叫做dirty data,这种行为叫做dirty read,一般只在理论上存在;</p></blockquote></li><li><p>read committed -&gt; 不可重复度</p><blockquote><p>两个事务A B,A提交数据,B就读到A的数据,这种隔离级别的缺点就是不可重复度,即会话双方一方修改,一方读取,总是读取不到正确数据.<br>不可重复读的重点是修改.</p></blockquote></li><li><p>repeatable read -&gt; 幻读</p><blockquote><p>看这名字就知道就是来解决无法重复读的问题的.事务A开始时,不管事务BCD修改数据还是提交事务,都不会改变A读取的数据.<br>幻读:幻读是指当事务不是独立执行时发生的一种现象.事务A读取与搜索条件相匹配的若干行。<br>事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。这时候事务A的用户发现表中还存在没有修改的数据行,就像出现了幻觉一样.</p></blockquote></li><li><p>serializable -&gt; 效率低</p><blockquote><p>不会出现上述问题,但由于进行了锁表操作,所以会降低吞吐量.<br>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表.</p></blockquote></li></ol><p></p><h3 id="隔离的原理"><a href="#隔离的原理" class="headerlink" title="隔离的原理"></a>隔离的原理</h3><p>多版本并发控制MVCC</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><ul><li>一般全库逻辑备份时会用到</li><li>FlushTablesWithReadLock：库进入只读，阻塞DML，DDL，未提交的更新事务。故障时会释放锁。</li><li>set global readlonly&#x3D;true：用于主备库判断，故障时数据库不会释放锁。</li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul><li>lock tables … read&#x2F;write 客户端断开自动释放</li><li>元数据锁：metadata lock：访问表时自动开启，修改表结构时加MDL锁；</li><li>给小表安全加字段：<ul><li>kill长事务</li><li>alter table语句加等待时间，过期放弃。</li></ul></li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul><li>innodb特有</li><li>死锁与死锁检测：<ul><li>循环依赖导致</li><li>等到超时：innodb_lock_wait_timeout</li><li>主动检测：innodb_deadlock_detect&#x3D;on，缺点影响性能。</li><li>减小主动检测的性能影响：<ul><li>控制并发度，一行只能十个线程，但是客户端过多还是不行。</li><li>设计层面优化，把记录拆分多条，然后算多个记录的和。</li></ul></li></ul></li></ul><h2 id="常见表结构设计"><a href="#常见表结构设计" class="headerlink" title="常见表结构设计"></a>常见表结构设计</h2><h3 id="表设计三大范式"><a href="#表设计三大范式" class="headerlink" title="表设计三大范式"></a>表设计三大范式</h3><blockquote><p>范式只是一种参考，实际生产要考虑索引问题、联表查询效率问题。</p></blockquote><ol><li><p>列不可分</p><ul><li>一列不可有两种属性</li><li>比如地址可分为省、市、区三个字段</li></ul></li><li><p>在范式1的基础上，所有的非主键字段要<strong>完全依赖</strong>主键，不是依赖主键的某一部分（针对联合主键）</p><ul><li><p>出现了<strong>多对多</strong>关系</p></li><li><p>例如一张表存学生和课程</p><ul><li>新增一个学生，该学生还没有选课，因此就不能新增。新增老师同理。</li></ul></li><li><p>一个表只描述一件事情</p></li></ul></li><li><p>在范式2基础上，所有非主键字段和主键字段<strong>没有传递依赖</strong></p><ul><li>出现<strong>一对多</strong>关系</li><li>例如一张表存老师和学生<ul><li>修改老师职称时要改很多数据（修改一影响多）</li><li>没人选该老师课程时，该老师职称记录会被删除。（多没了代表了一也没了，不合理）</li><li>新老师还没指定职称，那么职称不知如何保存。</li></ul></li><li>一对多出现时考虑：一和多分成两张表，多表存一表主键，</li></ul></li></ol><h2 id="SQL命令使用常识"><a href="#SQL命令使用常识" class="headerlink" title="SQL命令使用常识"></a>SQL命令使用常识</h2><ul><li>count：count(字段)&lt;count(id)&lt;count(1)约等count(*)</li><li>order by：<ul><li>sort_buffer_size：排序内存大小，如果太小就利用临时文件排序。</li><li>rowid排序：如果要返回字段过多，只取出排序字段。</li><li>如果内存够，就用内存排序。</li></ul></li><li>join:<ul><li>正确选择驱动表，驱动表走全表扫描，被驱动表走数索引。</li><li>使用join语句，性能比强行拆成多个单表执行SQL语句的性能好。</li><li>如果使用join，需要使用小表做驱动。</li></ul></li></ul><h2 id="常见疑难杂症"><a href="#常见疑难杂症" class="headerlink" title="常见疑难杂症"></a>常见疑难杂症</h2><ul><li><p>普通索引和唯一索引怎么选？</p><ul><li><p>读：区别不大</p></li><li><p>写：</p><ul><li>change buffer：缓存更新操作，唯一索引不能用，只有普通索引可以用。如果更新后马上查询，不要用这个。redolog节省随机写磁盘的io消耗，changebuffer节省对应读的io消耗。</li><li>唯一索引：判断冲突</li><li>普通索引：更新记录在changebuffer</li></ul></li></ul></li><li><p>怎么给字符串加索引？</p></li><li><p>mysql为什么会抖一下？</p><ul><li>内存脏页：内存数据和磁盘数据不一样时，内存页就是脏页。</li></ul></li><li><p>为什么表数据删除一半，表文件大小不变？</p><ul><li>delete结果不会变，alter table才会改变。</li></ul></li><li><p>为什么逻辑相同的语句，性能缺差异巨大？</p><ul><li><p>条件字段函数操作</p></li><li><p>隐式类型转换</p></li><li><p>隐式字符编码转换</p></li></ul></li><li><p>查一行也很慢？</p><ul><li>查询长时间不返回：锁表了，通过show processlist查看状态。</li><li>等DML锁：show processlist查看wait for table metadata lock</li><li>等flush</li></ul></li><li><p>幻读有什么问题吗？</p></li><li><p>鸩止渴的提高性能？</p><ul><li><p>先处理占着链接但是不工作的线程</p></li><li><p>减少链接过程的消耗</p></li><li><p>慢查询性能问题</p><ul><li>索引没有设计好</li><li>语句没写好</li></ul></li><li><p>QPS突增问题</p></li></ul></li><li><p>如何保证数据不丢？</p><ul><li><p>binglog写入机制</p></li><li><p>redolog写入机制</p></li></ul></li><li><p>保证主备一致？</p></li><li><p>涉及到binlog可选</p><ul><li>statement</li><li>row</li><li>mixed</li></ul></li><li><p>怎么保证高可用？</p><ul><li><p>主备延迟</p><ul><li><p>备库机器差劲</p></li><li><p>备库压力大</p></li><li><p>大事务</p></li></ul></li><li><p>可靠性优先策略</p></li></ul></li><li><p>备库为什么会延迟几个小时？</p><ol><li><p>5.5版本并行复制策略</p><ol><li>按表分发</li><li>按行分发</li></ol></li><li><p>5.7并行复制策略</p></li><li><p>5.7.22并行复制策略</p></li></ol></li><li><p>主库出问题，从库怎么办？</p><ol><li><p>基于位点的主备切换</p></li><li><p>基于GTID的主备切换</p></li></ol></li><li><p>读写分离有哪些坑？</p></li></ul><ol><li>主备延迟导致的读写分离<ol><li>强制走主库</li><li>sleep</li><li>判断主备无延迟<ol><li>通过seconds_behind_master</li><li>位点比对</li><li>GTID</li></ol></li><li>semi-sync半同步复制</li></ol></li></ol><ul><li><p>判断数据库是不是出问题？</p><ol><li><p>select 1</p></li><li><p>查表判断</p></li><li><p>更新判断</p></li><li><p>内部统计</p></li></ol></li><li><p>误删数据怎么办？</p><ol><li><p>删除行</p></li><li><p>删除库&#x2F;表</p></li></ol></li><li><p>为什么有些命令kill不掉？</p><ol><li><p>kill query + 线程id</p></li><li><p>kill connection + 线程id</p></li><li><p>关于客户端的误解：表多就慢</p></li></ol></li><li><p>查大量数据会不会打爆内存？</p><ol><li><p>全表扫描对server层影响：先装net_buffer，满了就输出，边读边发。</p></li><li><p>全表扫描对innodb的影响</p></li></ol></li><li><p>为什么临时表可以重名？</p><ol><li><p>create temporary table 创建临时表</p></li><li><p>创建的临时表只能被当前session访问</p></li><li><p>可以与普通表重名，优先访问临时表，show tables不显示临时表。</p></li></ol></li><li><p>何时会用到临时表？</p><ol><li><p>union执行流程</p></li><li><p>group by</p></li></ol></li><li><p>innodb虽然厉害，那么memory还用不用？</p><ol><li><p>innodb索引组织表</p><ol><li>有序存放</li><li>有空位也会写入新位置</li><li>数据位置变化只要修改主键索引</li><li>通过主键就一次，普通索引要两次</li></ol></li><li><p>memory堆组织表</p><ol><li>按照写入顺序存放<ol><li>有空位就插入</li><li>位置变化要修改所有索引</li><li>查找时一视同仁</li></ol></li></ol></li></ol></li><li><p>怎么快速复制一张表？</p><ol><li><p>sqldump方法：生成包含insert语句的方法，可以在where参数里面加过滤，不能join</p></li><li><p>导出csv</p></li><li><p>物理拷贝：最快、必须全表拷贝、需要到机器上拷贝，在用户登录数据库的场景下无法使用，都得是innodb</p></li></ol></li><li><p>grant之后要跟着flushprivileges吗？</p></li><li><p>要不要分区分表？</p></li><li><p>自增ID用完怎么办？</p><ol><li><p>表定义自增id：用完会冲突，可以增加范围biginit unsigned。</p><ol><li><p>innodb系统自增row_id：</p><ol><li>不显示指定主键时，系统隐式自带。</li><li>用完就会重零开始覆盖</li></ol></li><li><p>xid</p><ol><li>作用于事务：这是redo log和binglog配合使用的id</li><li>不要在binlog重复</li></ol></li></ol></li><li><p>innodb trx_id：每次随着mysql重启会被保存起来。</p></li><li><p>thread_id</p></li></ol></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>初始化SQL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists dept;</span><br><span class="line">drop table if exists salgrade;</span><br><span class="line">drop table if exists emp; </span><br><span class="line">create table dept(</span><br><span class="line">    deptno int(10) primary key,</span><br><span class="line">    dname varchar(14),</span><br><span class="line">    loc varchar(13)</span><br><span class="line">);</span><br><span class="line">create table salgrade(</span><br><span class="line">    grade int(11),</span><br><span class="line">    losal int(11),</span><br><span class="line">    hisal int(11)</span><br><span class="line">);</span><br><span class="line">create table emp(</span><br><span class="line">    empno int(4) primary key,</span><br><span class="line">    ename varchar(10),</span><br><span class="line">    job varchar(9),</span><br><span class="line">    mgr int(4),</span><br><span class="line">    hiredate date,</span><br><span class="line">    sal double(7,2),</span><br><span class="line">    comm double(7,2),</span><br><span class="line">    deptno int(2)</span><br><span class="line">);</span><br><span class="line">insert into dept(deptno,dname,loc) values(10,&#x27;ACCOUNTING&#x27;,&#x27;NEW YORK&#x27;);</span><br><span class="line">insert into dept(deptno,dname,loc) values(20,&#x27;RESEARCHING&#x27;,&#x27;DALLAS&#x27;);</span><br><span class="line">insert into dept(deptno,dname,loc) values(30,&#x27;SALES&#x27;,&#x27;CHICAGO&#x27;);</span><br><span class="line">insert into dept(deptno,dname,loc) values(40,&#x27;OPERATIONS&#x27;,&#x27;BOSTON&#x27;); </span><br><span class="line"></span><br><span class="line">insert into salgrade(grade,losal,hisal) values(1,700,1200);</span><br><span class="line">insert into salgrade(grade,losal,hisal) values(2,1201,1400);</span><br><span class="line">insert into salgrade(grade,losal,hisal) values(3,1401,2000);</span><br><span class="line">insert into salgrade(grade,losal,hisal) values(4,2001,3000);</span><br><span class="line">insert into salgrade(grade,losal,hisal) values(5,3001,5000); </span><br><span class="line"></span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7369,&#x27;SIMITH&#x27;,&#x27;CLERK&#x27;,7902,&#x27;1980-12-17&#x27;,800,null,20);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7499,&#x27;ALLEN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-02-20&#x27;,1600,300,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7521,&#x27;WARD&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-02-22&#x27;,1250,500,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7566,&#x27;JONES&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-04-02&#x27;,2975,null,20);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7654,&#x27;MARTIN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-09-28&#x27;,1250,1400,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7698,&#x27;BLAKE&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-05-01&#x27;,2850,null,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7782,&#x27;CLARK&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-06-09&#x27;,2450,null,10);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7788,&#x27;SCOTT&#x27;,&#x27;ANALYST&#x27;,7566,&#x27;1987-04-19&#x27;,3000,null,20);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7839,&#x27;KING&#x27;,&#x27;PRESIDENT&#x27;,null,&#x27;1981-11-17&#x27;,5000,null,10);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7844,&#x27;TURNER&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-09-08&#x27;,1500,null,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7876,&#x27;ADAMS&#x27;,&#x27;CLERK&#x27;,7788,&#x27;1987-05-23&#x27;,1100,null,20);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7900,&#x27;JAMES&#x27;,&#x27;CLERK&#x27;,7698,&#x27;1981-12-03&#x27;,950,null,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7902,&#x27;FORD&#x27;,&#x27;ANALYST&#x27;,7566,&#x27;1981-12-03&#x27;,3000,null,20);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7934,&#x27;MILLER&#x27;,&#x27;CLERK&#x27;,7782,&#x27;1982-01-23&#x27;,1300,null,10);</span><br></pre></td></tr></table></figure><ol><li><p>每个部门薪水最高的人员名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.ename NAME,</span><br><span class="line">t.maxsal,</span><br><span class="line">d.dname deptname </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">JOIN ( SELECT deptno, max( sal ) maxsal FROM emp GROUP BY deptno ) t ON t.deptno = e.deptno </span><br><span class="line">AND t.maxsal = e.sal</span><br><span class="line">JOIN dept d ON t.deptno = d.deptno;</span><br></pre></td></tr></table></figure></li><li><p>薪水在部门平均水平以上的人</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">e.ename name,e.deptno,e.sal</span><br><span class="line">from </span><br><span class="line">emp e join (select deptno,avg(sal) avgsal from emp group by deptno) t </span><br><span class="line">on e.sal &gt; t.avgsal and t.deptno=e.deptno;</span><br></pre></td></tr></table></figure></li><li><p>取得部门中的平均薪水等级(所有人)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">t.deptno deptno,s.grade grade </span><br><span class="line">from </span><br><span class="line">(select deptno, avg(sal) avgsal from emp group by deptno) t join salgrade s on t.avgsal between losal and hisal;</span><br></pre></td></tr></table></figure></li><li><p>取得部门中所有人的薪水等级,并对部门薪水等级求平均</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t.dept, avg(t.grade) avg_grade from (select e.deptno dept,e.ename name,e.sal salary,s.grade grade from emp e join salgrade s on e.sal between s.losal and hisal) t group by t.dept;</span><br></pre></td></tr></table></figure><p>也可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.deptno dept,avg(s.grade) from emp e join salgrade s on e.sal between s.losal and hisal group by e.deptno;</span><br></pre></td></tr></table></figure></li><li><p>不用聚合函数max,取得最高薪水,使用两种方法解决</p><ol><li><code>select ename,sal from emp order by sal desc limit 1;</code></li><li><code>select sal from emp where sal not in (select distinct a.sal sal_a from emp a join emp b on a.sal &lt; b.sal);</code></li></ol></li><li><p>取得平均薪水最高的部门的部门编号(2种方案)</p><blockquote><p>可能有相等数据,取第一个可能会错误,所以要根据deptno找到重复的max</p></blockquote><ol><li><pre><code class="mysql">select     deptno,avg(sal) as avgsalfrom     emp group by     deptnohaving     avg(sal) = (select avg(sal) avgsal from emp group by deptno order by avgsal desc limit 1);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 聚合函数max</span><br><span class="line"></span><br><span class="line">   ```mysql</span><br><span class="line">   select </span><br><span class="line">   deptno,avg(sal) avgsal</span><br><span class="line">   from </span><br><span class="line">   emp</span><br><span class="line">   group by </span><br><span class="line">   deptno</span><br><span class="line">   having</span><br><span class="line">   avg(sal) = (select max(t.avgsal) from (select deptno,avg(sal) avgsal from emp group by deptno ) t);</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p>取得平均薪水最高的部门的部门名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">d.dname,m.avgsal</span><br><span class="line">from</span><br><span class="line">dept d</span><br><span class="line">join </span><br><span class="line">(select </span><br><span class="line">deptno,avg(sal) avgsal</span><br><span class="line">from </span><br><span class="line">emp</span><br><span class="line">group by </span><br><span class="line">deptno</span><br><span class="line">having</span><br><span class="line">avg(sal) = (select max(t.avgsal) from (select deptno,avg(sal) avgsal from emp group by deptno ) t)) m</span><br><span class="line">on m.deptno=d.deptno;</span><br></pre></td></tr></table></figure></li><li><p>求平均薪水的等级最高的部门名称</p></li><li><p>求各个部门平均薪水的等级(结果只有部门名称.平均薪水,等级三个字段)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select t.avgsal,s.grade,t.dname from </span><br><span class="line">(select d.dname dname,avg(e.sal) avgsal from emp e join dept d on e.deptno=d.deptno group by dname) t</span><br><span class="line">join salgrade s</span><br><span class="line">on t.avgsal between s.losal and s.hisal;</span><br></pre></td></tr></table></figure></li><li><p>获取最高等级值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select max(s.grade) from </span><br><span class="line">(select deptno,avg(sal) avgsal from emp group by deptno) t</span><br><span class="line">join salgrade s</span><br><span class="line">on t.avgsal between s.losal and s.hisal;</span><br></pre></td></tr></table></figure></li><li><p>联合上两张表 给出avgsal,dname,grade,满足平均值为最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select t.avgsal,s.grade,t.dname from </span><br><span class="line">(select d.dname dname,avg(e.sal) avgsal from emp e join dept d on e.deptno=d.deptno group by dname) t</span><br><span class="line">join salgrade s</span><br><span class="line">on t.avgsal between s.losal and s.hisal</span><br><span class="line">where</span><br><span class="line">s.grade=(select max(s.grade) from </span><br><span class="line">(select deptno,avg(sal) avgsal from emp group by deptno) t</span><br><span class="line">join salgrade s</span><br><span class="line">on t.avgsal between s.losal and s.hisal);</span><br></pre></td></tr></table></figure></li><li><p>取得比<strong>普通员工</strong>(员工代码没有在mgr字段上出现的)的<strong>最高薪水</strong>还要高的姓名</p><ol><li><p>先找到普通员工(注意not in (不能有null))<br><code>select * from emp where empno  not in (select distinct mgr from emp where mgr is not null);</code></p><pre><code>     2. 找出普通员工最高薪水</code></pre><p><code>select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null);</code></p></li><li><p>找出薪水高于1600</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ename ,sal from emp </span><br><span class="line">where sal &gt; (select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null));</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>​补充学习: <code>select ename,sal,(case job when &#39;manager&#39; then sal * 0.8 when &#39;salesman&#39; then sal*1.5 end) newsal from emp;</code></p><ol start="9"><li><p>取得薪水最高的前五</p></li><li><p>取得薪水最高的第六名到第十名</p></li><li><p>取得最后入职的5名员工</p></li><li><p>取得每个薪水等级有多少个员工</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select e.ename, e.sal, s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;</span><br><span class="line">select t.sgrade ,count(*) from (select e.ename, e.sal, s.grade sgrade from emp e join salgrade s on e.sal between s.losal and s.hisal) t group by t.sgrade;</span><br><span class="line">select count(*), s.grade </span><br><span class="line">from emp e join salgrade s on e.sal between s.losal and s.hisal</span><br><span class="line">group by s.grade;</span><br></pre></td></tr></table></figure></li><li><p>列出所有员工和领导的名字<br> 列出所有的领导,not in 领导就是员工(自连接)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select distinct a.empno,a.ename,b.mgr from emp a join emp b on a.empno =b.mgr;-- 所有的领导</span><br><span class="line">select ename from emp where ename not in (select distinct a.ename from emp a join emp b on a.empno =b.mgr);</span><br></pre></td></tr></table></figure></li><li><p>找出入职日期早于其直接领导的员工编号,姓名,部门名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">t.adno,</span><br><span class="line">t.aname,</span><br><span class="line">d.dname </span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">              SELECT</span><br><span class="line">              a.empno eno,</span><br><span class="line">              a.ename aname,</span><br><span class="line">              a.hiredate ahdate,</span><br><span class="line">              a.deptno adno,</span><br><span class="line">              b.hiredate bhdate </span><br><span class="line">              FROM</span><br><span class="line">              emp a</span><br><span class="line">              LEFT JOIN emp b ON a.mgr = b.empno </span><br><span class="line">          ) t</span><br><span class="line">JOIN dept d ON d.deptno = t.adno </span><br><span class="line">WHERE</span><br><span class="line">t.ahdate &lt; t.bhdate</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 老司机做法选出员工直接老板和各自的入职日期,通过where筛选</span><br><span class="line">select a.empno aempno, a.ename aename,d.dname ddname, b.empno bempno, b.ename bename</span><br><span class="line">from emp a join emp b on a.mgr = b.empno join dept d on d.deptno = a.deptno</span><br><span class="line">where a.hiredate&lt;b.hiredate;</span><br></pre></td></tr></table></figure></li><li><p>列出部门名称和这些部门员工信息,同时列出没有员工的部门<br><code>select d.dname,e.* from emp e right join dept d on e.deptno=d.deptno order by d.dname asc;</code></p></li><li><p>列出至少有5个员工的所有部门(什么这里select后可以有groupby没有的东西)<br><code>select dept.*,emp.deptno,count(*) from emp join dept on emp.deptno = dept.deptno group by dept.deptno having count(*) &gt;=5;</code></p></li><li><p>列出薪资比simith高的员工的个人信息<br><code>select * from emp where sal &gt; (select sal from emp where ename=&#39;simith&#39;);</code></p></li><li><p>列出所有clerk职位的员工姓名,部门名称,部门人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.ename ename,d.dname ddname, t.countall from emp e join dept d on d.deptno = e.deptno join (select e.deptno, count(*) countall from  emp e  group by e.deptno) t on t.deptno = d.deptno</span><br><span class="line">where job=&#x27;clerk&#x27; ;</span><br><span class="line">select e.deptno, count(*) countall from  emp e group by e.deptno;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>列出最低薪资大于1500的各工种及从事此工作的全部员工人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select job,min(sal) minsal,count(*) from emp group by job having minsal &gt;1500;</span><br></pre></td></tr></table></figure></li><li><p>在不知道部门编号的情况下列出sales部门的员工姓名<br> 这题又理解错误,emp的deptno是知道的,只有dept表中deptno不知道</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select deptno from dept where dname=&#x27;sales&#x27;;</span><br><span class="line">select ename from emp where deptno = ( select deptno from dept where dname=&#x27;sales&#x27;);</span><br></pre></td></tr></table></figure><ol start="21"><li><p>列出薪资高于公司平均薪资的所有员工,所在部门,上级领导,员工的工资等级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 注意用全连接找出king的信息</span><br><span class="line">SELECT</span><br><span class="line">e.mgr,</span><br><span class="line">e.ename,</span><br><span class="line">e.deptno,</span><br><span class="line">e2.ename boss,</span><br><span class="line">d.dname,</span><br><span class="line">s.grade </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">LEFT JOIN emp e2 ON e.mgr = e2.empno</span><br><span class="line">JOIN dept d ON d.deptno = e.deptno</span><br><span class="line">JOIN salgrade s ON e.sal BETWEEN s.losal </span><br><span class="line">AND s.hisal </span><br><span class="line">WHERE</span><br><span class="line">e.sal &gt; ( SELECT avg( sal ) FROM emp );</span><br></pre></td></tr></table></figure></li><li><p>列出与scott从事相同工作的所有员工及其部门名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">job </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">ename = &#x27;scott&#x27;;</span><br><span class="line">SELECT</span><br><span class="line">e.ename,</span><br><span class="line">d.dname,</span><br><span class="line">e.job </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">JOIN dept d ON e.deptno = d.deptno </span><br><span class="line">WHERE</span><br><span class="line">job = ( SELECT job FROM emp WHERE ename = &#x27;scott&#x27; );</span><br></pre></td></tr></table></figure></li><li><p>列出薪资等于部门30中员工的薪资的其他员工的姓名和薪金</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">sal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">deptno = 30;</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">ename,</span><br><span class="line">sal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">( sal IN ( SELECT DISTINCT sal FROM emp WHERE deptno = 30 ) ) AND deptno &lt;&gt; 30;</span><br></pre></td></tr></table></figure></li><li><p>列出薪资高于部门30中员工的薪资的其他员工的姓名和薪金</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">ename,</span><br><span class="line">sal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">sal &gt; ( SELECT max( t.sal ) FROM ( SELECT DISTINCT sal FROM emp WHERE deptno = 30 ) t );</span><br></pre></td></tr></table></figure><ol start="25"><li>列出在每个部门工作的员工数量,平均工资和平均服务期限(工龄)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 所有、每个这类关键字，一般需要全连接</span><br><span class="line">SELECT</span><br><span class="line">e.deptno,</span><br><span class="line">count( e.ename ) totalmember,</span><br><span class="line">IFNULL(avg( sal ) ,0) avgsal,</span><br><span class="line">IFNULL(avg(( ( TO_DAYS( now( ) ) - TO_DAYS( hiredate ) ) / 356 )),0) year</span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">RIGHT JOIN dept d ON e.deptno = d.deptno </span><br><span class="line">GROUP BY</span><br><span class="line">deptno;</span><br></pre></td></tr></table></figure><ol start="26"><li><p>列出所有员工的姓名,部门名称,工资<br><code>select e.ename,d.dname,e.sal from emp e join dept d on e.deptno=d.deptno;</code></p></li><li><p>列出所有部门的详细信息和人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d.deptno,d.dnae,d.loc,count(e.ename) from emp e right join dept d on e.deptno=d.deptno group by d.deptno,d.dname,d.loc;</span><br></pre></td></tr></table></figure></li><li><p>列出各个工作岗位最低工资和符合最低工资的人姓名<br>(判空与去重)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">t.job,</span><br><span class="line">e.ename,</span><br><span class="line">t.minsal </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">JOIN ( SELECT job, min( sal ) minsal FROM emp GROUP BY job ) t ON e.job = t.job </span><br><span class="line">AND e.sal = t.minsal </span><br><span class="line">ORDER BY</span><br><span class="line">t.minsal ASC;</span><br></pre></td></tr></table></figure></li><li><p>获取各个部门mgr的最低薪资</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">deptno,</span><br><span class="line">min( sal ) minsal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">where</span><br><span class="line">job=&#x27;manager&#x27;</span><br><span class="line">GROUP BY</span><br><span class="line">deptno;</span><br></pre></td></tr></table></figure><ol start="30"><li><p>取出所有员工年薪,由低到高排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">ename,</span><br><span class="line">sal * 12+ ifnull( comm, 0 ) yearsal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">ORDER BY</span><br><span class="line">yearsal ASC;</span><br></pre></td></tr></table></figure></li><li><p>取出员工领导薪水超过3000的员工名称和领导名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.ename,</span><br><span class="line">e2.ename leader</span><br><span class="line">FROM</span><br><span class="line">emp e JOIN emp e2 ON e.mgr = e2.empno AND e2.sal &gt; 3000;</span><br></pre></td></tr></table></figure></li><li><p>取出含有s的部门,给出此部门的工资合计,部门人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">d.dname empname,</span><br><span class="line">count( e.ename ) totalpersons,</span><br><span class="line">SUM( ifnull( e.sal, 0 ) ) sumsal </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">RIGHT JOIN dept d ON e.deptno = d.deptno </span><br><span class="line">WHERE</span><br><span class="line">d.dname LIKE &#x27;%s%&#x27; </span><br><span class="line">GROUP BY</span><br><span class="line">d.dname;</span><br></pre></td></tr></table></figure></li><li><p>给任职超过30年的人加薪10%;<br>工作时间计算公式(年)<br>(( TO_DAYS( now( ) ) - TO_DAYS( hiredate ) ) &#x2F; 365 ) year</p></li></ol><p>create table emp_bak as select * from emp;</p><ol start="34"><li>面试一下</li></ol><p><strong>初始化数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists s;</span><br><span class="line">drop table if exists c;</span><br><span class="line">drop table if exists sc; </span><br><span class="line">create table s(</span><br><span class="line">    sno int(10) primary key,</span><br><span class="line">    sname varchar(14)</span><br><span class="line">);</span><br><span class="line">create table c(</span><br><span class="line">    cno int(10) primary key,</span><br><span class="line">    cname varchar(14),</span><br><span class="line">    cteacher varchar(14)</span><br><span class="line">);</span><br><span class="line">create table sc(</span><br><span class="line">    sno int(10),  </span><br><span class="line">    cno int(10),</span><br><span class="line">    scgrade int(10),</span><br><span class="line">    primary key(sno,cno)</span><br><span class="line">);</span><br><span class="line">insert into s(sno,sname) values(1,&#x27;a&#x27;);</span><br><span class="line">insert into s(sno,sname) values(2,&#x27;b&#x27;);</span><br><span class="line">insert into s(sno,sname) values(3,&#x27;c&#x27;);</span><br><span class="line">insert into s(sno,sname) values(4,&#x27;d&#x27;); </span><br><span class="line"></span><br><span class="line">insert into c(cno,cname,cteacher) values(1,&#x27;java&#x27;,&#x27;王老师&#x27;);</span><br><span class="line">insert into c(cno,cname,cteacher) values(2,&#x27;C++&#x27;,&#x27;张老师&#x27;);</span><br><span class="line">insert into c(cno,cname,cteacher) values(3,&#x27;C#&#x27;,&#x27;李老师&#x27;);</span><br><span class="line">insert into c(cno,cname,cteacher) values(4,&#x27;mysql&#x27;,&#x27;周老师&#x27;);</span><br><span class="line">insert into c(cno,cname,cteacher) values(5,&#x27;oracle&#x27;,&#x27;黎明&#x27;); </span><br><span class="line"></span><br><span class="line">insert into sc(sno,cno,scgrade) values(1,1,50);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(1,2,50);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(1,3,50);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(2,2,80);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(2,3,70);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(2,4,59);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(3,1,60);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(3,2,61);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(3,3,99);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(3,4,100);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(3,5,52);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(4,3,82);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(4,4,99);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(4,5,40);</span><br></pre></td></tr></table></figure><blockquote><p>有3个表s(学生表),c(课程表),sc(学生选课表)<br>s(sno,sname) 代表 (学号,姓名)<br>c(cno,cname,cteacher) 代表(课号,课名,教师)<br>sc(sno,cno,scgrade)代表 (学号,课号,成绩)</p></blockquote><ol><li><p>找出没选过”黎明”老师的所有学生姓名<br>1. 肯定要用补集求解,所以先求黎明苏所在表的相关信息<br>select cno,cname from c where cteacher&#x3D;’黎明’;<br>2. 选了黎明的人<br>select sno from sc where cno &#x3D; (select cno from c where cteacher&#x3D;’黎明’);<br> 3. 没选黎明的人<br> select sname from s where sno not in (select sno from sc where cno &#x3D; (select cno from c where cteacher&#x3D;’黎明’))</p></li><li><p>列出2门以上(含2门) 不及格学生姓名及他的所有成绩的平均成绩<br> 1. 先选出2门不及格的学生<br><br> <code>    select sno from sc where scgrade &lt; 60 group by sno having count(*)&gt;=2 ;</code><br><br> 2. 连接s取姓名<br><br> <code>select s.sname from sc join s on sc.sno = s.sno where sc.scgrade &lt; 60 group by s.sname having count(*)&gt;=2 ;</code><br><br> 3. 算出每个学生的平均成绩跟不及格的姓名连接(下面这个做法不行,因为其他成绩已经过滤掉了,只会求不及格成绩的平均线)<br>   <code>select s.sname name, avg(sc.scgrade) avgscore from sc join s on sc.sno = s.sno where sc.scgrade &lt; 60 group by s.sname having count(*)&gt;=2 ;</code></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 求出所有学生平均成绩</span><br><span class="line">select sc.sno,avg(sc.scgrade) avgscore from sc group  by sc.sno;</span><br><span class="line">select sno,avg(sc.scgrade) avgscore from sc group  by sno;</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">t1.NAME NAME,</span><br><span class="line">t2.avgscore avgscore </span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">s.sname NAME,</span><br><span class="line">s.sno sno </span><br><span class="line">FROM</span><br><span class="line">sc</span><br><span class="line">JOIN s ON sc.sno = s.sno </span><br><span class="line">WHERE</span><br><span class="line">sc.scgrade &lt; 60 GROUP BY NAME, sno HAVING count( * ) &gt;= 2 </span><br><span class="line">) t1</span><br><span class="line">JOIN ( SELECT sc.sno sno, avg( sc.scgrade ) avgscore FROM sc GROUP BY sc.sno ) t2 ON t1.sno = t2.sno </span><br><span class="line">GROUP BY</span><br><span class="line">t1.sno;</span><br></pre></td></tr></table></figure><ol start="3"><li>即学过1号课程又学过2号课程所有学生的姓名<br>1. 学过1号课程的所有学生(sname,cno)<br><code>select s.sname sname,sc.cno cno from sc join s on s.sno=sc.sno where cno = 1;</code><br>2. 学过2号课程的所有学生(sname,cno)<br><code>select s.sname sname,sc.cno cno from sc join s on s.sno=sc.sno where cno=2;</code><br>3. 求交集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select t1.sname sname from (select s.sname sname,sc.cno cno from sc </span><br><span class="line">join s on s.sno=sc.sno where cno = 1) t1 </span><br><span class="line">join (select s.sname sname,sc.cno cno from sc join s on s.sno=sc.sno where cno=2) t2 on t1.sname = t2.sname;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br><strong>作业到此完成,所有的问题都可分成小问题来拼出来,这个过程中除了注意sql的语法,mysql的特殊语法,还要考虑判空,去重,是否要全连接等.</strong><br><strong>查询数据的思路</strong></p><ol><li>我需要哪些字段?这些字段分别在那些表里?这些表靠什么连接?</li><li>涉及多表字段(自连接也算) 要先分开查询,查询时要注意判空与去重,以及选用合适的过滤方法和分组函数.</li><li>连接时选用内还是外连接,是要用增加查询字段,进行子查询,还是表连接要先后判断一下.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;伟大滴麦色可友，养活互联网企业的神器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="系统设计" scheme="https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="system design" scheme="https://hideincode.github.io/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://hideincode.github.io/2021/07/05/system/Spring/"/>
    <id>https://hideincode.github.io/2021/07/05/system/Spring/</id>
    <published>2021-07-04T16:00:00.000Z</published>
    <updated>2024-05-07T08:57:21.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="为什么Spring"><a href="#为什么Spring" class="headerlink" title="为什么Spring?"></a>为什么Spring?</h2><ol><li>IOC进行松耦合与容器化管理对象，AOP进行业务和系统逻辑分开。</li><li>轻量，几兆而已。</li><li>事务处理能力：本地全局都可以进行统一事物管理。</li><li>异常处理：可以全局捕获运行时异常。</li><li>MVC进行web编程提高生产效率。</li></ol><h2 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h2><ol><li>切⾯（Aspect）：官⽅的抽象定义为“⼀个关注点的模块化，这个关注点可能会横切多个对象”。</li><li>连接点（Joinpoint）：程序执⾏过程中的某⼀⾏为。 </li><li>通知（Advice）：“切⾯”对于某个“连接点”所产⽣的动作。 </li><li>切⼊点（Pointcut）：匹配连接点的断⾔，在 AOP 中通知和⼀个切⼊点表达式关联。</li><li>⽬标对象（Target Object）：被⼀个或者多个切⾯所通知的对象。 </li><li>AOP 代理（AOP Proxy）：在 Spring AOP 中有两种代理⽅式，JDK 动态代理和 CGLIB 代理。</li></ol><h2 id="通知类型有哪些？"><a href="#通知类型有哪些？" class="headerlink" title="通知类型有哪些？"></a>通知类型有哪些？</h2><ol><li><p>前置通知（Before advice）：在某连接点（JoinPoint）之前执⾏的通知，但这个通知不能阻⽌连接点前的执 ⾏。ApplicationContext 中在 aop:aspect ⾥⾯使⽤ aop:before 元素进⾏声明； </p></li><li><p>后置通知（After advice）：当某连接点退出的时候执⾏的通知（不论是正常返回还是异常退出）。 ApplicationContext 中在 aop:aspect ⾥⾯使⽤ aop:after 元素进⾏声明。 </p></li><li><p>返回后通知（After return advice ：在某连接点正常完成后执⾏的通知，不包括抛出异常的情况。 ApplicationContext 中在 aop:aspect ⾥⾯使⽤ &lt;&gt; 元素进⾏声明。</p></li><li><p>环绕通知（Around advice）：包围⼀个连接点的通知，类似 Web 中 Servlet规范中的 Filter 的 doFilter ⽅ 法。可以在⽅法的调⽤前后完成⾃定义的⾏为，也可以选择不执⾏。ApplicationContext 中在 aop:aspect ⾥ ⾯使⽤ aop:around 元素进⾏声明。</p></li><li><p>抛出异常后通知（After throwing advice）：在⽅法抛出异常退出时执⾏的通知。ApplicationContext 中在 a op:aspect ⾥⾯使⽤ aop:after-throwing 元素进⾏声明</p></li></ol><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ol><li>Spring 启动，查找并加载需要被 Spring 管理的 Bean，进⾏ Bean 的实例化； </li><li>Bean 实例化后，对 Bean 的引⼊和值注⼊到 Bean 的属性中； </li><li>如果 Bean 实现了 BeanNameAware 接⼝的话，Spring 将 Bean 的 Id 传递给 setBeanName() ⽅法； </li><li>如果 Bean 实现了 BeanFactoryAware 接⼝的话，Spring 将调⽤ setBeanFactory() ⽅法，将 BeanFactory 容器实例传⼊； </li><li>如果 Bean 实现了 ApplicationContextAware 接⼝的话，Spring 将调⽤ Bean 的 setApplicationContext() ⽅ 法，将 Bean 所在应⽤上下⽂引⽤传⼊进来；</li><li>如果 Bean 实现了 BeanPostProcessor 接⼝，Spring 就将调⽤它们的 postProcessBeforeInitialization() ⽅ 法； </li><li>如果 Bean 实现了 InitializingBean 接⼝，Spring 将调⽤它们的 afterPropertiesSet() ⽅法。类似地，如果 Bean 使⽤ init-method 声明了初始化⽅法，该⽅法也会被调⽤； </li><li>如果 Bean 实现了 BeanPostProcessor 接⼝，Spring 就将调⽤它们的 postProcessAfterInitialization() ⽅ 法； </li><li>此时，Bean 已经准备就绪，可以被应⽤程序使⽤了。它们将⼀直驻留在应⽤上下⽂中，直到应⽤上下⽂被销 毁； </li><li>如果 Bean 实现了 DisposableBean 接⼝，Spring 将调⽤它的 destory() 接⼝⽅法，同样，如果 Bean 使⽤了 destory-method 声明销毁⽅法，该⽅法也会被调⽤。</li></ol><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><ol><li>singleton : 唯⼀ bean 实例，Spring 中的 bean 默认都是单例的； </li><li>prototype : 每次请求都会创建⼀个新的 bean 实例； </li><li>request：每⼀次 HTTP 请求都会产⽣⼀个新的 bean，该 bean 仅在当前 HTTP request 内有效； </li><li>session : 每⼀次 HTTP 请求都会产⽣⼀个新的 bean，该 bean 仅在当前 HTTP session 内有效； </li><li>global-session：全局 session 作⽤域，仅仅在基于 portlet 的 web 应⽤中才有意义，Spring5 已经没有了。 Portlet 是能够⽣成语义代码(例如：HTML)⽚段的⼩型 Java Web 插件。它们基于 portlet 容器，可以像 servlet ⼀样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ol><h2 id="Spring的事物隔离级别"><a href="#Spring的事物隔离级别" class="headerlink" title="Spring的事物隔离级别"></a>Spring的事物隔离级别</h2><p>TransactionDefinition 接⼝中定义了五个表示隔离级别的常量： <strong>TransactionDefinition.ISOLATION_DEFAULT</strong>：使⽤后端数据库默认的隔离级别，MySQL 默认采⽤的 REPEATABLE_READ 隔离级别 Oracle 默认采⽤的 READ_COMMITTED 隔离级别； TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可 能会导致脏读、幻读或不可᯿复读； <strong>TransactionDefinition.ISOLATION_READ_COMMITTED</strong>：允许读取并发事务已经提交的数据，可以阻⽌脏读，但 是幻读或不可᯿复读仍有可能发⽣； <strong>TransactionDefinition.ISOLATION_REPEATABLE_READ</strong>：对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被 本身事务⾃⼰所修改，可以阻⽌脏读和不可᯿复读，但幻读仍有可能发⽣； </p><p><strong>TransactionDefinition.ISOLATION_SERIALIZABLE</strong>：最⾼的隔离级别，完全服从 ACID 的隔离级别。所有的事务依 次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可᯿复读以及幻读。但是 这将严᯿影响程序的性能。通常情况下也不会⽤到该级别.</p><h2 id="Spring的事物传播行为"><a href="#Spring的事物传播行为" class="headerlink" title="Spring的事物传播行为"></a>Spring的事物传播行为</h2><p>事务传播⾏为是为了解决业务层⽅法之间互相调⽤的事务问题。当事务⽅法被另⼀个事务⽅法调⽤时，必须指定事 务应该如何传播。例如：⽅法可能继续在现有事务中运⾏，也可能开启⼀个新事务，并在⾃⼰的事务中运⾏。在 TransactionDefinition 定义中包括了如下⼏个表示传播⾏为的常量： ⽀持当前事务的情况： <strong>TransactionDefinition.PROPAGATION_REQUIRED</strong>：如果当前存在事务，则加⼊该事务；如果当前没有事务，则 创建⼀个新的事务； <strong>TransactionDefinition.PROPAGATION_SUPPORTS</strong>：如果当前存在事务，则加⼊该事务；如果当前没有事务，则 以⾮事务的⽅式继续运⾏； <strong>TransactionDefinition.PROPAGATION_MANDATORY</strong>：如果当前存在事务，则加⼊该事务；如果当前没有事务， 则抛出异常。 不⽀持当前事务的情况： <strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW</strong>：创建⼀个新的事务，如果当前存在事务，则把当前事务 挂起； <strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</strong>：以⾮事务⽅式运⾏，如果当前存在事务，则把当前事 务挂起。 TransactionDefinition.PROPAGATION_NEVER：以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。 其他情况： <strong>TransactionDefinition.PROPAGATION_NESTED</strong>：如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务 来运⾏；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED</p><h2 id="循环依赖如何解决？"><a href="#循环依赖如何解决？" class="headerlink" title="循环依赖如何解决？"></a>循环依赖如何解决？</h2><h2 id="MVC执行流程"><a href="#MVC执行流程" class="headerlink" title="MVC执行流程"></a>MVC执行流程</h2><ol><li>⽤户向服务器发送请求，请求被 Spring 前端控制Servelt DispatcherServlet 捕获； </li><li>DispatcherServlet 对请求 URL 进⾏解析，得到请求资源标识符（URI）。然后根据该 URI，调⽤ HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截 器），最后以 HandlerExecutionChain 对象的形式返回； </li><li>DispatcherServlet 根据获得的 Handler，选择⼀个合适的HandlerAdapter；（附注：如果成功获得 HandlerAdapter 后，此时将开始执⾏拦截器的 preHandler(…)⽅法） </li><li>提取 Request 中的模型数据，填充 Handler ⼊参，开始执⾏Handler（Controller)。在填充 Handler 的⼊参 过程中，根据你的配置，Spring 将帮你做⼀些额外的⼯作： （1）HttpMessageConveter：将请求消息（如：Json、xml 等数据）转换成⼀个对象，将对象转换为指定的响应 信息； （2）数据转换：对请求消息进⾏数据转换。如：String 转换成 Integer、Double 等； （3）数据格式化：对请求消息进⾏数据格式化。如：将字符串转换成格式化数字或格式化⽇期等； （4）数据验证：验证数据的有效性（⻓度、格式等），验证结果存储到 BindingResult 或 Error 中; </li><li>Handler 执⾏完成后，向 DispatcherServlet 返回⼀个 ModelAndView 对象； </li><li>根据返回的 ModelAndView，选择⼀个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)返回给DispatcherServlet； </li><li>ViewResolver 结合 Model 和 View，来渲染视图； </li><li>将渲染结果返回给客户端。</li></ol><h2 id="MVC核心组件"><a href="#MVC核心组件" class="headerlink" title="MVC核心组件"></a>MVC核心组件</h2><ol><li>前端控制器 DispatcherServlet 作⽤：Spring MVC 的⼊⼝函数。接收请求，响应结果，相当于转发器，中央处理器。有了 DispatcherServlet 减 少了其它组件之间的耦合度。⽤户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个 流程控制的中⼼，由它调⽤其它组件处理⽤户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 </li><li>处理器映射器 HandlerMapping 作⽤：根据请求的 url 查找 Handler。HandlerMapping 负责根据⽤户请求找到 Handler 即处理器 （Controller），SpringMVC 提供了不同的映射器实现不同的映射⽅式，例如：配置⽂件⽅式，实现接⼝⽅式，注 解⽅式等。 </li><li>处理器适配器 HandlerAdapter 作⽤：按照特定规则（HandlerAdapter 要求的规则）去执⾏ Handler。通过 HandlerAdapter 对处理器进⾏执 ⾏，这是适配器模式的应⽤，通过扩展适配器可以对更多类型的处理器进⾏执⾏。</li><li>处理器 Handler 注意：编写 Handler 时按照 HandlerAdapter 的要求去做，这样适配器才可以去正确执⾏ Handler。Handler 是继 DispatcherServlet 前端控制器的后端控制器，在 DispatcherServlet 的控制下 Handler 对具体的⽤户请求进⾏处 理。由于 Handler 涉及到具体的⽤户业务请求，所以⼀般情况需要⼯程师根据业务需求开发 Handler。 </li><li>视图解析器 View resolver 作⽤：进⾏视图解析，根据逻辑视图名解析成真正的视图（View ）。View Resolver 负责将处理结果⽣成 View 视 图，View Resolver ⾸先根据逻辑视图名解析成物理视图名即具体的⻚⾯地址，再⽣成 View 视图对象，最后对 View 进⾏渲染将处理结果通过⻚⾯展示给⽤户。SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、 freemarkerView、pdfView 等。⼀般情况下需要通过⻚⾯标签或⻚⾯模版技术将模型数据通过⻚⾯展示给⽤户， 需要由⼯程师根据业务需求开发具体的⻚⾯。 </li><li>视图 View View 是⼀个接⼝，实现类⽀持不同的 View 类型（jsp、freemarker…）。 注意：处理器 Handler（也就是我们平常说的 Controller 控制器）以及视图层 View 都是需要我们⾃⼰⼿动 开发的。其他的⼀些组件⽐如：前端控制器 DispatcherServlet、处理器映射器 HandlerMapping、处理器适 配器 HandlerAdapter 等等都是框架提供给我们的，不需要⾃⼰⼿动开发。</li></ol><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><blockquote><p>优点：</p><ol><li>简化spring配置，自动配置。</li><li>内嵌各种容器，可以直接jar包启动</li><li>通过starter封装各种配置</li><li>避免了maven冲突</li><li>提供了监控服务</li></ol><p>缺点：</p><ol><li>封装太多，排查问题麻烦点。</li></ol></blockquote><h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><ol><li>启动加载大量自动配置类</li><li>检查需要的功能有没有在自动配置中</li><li>可以通过properties文件添加组件</li></ol><h2 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h2><ol><li>SpringBoot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的 值 </li><li>将这些值作为⾃动配置类导⼊容器 ， ⾃动配置类就⽣效 ， 帮我们进⾏⾃动配置⼯作； </li><li>整个J2EE的整体解决⽅案和⾃动配置都在springboot-autoconfigure的jar包中； </li><li>它会给容器中导⼊⾮常多的⾃动配置类 （xxxAutoConfiguration）, 就是给容器中导⼊这个场景需要的所有组 件 ， 并配置好这些组件 ； 5. 有了⾃动配置类 ， 免去了我们⼿动编写配置注⼊功能组件等的⼯作；</li></ol><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><h2 id="集成定时任务"><a href="#集成定时任务" class="headerlink" title="集成定时任务"></a>集成定时任务</h2><ol><li>配置Quartz</li><li>定义job和trigger即可</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;为什么Spring&quot;&gt;&lt;a href=&quot;#为什么Spring&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="系统设计" scheme="https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="system design" scheme="https://hideincode.github.io/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://hideincode.github.io/2021/04/08/system/Redis/"/>
    <id>https://hideincode.github.io/2021/04/08/system/Redis/</id>
    <published>2021-04-07T16:00:00.000Z</published>
    <updated>2024-05-07T08:56:55.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>Strings</p></li><li><p>Hash</p></li><li><p>Lists</p><blockquote><p>粉丝列表,文章评论;基于缓存分页lrange</p></blockquote></li><li><p>Sets</p><blockquote><p>求交并补</p></blockquote></li><li><p>Sorted Sets</p></li></ul><h2 id="缓存与数据库数据一致性问题"><a href="#缓存与数据库数据一致性问题" class="headerlink" title="缓存与数据库数据一致性问题"></a>缓存与数据库数据一致性问题</h2><ol><li><p>CAP 读的时候先读缓存,写时先写库.</p><hr><ul><li><p>问题:如果删除缓存失败,那么就会读到旧数据.</p></li><li><p>解决方案:</p><ul><li>先删除缓存在更新库.</li><li>延时双删,利用队列 DelayQueue MQ</li></ul></li><li><p>高并发情况下的问题：</p><blockquote><p>A线程先删除了缓存，再去改数据，此时B线程读取数据会直接读取数据库旧数据，然后写入缓存。等到A修改完成，那么缓存与库数据不一致情况就会出现。</p></blockquote><p>解决方案，利用jvm本身的队列，进行串行化操作.</p></li></ul></li></ol><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><ol><li><p><strong>雪崩</strong>：雪崩指的是大量的缓存失效（一般由于过期），大量查询直接到数据库，导致数据库爆炸。</p><p>预防：利用redis的高可用，就是主从+哨兵，集群；</p><p>正在发生：本地ehcache缓存+hystrix限流降级，避免mysql挂掉；</p><p>事后：redis持久化，之后再去重启redis就直接从磁盘拿数据。</p></li><li><p>穿透：高并发查询缓存和数据库中都没有的数据，例如查询id&#x3D;-1，致使所有的请求都打到数据库，数据库爆炸。因为视缓存为无物，所以叫做穿透。</p><p>解决方案：从数据库中查询不到的值，也要在缓存中设置一个空值，设置一个过期时间。</p><p>如果使用不同的负数查询，那么用布隆过滤器，把所有数据放到布隆hash中，利用布隆过滤器筛选，减少压力；</p></li><li><p><strong>击穿</strong>： 热点数据的key在缓存失效瞬间，全部请求到数据库，导致数据库爆炸。</p><p>解决方案：</p><ul><li><p>对于不怎么更新的数据，设置成永不过期。</p></li><li><p>更新不频繁的，耗时较短的数据，利用分布式锁，让少量请求更新缓存，其余的在锁释放后读取缓存即可；</p></li><li><p>若缓存更新频繁或者耗时较长，利用定时任务在过期前主动重新构建缓存或者延后缓存过期时间，保证所有请求都能访问对应的缓存；</p></li></ul></li></ol><h2 id="Redis并发竞争问题"><a href="#Redis并发竞争问题" class="headerlink" title="Redis并发竞争问题"></a>Redis并发竞争问题</h2><blockquote><p>并发写，由于顺序问题，导致数据出错。利用分布式锁和数据库中的时间戳（更新时间），利用锁一个个写，利用时间戳比对数据是否是最新的。</p></blockquote><h2 id="技术选型为啥用Redis"><a href="#技术选型为啥用Redis" class="headerlink" title="技术选型为啥用Redis"></a>技术选型为啥用Redis</h2><blockquote><p>redis支持复杂的数据结构,相比于memcached,redis支持集群,数据量多的情况下,还是redis更好用.redis内部使用文件事件处理器.比较复杂,todo</p></blockquote><h2 id="为啥单线程的redis这么快"><a href="#为啥单线程的redis这么快" class="headerlink" title="**为啥单线程的redis这么快 **"></a>**为啥单线程的redis这么快 **</h2><ol><li>纯内存操作</li><li>基于非阻塞的IO多路复用机制</li><li>采用了C语言这种更加接近底层的语言</li><li>单线程避免了多线程的上下文频繁切换.也不会出现redis本身的资源竞争问题.</li></ol><h2 id="redis是有多线程的-自6-0以后"><a href="#redis是有多线程的-自6-0以后" class="headerlink" title="redis是有多线程的,自6.0以后"></a><strong>redis是有多线程的,自6.0以后</strong></h2><blockquote><p>因为某些方面,单线程已经没有太大优势了,读写网络的Read和Write系统在调用redis执行期间占用了大部分cpu时间,这种地方使用多线程对性能更友好.</p></blockquote><h2 id="redis的过期策略"><a href="#redis的过期策略" class="headerlink" title="redis的过期策略"></a>redis的过期策略</h2><ol><li><p>定期删除+惰性删除</p><blockquote><p>每过100ms就随机抽查一部分<code>设置了过期时间</code>的key,如果过期就删除;</p><p>查询key的时候也会检查,如果key已经过期,那么直接删除;</p><p><strong>此时大量过期key堆积,导致内存不够用,该如何是好</strong></p><p>答案:内存淘汰机制</p></blockquote><p>​2. Redis 内存淘汰机制有以下几个：</p></li></ol><ul><li><p>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</p></li><li><p><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key（这个是<strong>最常用</strong>的）。</p></li><li><p>allkeys-random：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</p></li><li><p>volatile-lru：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除最近最少使用的 key（这个一般不太合适）。</p></li><li><p>volatile-random：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，<strong>随机移除</strong>某个 key。</p></li><li><p>volatile-ttl：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，有<strong>更早过期时间</strong>的 key 优先移除。</p><p> <strong>考点: LRU算法</strong></p></li></ul><h3 id="Redis通过哨兵集群实现高可用"><a href="#Redis通过哨兵集群实现高可用" class="headerlink" title="Redis通过哨兵集群实现高可用"></a>Redis通过哨兵集群实现高可用</h3><ul><li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li><li>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li></ul><p>哨兵本身也是分布式的,可以做集群部署.</p><ul><li>故障转移需要大部分的哨兵同意.</li><li>哨兵至少需要三个实例.</li><li>哨兵+Redis的主从部署,不保证数据零丢失,只能保证Redis集群的高可用.</li><li>复杂部署架构,需要在测试环境和生产环境做够充足演练.</li></ul><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><blockquote><ul><li>RDB持久化机制,对Redis中的数据执行周期性的持久化</li><li>AOF记录日志,类似于Mysql的binlog,追加的形式到日志文件,重启时通过回放日志文件来重新构建数据集.</li></ul></blockquote><p><strong>RDB优缺点</strong></p><ul><li>会生成多个文件,适合存储云端服务器做冷备份.</li><li>对redis的对外读写影响很小,让redis保持高性能.</li><li>比AOF更快的持久化</li><li>由于周期型的,所以数据完整性不如AOF.</li><li>持久化的文件特别大时,会导致对客户端的服务暂停数毫秒到几秒.</li></ul><p><strong>AOF优缺点</strong></p><ul><li>数据完整性更可靠</li><li>写入性能高,直接追加.</li><li>日志文件过大也不会影响客户端的使用.</li><li>利用可读性较强的方式记录,适合做灾难性误删除的恢复.</li><li>开启后,支持写redis操作的QPS会降低</li><li>出现数据丢失</li></ul><p>可以同时开启两者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;</summary>
      
    
    
    
    <category term="系统设计" scheme="https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="system design" scheme="https://hideincode.github.io/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>Spring源码</title>
    <link href="https://hideincode.github.io/2021/03/03/code/spring/"/>
    <id>https://hideincode.github.io/2021/03/03/code/spring/</id>
    <published>2021-03-02T16:00:00.000Z</published>
    <updated>2024-05-07T08:44:59.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><blockquote><p>记录spring源码中的精华思想</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;记录spring源码中的精华思想&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="源码分析" scheme="https://hideincode.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="code" scheme="https://hideincode.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>JDK中的源码</title>
    <link href="https://hideincode.github.io/2020/09/07/code/jdk/"/>
    <id>https://hideincode.github.io/2020/09/07/code/jdk/</id>
    <published>2020-09-06T16:00:00.000Z</published>
    <updated>2024-05-07T08:59:20.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h1><blockquote><p>用于记录jdk中的好的设计模式，算法思路，一些特性与bug。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDK&quot;&gt;&lt;a href=&quot;#JDK&quot; class=&quot;headerlink&quot; title=&quot;JDK&quot;&gt;&lt;/a&gt;JDK&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;用于记录jdk中的好的设计模式，算法思路，一些特性与bug。&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="源码分析" scheme="https://hideincode.github.io/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="code" scheme="https://hideincode.github.io/tags/code/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis</title>
    <link href="https://hideincode.github.io/2020/08/02/system/MyBatis/"/>
    <id>https://hideincode.github.io/2020/08/02/system/MyBatis/</id>
    <published>2020-08-01T16:00:00.000Z</published>
    <updated>2024-05-07T08:55:43.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><blockquote><ol><li>半自动ORM框架，对JDBC进行了封装。</li><li>使用xml&#x2F;注解进行配置和映射。</li><li>灵活编写SQL，不用与代码耦合。</li><li>兼容各种数据库。</li><li>提供了映射标签。</li><li>但是SQL编写量变大，多表时麻烦；SQL语句以来数据库，不好随便换库。</li><li>不要用RowBounds进行分页，这是个内存分页。</li></ol></blockquote><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol><li><p>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，其存储作⽤域为 Session，当 Session flush 或 close 之 后，该 Session 中的所有 Cache 就将清空，默认打开⼀级缓存；</p></li><li><p>二级缓存：与⼀级缓存其机制相同，默认也是采⽤ PerpetualCache，HashMap 存储，不同在于其存储作⽤域为 Mapper(Namespace)，并且可⾃定义存储源，如 Ehcache。默认不打开⼆级缓存，要开启⼆级缓存，使⽤⼆级缓 存属性类需要实现 Serializable 序列化接⼝(可⽤来保存对象的状态)，可在它的映射⽂件中配。</p></li><li><p>对于缓存数据更新机制，当某⼀个作⽤域(⼀级缓存 Session &#x2F; ⼆级缓存 Namespaces)的进⾏了 C&#x2F;U&#x2F;D 操作后，默 认该作⽤域下所有 select 中的缓存将被 clear。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;/a&gt;Mybatis&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;半自动ORM框架，对JDBC进行了封装。&lt;/li&gt;
&lt;li&gt;使</summary>
      
    
    
    
    <category term="系统设计" scheme="https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="system design" scheme="https://hideincode.github.io/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>常见消息队列选型</title>
    <link href="https://hideincode.github.io/2020/07/13/system/MQ/"/>
    <id>https://hideincode.github.io/2020/07/13/system/MQ/</id>
    <published>2020-07-12T16:00:00.000Z</published>
    <updated>2024-05-07T08:55:16.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><blockquote><p>当碰到需要解耦、异步、削峰问题时，那么就使用MQ吧。</p></blockquote><h2 id="常见的MQ"><a href="#常见的MQ" class="headerlink" title="常见的MQ"></a>常见的MQ</h2><p><strong>ActiveMQ</strong>：支持万级的吞吐量，较成熟完善；官方更新迭代较少，社区的活跃度不是很高，有消息丢失的情况。</p><p><strong>RabbitMQ</strong>：延时低，微妙级延时，社区活跃度高，bug 修复及时，而且提供了很友善的后台界面；用 Erlang 语言开发，只熟悉 Java 的无法阅读源码和自行修复 bug。</p><p><strong>RocketMQ</strong>：阿里维护的消息中间件，可以达到十万级的吞吐量，支持分布式事务。</p><p><strong>Kafka</strong>：分布式的中间件，最大优点是其吞吐量高，一般运用于大数据系统的实时运算和日志采集的场景，功能简单，可靠性高，扩展性高；缺点是可能导致重复消费。</p><h2 id="MQ处理消息时容易遇到的问题"><a href="#MQ处理消息时容易遇到的问题" class="headerlink" title="MQ处理消息时容易遇到的问题"></a>MQ处理消息时容易遇到的问题</h2><ul><li>消息丢失<ul><li>RabbitMQ<ul><li>生产者：<ul><li>开启事务（不推荐）</li><li>开启confirm模式（推荐）</li></ul></li><li>MQ：开启持久化</li><li>消费者：<ul><li>关闭自动ACK</li></ul></li></ul></li><li>Kafka<ul><li>生产者：设置acks&#x3D;all，数据一定不丢</li><li>MQ：？？</li><li>消费者：Kafka会自动offset，可以关闭offset，使用手动提交offset，保证数据不会丢。</li></ul></li></ul></li><li>消息幂等<ul><li>写数据时先根据主键查询数据是否存在，存在则更新。</li><li>利用数据库的唯一键索引。</li><li>如果是redis，那么redis的set天然支持去重幂等。</li></ul></li><li>消息顺序性<ul><li>RabbitMQ：拆分成多个Queue，每个Queue一个Consumer，然后Consumer内部用内存队列做排队，分发给底层不同的Worker处理。</li><li>Kafka：写N个内存Queue，具有相同key的数据进入到同一个Queue；对于N个线程，每个线程消费一个内存Queue，保证了顺序性。</li></ul></li><li>消息积压<ul><li>先修复consumer，保证消费速度，然后停掉consumer;</li><li>新建个topic，partion设置为原来10倍，临时建立原来10倍的queue。</li><li>写一个临时分发数据的consumer，用这个程序去消费积压数据，把数据轮询写入临时建好的10倍queue；</li><li><strong>10倍机器部署consumer</strong>，每一批consumer消费一个queue，相当于把queue资源和consumer资源扩大10倍，以原来10倍速度消费；</li><li>等消费完积压的数据，恢复原来结构，正常消费。</li></ul></li><li>消息失效<ul><li>把丢失的消息查出来，重新导入MQ。</li></ul></li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>如何高可用<ul><li>RabbitMQ：镜像集群模式，队列的消息会分布在多个机器上，写消息时就会跟多个队列进行通讯。这样任意一个宕机都不影响系统。问题在于开销太大，拓展性差。</li><li>Kafka：partition和replica机制，每个节点都是一个broker，一个topic可以分成多个partition，partition可以存在多个broker上，也就是说一个topic的消息是分在多个机器上的。0.8版本后提供了HA机制，即replica副本机制。每个partition数据都会同步到其他机器，形成多个副本。然后所有的replica选举一个leader，生产消费都和这个leader打交道，其他的replica就是follower。写的时候leader会把数据同步到所有的follower上去，读的时候直接读leader上的数据。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MQ&quot;&gt;&lt;a href=&quot;#MQ&quot; class=&quot;headerlink&quot; title=&quot;MQ&quot;&gt;&lt;/a&gt;MQ&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;当碰到需要解耦、异步、削峰问题时，那么就使用MQ吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;常见的M</summary>
      
    
    
    
    <category term="系统设计" scheme="https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="system design" scheme="https://hideincode.github.io/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>ES的使用与原理</title>
    <link href="https://hideincode.github.io/2020/06/11/system/ElasticSearch/"/>
    <id>https://hideincode.github.io/2020/06/11/system/ElasticSearch/</id>
    <published>2020-06-10T16:00:00.000Z</published>
    <updated>2024-05-07T08:54:06.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><blockquote><p>简称ES，一种近实时、大量数据搜索工具。多用于监控（ELK)、信息检索。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ElasticSearch&quot;&gt;&lt;a href=&quot;#ElasticSearch&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch&quot;&gt;&lt;/a&gt;ElasticSearch&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;简称ES，一种近实时、大量</summary>
      
    
    
    
    <category term="系统设计" scheme="https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="system design" scheme="https://hideincode.github.io/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://hideincode.github.io/2020/05/02/system/Dubbo/"/>
    <id>https://hideincode.github.io/2020/05/02/system/Dubbo/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2024-05-07T08:55:11.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><blockquote><p>RPC框架，用于服务之间调用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dubbo&quot;&gt;&lt;a href=&quot;#Dubbo&quot; class=&quot;headerlink&quot; title=&quot;Dubbo&quot;&gt;&lt;/a&gt;Dubbo&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;RPC框架，用于服务之间调用。&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    <category term="系统设计" scheme="https://hideincode.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="system design" scheme="https://hideincode.github.io/tags/system-design/"/>
    
  </entry>
  
  <entry>
    <title>代码问题</title>
    <link href="https://hideincode.github.io/2020/04/01/error/%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://hideincode.github.io/2020/04/01/error/%E4%BB%A3%E7%A0%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-31T16:00:00.000Z</published>
    <updated>2024-05-07T08:52:44.526Z</updated>
    
    
    
    
    <category term="问题排查" scheme="https://hideincode.github.io/categories/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    
    <category term="error" scheme="https://hideincode.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>开发环境准备</title>
    <link href="https://hideincode.github.io/2019/12/01/devops/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"/>
    <id>https://hideincode.github.io/2019/12/01/devops/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</id>
    <published>2019-11-30T16:00:00.000Z</published>
    <updated>2024-05-07T08:52:25.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h1><p>代码工具：JDK、Idea、Maven、Git、VsCode、NodeJs、Anaconda、Pycharm</p><p>vscode插件：</p><ul><li>EsLint —— 语法纠错 </li><li>Auto Close Tag —— 自动闭合 </li><li>HTML&#x2F;XML 标签 </li><li>Auto Rename Tag —— 自动完成另一侧标签的同步修改 </li><li>JavaScript(ES6) code snippets — — ES6 语 法 智 能 提 示 以 及 快 速 输 入 ， 除 js 外 还 支 持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含 js 代码文件的时间 </li><li>HTML CSS Support —— 让 html 标签上写 class 智能提示当前项目所支持的样式 </li><li>HTML Snippets —— html 快速自动补全</li><li>Open in browser —— 浏览器快速打开 Live Server —— 以内嵌服务器方式打开 </li><li>Chinese (Simplified) Language Pack for Visual Studio Code</li></ul><p>虚拟机配置：Vagrant、VirtualBox</p><p>常用服务：MySQL、Redis、Tomcat、Nginx</p><p>远程连接与可视化：MobaXterm、Navicat、RedisInsight</p><p>设计图工具：Processon、draw.io</p><p>杂项：Postman、Typora、Everything、XMind、7zip、梯子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开发环境准备&quot;&gt;&lt;a href=&quot;#开发环境准备&quot; class=&quot;headerlink&quot; title=&quot;开发环境准备&quot;&gt;&lt;/a&gt;开发环境准备&lt;/h1&gt;&lt;p&gt;代码工具：JDK、Idea、Maven、Git、VsCode、NodeJs、Anaconda、Pycharm</summary>
      
    
    
    
    <category term="开发部署" scheme="https://hideincode.github.io/categories/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2/"/>
    
    
    <category term="devops" scheme="https://hideincode.github.io/tags/devops/"/>
    
  </entry>
  
</feed>
