<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://hideincode.github.io/atom.xml" rel="self"/>
  
  <link href="https://hideincode.github.io/"/>
  <updated>2023-09-01T15:52:48.753Z</updated>
  <id>https://hideincode.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/error/%E6%9C%BA%E5%99%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://hideincode.github.io/2024/05/07/error/%E6%9C%BA%E5%99%A8%E9%97%AE%E9%A2%98/</id>
    <published>2024-05-06T18:09:22.576Z</published>
    <updated>2023-09-01T15:52:48.753Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/devops/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"/>
    <id>https://hideincode.github.io/2024/05/07/devops/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</id>
    <published>2024-05-06T18:09:22.572Z</published>
    <updated>2023-11-23T13:21:31.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h1><p>代码工具：JDK、Idea、Maven、Git、VsCode、NodeJs、Anaconda、Pycharm</p><p>vscode插件：</p><ul><li>EsLint —— 语法纠错 </li><li>Auto Close Tag —— 自动闭合 </li><li>HTML&#x2F;XML 标签 </li><li>Auto Rename Tag —— 自动完成另一侧标签的同步修改 </li><li>JavaScript(ES6) code snippets — — ES6 语 法 智 能 提 示 以 及 快 速 输 入 ， 除 js 外 还 支 持.ts，.jsx，.tsx，.html，.vue，省去了配置其支持各种包含 js 代码文件的时间 </li><li>HTML CSS Support —— 让 html 标签上写 class 智能提示当前项目所支持的样式 </li><li>HTML Snippets —— html 快速自动补全</li><li>Open in browser —— 浏览器快速打开 Live Server —— 以内嵌服务器方式打开 </li><li>Chinese (Simplified) Language Pack for Visual Studio Code</li></ul><p>虚拟机配置：Vagrant、VirtualBox</p><p>常用服务：MySQL、Redis、Tomcat、Nginx</p><p>远程连接与可视化：MobaXterm、Navicat、RedisInsight</p><p>设计图工具：Processon、draw.io</p><p>杂项：Postman、Typora、Everything、XMind、7zip、梯子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;开发环境准备&quot;&gt;&lt;a href=&quot;#开发环境准备&quot; class=&quot;headerlink&quot; title=&quot;开发环境准备&quot;&gt;&lt;/a&gt;开发环境准备&lt;/h1&gt;&lt;p&gt;代码工具：JDK、Idea、Maven、Git、VsCode、NodeJs、Anaconda、Pycharm</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/devops/ngxin/"/>
    <id>https://hideincode.github.io/2024/05/07/devops/ngxin/</id>
    <published>2024-05-06T18:09:22.571Z</published>
    <updated>2023-11-23T04:35:28.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><h2 id="docker下安装"><a href="#docker下安装" class="headerlink" title="docker下安装"></a>docker下安装</h2><ol><li><p>docker pull nginx </p></li><li><p>docker run –name nginx -p 9000:80 -d nginx 先启动一个容器用来复制配置</p></li><li><p>生成挂载文件地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /opt/docker/nginx/conf</span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/docker/nginx/html</span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/docker/nginx/logs</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">cp</span> nginx:/etc/nginx/nginx.conf /opt/docker/nginx/conf/nginx.conf</span><br><span class="line">docker <span class="built_in">cp</span> nginx:/etc/nginx/conf.d /opt/docker/nginx/conf/conf.d</span><br><span class="line">docker <span class="built_in">cp</span> nginx:/usr/share/nginx/html /opt/docker/nginx</span><br></pre></td></tr></table></figure></li><li><p>干掉这个nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker stop nginx </span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br></pre></td></tr></table></figure></li><li><p>以80端口启动，一行命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 --name nginx --restart=always -v /opt/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v /opt/docker/nginx/conf/conf.d:/etc/nginx/conf.d -v /opt/docker/nginx/html:/usr/share/nginx/html -v /opt/docker/nginx/logs:/var/log/nginx -d nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="配置遗漏"><a href="#配置遗漏" class="headerlink" title="配置遗漏"></a>配置遗漏</h3><ol><li>每句配置结尾有分号！！！</li></ol><h3 id="转发不到"><a href="#转发不到" class="headerlink" title="转发不到"></a>转发不到</h3><ol><li>查看error.log，请求路径是否符合预期。</li></ol><h2 id="斜杠问题"><a href="#斜杠问题" class="headerlink" title="斜杠问题"></a>斜杠问题</h2><blockquote><p>配置为：</p><p>location hello&#x2F; {</p><p> <strong>proxy_pass</strong> 192.168.56.10&#x2F;</p><p>}</p><p>请求：nginx主机&#x2F;hello&#x2F;all</p></blockquote><ol><li>location：不带&#x2F;的话会自动补上，带的话能正确拼接。</li><li>proxy_pass：<ol><li>带&#x2F;：;最终请求：nginx主机&#x2F;all，即忽略location.</li><li>不带&#x2F;：最终请求：nginx主机&#x2F;hello&#x2F;all</li></ol></li><li>location不带，proxy_pass带：会生成双斜杠，nginx主机&#x2F;&#x2F;all，这是因为补齐机制导致。</li><li>总结：proxy_pass看项目的controller有没有带，location最好带上。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装部署&quot;&gt;&lt;a href=&quot;#安装部署&quot; class=&quot;headerlink&quot; title=&quot;安装部署&quot;&gt;&lt;/a&gt;安装部署&lt;/h1&gt;&lt;h2 id=&quot;docker下安装&quot;&gt;&lt;a href=&quot;#docker下安装&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/devops/maven/"/>
    <id>https://hideincode.github.io/2024/05/07/devops/maven/</id>
    <published>2024-05-06T18:09:22.570Z</published>
    <updated>2023-11-23T13:13:41.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven的一些问题"><a href="#Maven的一些问题" class="headerlink" title="Maven的一些问题"></a>Maven的一些问题</h1><h2 id="常见配置"><a href="#常见配置" class="headerlink" title="常见配置"></a>常见配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>../rep<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Maven的一些问题&quot;&gt;&lt;a href=&quot;#Maven的一些问题&quot; class=&quot;headerlink&quot; title=&quot;Maven的一些问题&quot;&gt;&lt;/a&gt;Maven的一些问题&lt;/h1&gt;&lt;h2 id=&quot;常见配置&quot;&gt;&lt;a href=&quot;#常见配置&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/devops/linux/"/>
    <id>https://hideincode.github.io/2024/05/07/devops/linux/</id>
    <published>2024-05-06T18:09:22.569Z</published>
    <updated>2023-11-19T08:22:56.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1><p>查看端口</p><ul><li>lsof -i:8080 列出系统打开的文件</li><li>netstat -tunlp |grep 8080 列出包含8080端口的tcp、udp、拒绝别名、展示监听、进程名</li></ul><p>查看进程</p><ul><li>ps -ef |grep java 查看java进程</li><li>jps 查看java进程，需要安装jdk</li></ul><p>杀进程</p><ul><li>kill -9 pid 强制干掉$pid</li><li>kill -15 pid 优雅停机</li></ul><p>清理旧包脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf target</span><br><span class="line">appname=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;appname:<span class="variable">$appname</span>&quot;</span></span><br><span class="line">pid=`ps -ef | grep <span class="variable">$appname</span> | grep <span class="string">&#x27;java -Xms&#x27;</span> | awk <span class="string">&#x27;&#123;printf $2&#125;&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pid</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$pid</span>];</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$appname</span> not start&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$appname</span> stoping...&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">check=`ps -ef | grep -w <span class="variable">$pid</span> | grep java`</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$check</span>];</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$appname</span> pid:<span class="variable">$pid</span> is stop&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$appname</span> stop failed&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux命令&quot;&gt;&lt;a href=&quot;#Linux命令&quot; class=&quot;headerlink&quot; title=&quot;Linux命令&quot;&gt;&lt;/a&gt;Linux命令&lt;/h1&gt;&lt;p&gt;查看端口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lsof -i:8080 列出系统打开的文件&lt;/li&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/devops/k8s/"/>
    <id>https://hideincode.github.io/2024/05/07/devops/k8s/</id>
    <published>2024-05-06T18:09:22.567Z</published>
    <updated>2023-11-23T13:32:59.873Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K8S集群搭建"><a href="#K8S集群搭建" class="headerlink" title="K8S集群搭建"></a>K8S集群搭建</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;K8S集群搭建&quot;&gt;&lt;a href=&quot;#K8S集群搭建&quot; class=&quot;headerlink&quot; title=&quot;K8S集群搭建&quot;&gt;&lt;/a&gt;K8S集群搭建&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/devops/jenkins/"/>
    <id>https://hideincode.github.io/2024/05/07/devops/jenkins/</id>
    <published>2024-05-06T18:09:22.566Z</published>
    <updated>2023-11-18T13:54:12.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jenkins部署与使用"><a href="#Jenkins部署与使用" class="headerlink" title="Jenkins部署与使用"></a>Jenkins部署与使用</h1><ol><li><p>去官网下载war包，注意支持的Java版本<a href="https://www.jenkins.io/zh/">Jenkins官网</a></p></li><li><p>上传到服务器，下载jdk，使用命令：nohup java -Xms515m -Xmx1024m -jar -Dfile.encoding&#x3D;UTF-8 jenkins.war &gt; jenkins.log 2&gt;&amp;1 &amp;</p></li><li><p>进入2中生成log查看密码，或者&#x2F;root&#x2F;.jenkins&#x2F;secrets&#x2F;initialAdminPassword中看到密码。</p></li><li><p>host:8080登录,选择推荐安装，能跳过先跳过。</p></li><li><p>修改密码</p></li><li><p>安装<a href="https://plugins.jenkins.io/maven-plugin">Maven Integration plugin</a>、<a href="https://plugins.jenkins.io/build-token-root">Build Authorization Token Root Plugin</a>、<a href="https://plugins.jenkins.io/publish-over-ssh">Publish Over SSH</a>。用于进行maven打包、自动构建匿名token，链接服务器。</p></li><li><p>在服务器上安装maven，git。maven要配置好国内镜像。</p></li><li><p>新建任务选择<strong>构建一个maven项目</strong>，这一步必须安装插件才有</p></li><li><p>在<strong>系统管理</strong>-&gt;<strong>系统配置</strong>中，<strong>JekinsLocation</strong>指定jenkins服务器地址；配置<strong>Publish over SSH</strong>执行jar包的服务器地址与用户</p></li><li><p>在<strong>源码管理中</strong>配置git仓库地址与分支，<strong>PostSteps</strong>中配置执行jar包的服务器(使用绝对路径)，设置启动命令。在<strong>构建触发器</strong>中触发远程构建，自定义令牌，利用Build Authorization Token Root Plugin，生成链接，具体参考插件官网。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动项目</span></span><br><span class="line"><span class="built_in">nohup</span> java -Xms515m -Xmx1024m -jar -Dfile.encoding=UTF-8 *.jar &gt; app.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li><p>在<strong>PreSteps</strong>中远程清除jar包，杀死旧进程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf target</span><br><span class="line">appname=<span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;appname:<span class="variable">$appname</span>&quot;</span></span><br><span class="line">pid=`ps -ef | grep <span class="variable">$appname</span> | grep <span class="string">&#x27;java -Xms&#x27;</span> | awk <span class="string">&#x27;&#123;printf $2&#125;&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$pid</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$pid</span>];</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$appname</span> not start&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">kill</span> -9 <span class="variable">$pid</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$appname</span> stoping...&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">check=`ps -ef | grep -w <span class="variable">$pid</span> | grep java`</span><br><span class="line"><span class="keyword">if</span> [ -z <span class="variable">$check</span>];</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$appname</span> pid:<span class="variable">$pid</span> is stop&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$appname</span> stop failed&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>点击构建，观察控制台。</p></li><li><p>可以配置gitlab的webhook触发自动部署，记得切换管理员到network中<strong>外发请求</strong>中勾选允许本地。</p></li><li><p>可以利用定时构建和cron表达式来定期构建。判断表达式可用工具：<a href="https://crontab.guru/">cron工具</a></p></li><li><p>可以配置告警邮件，要自己给出支持SMTP的邮箱，推荐网易，QQ不行。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Jenkins部署与使用&quot;&gt;&lt;a href=&quot;#Jenkins部署与使用&quot; class=&quot;headerlink&quot; title=&quot;Jenkins部署与使用&quot;&gt;&lt;/a&gt;Jenkins部署与使用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;去官网下载war包，注意支持的Java版本</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/devops/git/"/>
    <id>https://hideincode.github.io/2024/05/07/devops/git/</id>
    <published>2024-05-06T18:09:22.564Z</published>
    <updated>2023-11-23T03:11:55.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git解决了什么问题"><a href="#git解决了什么问题" class="headerlink" title="git解决了什么问题"></a>git解决了什么问题</h2><ol><li><p><strong>分布式</strong>: 解决以前<strong>集中式</strong>单点文件服务器宕机的痛点,;由于git是分布式的vcs系统,<code>无需联网</code>就可以在本地提交保存各自的操作记录,最后与其他人合并推送到远程服务器保存即可.</p></li><li><p><strong>轻量健全的分支系统</strong>:有想法就可以开分支,分支都在自己仓库内,不会影响其他人,便于切换和协作开发.</p></li><li><p><strong>快</strong>:所有操作在本地,肯定会快.</p><p><strong>tips</strong> : git的学习曲线真的不算平滑,当然如果只是当个下载器那没啥可说.</p></li></ol><h2 id="建仓"><a href="#建仓" class="headerlink" title="建仓"></a>建仓</h2><blockquote><p><code>git init </code></p><p>git config –global user.name “sui”</p><p>git config –global user.email “<a href="mailto:&#x61;&#64;&#98;&#46;&#99;&#111;&#x6d;">&#x61;&#64;&#98;&#46;&#99;&#111;&#x6d;</a>“</p><p><code>git config --list</code> 查看现有配置</p><p>初始化仓库,配置自己的<code>名字</code>和<code>邮箱</code></p></blockquote><p><strong>tips:</strong> 如果文件是代码的话,一般要配置上.gitignore和README.md文件.</p><p><strong>tips:</strong>  <em>作者</em> 和 <em>提交者</em> 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><blockquote><p><strong>工作区</strong>—&gt;<strong>暂存区</strong>—&gt;<strong>本地仓库</strong></p><p><code>git add 文件</code> 开始追踪该文件,并加入缓存区.已经追踪但是修改了的文件也要重新add才能加入暂存区.</p><p><code>git commit -m</code> 把暂存区的所有变更提到本地仓库,工作区直接提交加-a</p><p><code>git diff</code> 查看未暂存的修改了哪些地方,不好用.</p><p><code>git diff --cached</code> 查看已暂存的变化.</p><p><code>git rm 文件</code> 从工作区删除该文件,并且不再追踪.</p><p><code>git rm --cached 文件</code> 不会从工作区删除该文件,不再追踪该文件. </p><p><code>git mv source target</code> 重命名,并且依旧追踪.</p><p><code>git log</code> 查看提交记录</p></blockquote><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><blockquote><p><code>git commit --amend</code> 修正提交,把暂存区的文件提交,第二次提交将代替第一次提交的结果.</p><p>用于修正提交信息和提交遗漏文件</p><p><code>git checkout 文件</code> 把该文件还原成暂存区中的状态 </p><p><code>git reset HEAD</code>  重置暂存区为上一次提交,工作区不变,暂存区改文件未提交.(放弃提交)</p><pre><code> 1. 默认是 git reset --mixed HEAD 同上 2. git reset --hard HEAD 重置所有没有提交入库的,工作区和暂存区都会修改,谨慎使用! 3. git reset --soft HEAD  重置HEAD指针,工作区和暂存区不会改变 4. git reset 文件 可以指定回退文件</code></pre><p><code>git checkout HEAD .</code> 把工作区的文件都会退到HEAD指向的提交</p><p><code>git checkout comId 文件  </code>把工作区改文件退回到comId</p></blockquote><p><strong>tips:</strong> 对于git,几乎所有的已提交的东西总能恢复.</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><blockquote><p><code>git remote -v</code> 查看要读写的远程仓库简称以及URL </p><p><code>git remote add &lt;为远程仓库起的别名&gt; &lt;远程仓库地址&gt;</code> 添加一个远程仓库</p><p><code>git fetch &lt;别名&gt;</code> 从远程仓库下载本地缺失的提交,更新远程分支,并没有修改本地文件,需要自己手动合并.</p><p><code>git pull &lt;别名&gt;</code> 拉取并合并</p><p><code>git push &lt;别名&gt; &lt;branch&gt;</code> 把本地仓库提交推送到远程仓库,如果已经有其他人推送,必须先拉取.</p><p><code>git remote show &lt;别名&gt;</code> 查看远程仓库所有分支与URL</p><p><code>git remote rename &lt;旧名字&gt; &lt;新名字&gt;</code> 重新命名简称</p><p><code>git remote remove &lt;别名&gt;</code> 移除与远程仓库的关联</p></blockquote><h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p><strong>标签是为了标记重要版本</strong></p><p>git支持两种标签:轻量标签,附注标签.其中轻量标签只是简单打个标签不含其他额外信息,而附注标签会带有打标签人的姓名,邮箱,日期,和标签独有信息.</p><blockquote><p><code>git tag</code> 列出所有标签</p><p><code>git tag -l &quot;v1.0*&quot;</code> 匹配所有v1.0版本的</p><p><code>git tag -a v1.0 -m &quot;my version 1.0&quot;</code> 打上<code>附注标签</code>标签v1.0,并填上信息</p><p><code>git show v1.0</code> 看标签信息</p><p><code>git tag tagName</code>  直接打上轻量标签</p><p><code>git tag -a &lt;tagName&gt; &lt;commId&gt; </code> 给历史提交打标签</p><p><code>git push origin &lt;tagName&gt;</code> 把标签推送到远程仓库(不会自动推送到远程)</p><p><code>git push origin tags</code> 把所有标签推送到远程仓库</p><p><code>git tag -d &lt;tagName&gt;</code> 删除标签,并不会删除远程标签</p><p><code>git push &lt;remote&gt;:refs/tags/&lt;tagName&gt;</code>删除远程关联的标签</p><p><code>git push origin --delete &lt;tagName&gt;</code> 效果同上,删除远程标签</p><p><code>git checkout &lt;tagName&gt;</code>  检出标签所指文件版本,会使仓库处于头指针分离状态,不建议用</p></blockquote><h2 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h2><blockquote><p><code>git config --global alias.co checkout</code> 把checkout改名为co</p></blockquote><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>轻量的,无需副本的,支持频繁合并</p><blockquote><p>HEAD 是一个指向当前所在的本地分支,可以把HEAD想象成当前分支的别名.</p><p>切换分支会重置工作区,而且工作目录和暂存区没有提交的内容如果和checkout的分支有冲突,那么将会切换失败,此时要先解决冲突.</p><p>冲突是指某个文件某一部分进行了不同的修改,这个是git无法处理的,合并完需要用<code>git add</code>来标记为已解决.</p></blockquote><blockquote><p><code>git branch &lt;分支名字&gt;</code>  创建一个分支,也就是创建了一个可移动的指向提交对象的指针,执行命令后HEAD并不会指向新建的分支.</p><p><code>git checkout &lt;分支名称&gt;</code> 切换分支,即把HEAD指向当前分支,<code>工作区可能被改变</code>,git发现有冲突时将切不过来.</p><p><code>git merge hotfix</code> 把hotfix合并到当前分支,喊过来一起干大事</p><p><code>git log --oneline --decorate --graph --all</code> 项目分叉历史.</p><p><code>git checkout -b &lt;分支名称&gt;</code> 创建并切换到新分支</p><p><code>git branch -d &lt;分支名字&gt;</code> 删除一个分支,一般分支要解决的问题完成后,就删除该分支</p><p><code>git branch -f main HEAD~3</code> 让分支指向另一个提交,此处让main往回走三次.</p></blockquote><h3 id="如何管理分支"><a href="#如何管理分支" class="headerlink" title="如何管理分支"></a>如何管理分支</h3><blockquote><p><code>git branch</code> 查看所有分支</p><p><code>git branch -v</code> 查看每个分支最后一次提交</p><p><code>git branch --merged</code> 查看哪些分支已经合并到当前分支</p><p><code>git branch --no-merged</code> 查看还没有合并到当前的分支,对这些分支进行删除会失败.</p></blockquote><h3 id="关于远程分支"><a href="#关于远程分支" class="headerlink" title="关于远程分支"></a>关于远程分支</h3><blockquote><p><code>git ls-remote origin</code> 获取远程仓库名为origin的所有分支引用.</p><p><code>git remote show origin</code> 获取远程分支的跟踪,合并,推送等信息</p><p><code>git fetch origin</code> 拉取origin上本地没有数据</p><p><code>git push origin master</code> 把本地仓库推送到远程仓库</p><p><code>git checkout -b release origin/release</code> 建立一个指向远程release的本地分支</p><p><code>git push origin --delete hotFix</code> 删除服务器上的hotFix分支</p></blockquote><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><blockquote><p>给另一个分支A当儿子,找到当前分支和A的最近公共祖先结点,把最近祖先结点后到当前的提交并入A下.</p><p>相比于merge的优点:使提交历史更加简洁,把并行开发弄得像穿行开发.</p><p>相同点:结果快照和merge都是一样的,只是变更了历史.</p><p>tips: git merge 有直接移动HEAD指针的功能</p><p><strong>wanrning</strong>: <strong>如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。</strong></p></blockquote><blockquote><p><code>git rebase master</code> 当前分支接着master</p><p><code>git rebase --onto master server client</code> 这里server拉取于master,client拉取于server,把属于client但是不属于server的提交变基到master下.<strong>git可以把树的当前节点合并到任意节点下</strong></p><p><code>git rebase &lt;basebranch&gt; &lt;topicbranch&gt;</code> 直接将topic合入master,无需切换分支</p><p><code>git pull --rebase</code> 正确拉取已经被编辑的提交</p></blockquote><h2 id="服务器上的Git"><a href="#服务器上的Git" class="headerlink" title="服务器上的Git"></a>服务器上的Git</h2><blockquote><p>基于不同协议传输数据</p><ol><li>本地协议,基于文件共享系统的.</li><li>HTTP协议</li><li>SSH协议</li><li>git协议</li></ol></blockquote><blockquote><p><code>ssh-keygen -o</code> 生成 ssh公钥到home路径的.ssh下的.pub文件,用于免密登录.</p><p><code>git cherry-pick commId1 commId2 ..</code>  摘樱桃,摘取有用提交.</p></blockquote><h2 id="Git工具"><a href="#Git工具" class="headerlink" title="Git工具"></a>Git工具</h2><blockquote><p><code>git revert release HEAD~1</code> 生成新提交,并撤销已存在提交的所有修改. </p></blockquote><p>常见Git服务器: GitLab</p><p>第三方托管:GitHub,Gitee</p><p><a href="https://git-scm.com/book/zh/v2">参考文档</a></p><h2 id="本地代码与远程仓库关联："><a href="#本地代码与远程仓库关联：" class="headerlink" title="本地代码与远程仓库关联："></a>本地代码与远程仓库关联：</h2><ol><li>git init</li><li>git remote add &lt;别名&gt; &lt;clone地址&gt;</li><li>提交所有本地代码到本地仓库</li><li>git push &lt;别名&gt; &lt;分支&gt; 这里的分支要和本地一致</li><li>完成</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git解决了什么问题&quot;&gt;&lt;a href=&quot;#git解决了什么问题&quot; class=&quot;headerlink&quot; title=&quot;git解决了什么问题&quot;&gt;&lt;/a&gt;git解决了什么问题&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;分布式&lt;/strong&gt;: 解决以前&lt;st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/code/spring/"/>
    <id>https://hideincode.github.io/2024/05/07/code/spring/</id>
    <published>2024-05-06T18:09:22.561Z</published>
    <updated>2023-10-12T14:36:24.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><blockquote><p>记录spring源码中的精华思想</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;记录spring源码中的精华思想&lt;/p&gt;
&lt;/blockquote&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/basic/%E7%BD%91%E7%BB%9C/"/>
    <id>https://hideincode.github.io/2024/05/07/basic/%E7%BD%91%E7%BB%9C/</id>
    <published>2024-05-06T18:09:22.556Z</published>
    <updated>2023-09-21T14:26:45.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="浏览器输入网址到展示内容发生了什么？"><a href="#浏览器输入网址到展示内容发生了什么？" class="headerlink" title="浏览器输入网址到展示内容发生了什么？"></a>浏览器输入网址到展示内容发生了什么？</h2><ol><li>DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索⾃身的 DNS 缓存、搜索操 作系统的 DNS 缓存、读取本地的 Host ⽂件和向本地 DNS 服务器进⾏查询等。对于向本地 DNS 服务器进⾏ 查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有 权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此⽹址映射关系，则调⽤这 个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该⽹址映射关系，那 么将根据其设置发起递归查询或者迭代查询；</li><li>TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建⽴链接，发起三次握⼿； </li><li>发送 HTTP 请求：TCP 连接建⽴起来后，浏览器向服务器发送 HTTP 请求； </li><li>服务器处理请求并返回 HTTP 报⽂：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进⾏处 理，并将处理结果及相应的视图返回给浏览器； </li><li>浏览器解析渲染⻚⾯：浏览器解析并渲染视图，若遇到对 js ⽂件、css ⽂件及图⽚等静态资源的引⽤，则᯿复 上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染⻚⾯，最终向⽤户呈现⼀个完整的 ⻚⾯。 </li><li>连接结束。</li></ol><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><blockquote><p>闭上眼睛再背一边</p></blockquote><h2 id="什么握手要三次？"><a href="#什么握手要三次？" class="headerlink" title="什么握手要三次？"></a>什么握手要三次？</h2><p>需要客户端确认服务端的收发能力</p><p>也需要服务端确认客户端的收发能力</p><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><blockquote><p>背</p></blockquote><h2 id="为什么要挥手四次？"><a href="#为什么要挥手四次？" class="headerlink" title="为什么要挥手四次？"></a>为什么要挥手四次？</h2><p>需要确认断开</p><p>这里客户端最后一次发送后会进入TIME_WAIT状态，需要保证服务端收到ACK报文。</p><p>没有收到的话服务端会重新发送FIN报文。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="post与get的区别"><a href="#post与get的区别" class="headerlink" title="post与get的区别"></a>post与get的区别</h3><ol><li><p>使用场景：get获取资源，post传输对象</p></li><li><p>参数：get请求需要编码，post可以用中文。</p></li><li><p>安全性：get是安全的，post不是。</p></li><li><p>幂等性：get是幂等的，post不是。</p></li><li><p>可缓存：</p><ol><li>请求报文方法：get可缓存，post多数情况下不可缓存。</li><li>响应报文状态码：可缓存。</li><li>响应报文的Cache-Control首部字段没有指定不进行缓存。</li></ol></li></ol><h3 id="不同版本的区别"><a href="#不同版本的区别" class="headerlink" title="不同版本的区别"></a>不同版本的区别</h3><ul><li><p>http1.0:不能长连接，只能短连接。打开需要connection:keep-alive;</p></li><li><p>http1.1:可以长连接，多个http请求服务器也只能一个个响应。默认长连接，</p></li><li><p>http2.0:多路复用，把报文分解成更小的二进制帧传送，不用http报文可以混合在一个TCP连接上传输。</p></li></ul><h3 id="与HTTPS的区别"><a href="#与HTTPS的区别" class="headerlink" title="与HTTPS的区别"></a>与HTTPS的区别</h3><ul><li>开销：HTTPS要用到CA申请证书，一般免费证书很少，需要花钱。</li><li>资源消耗：HTTP明文传输；HTTPS加密传输，占用更多CPU和内存。</li><li>端口不同：HTTP80；HTTPS443；</li><li>安全性：HTTP简单的无状态协议；HTTPS是TSL+HTTP进行加密传输、身份认证的网络协议、更安全。</li></ul><h2 id="HTTPS的工作流程"><a href="#HTTPS的工作流程" class="headerlink" title="HTTPS的工作流程"></a>HTTPS的工作流程</h2><ul><li>客户端发送加密规则给服务端告诉服务端要进行连接了。</li><li>服务器重中选出一套加密算法和hash算法以及自己的身份信息一证书的形式发送给浏览器。一般包括：服务器信息、加密公钥、整数的办法机构。</li><li>客户端收到证书后<ul><li>验证证书的合法性</li><li>通过后，生成一串随机数，对证书的公钥进行加密。</li><li>用约定好的hash算法计算握手信息，然后用生成的密钥加密，一起发给服务器。</li></ul></li><li>服务接受到信息后<ul><li>用私钥解析处密码，用密码解析握手信息，验证hash和浏览器发来的是否一致</li><li>使用密钥加密</li></ul></li><li>如果hash一致，握手成功。</li></ul><h2 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h2><p>TCP：</p><ol><li>面向连接的运输层协议：传数据前必须先建立通道。</li><li>一个TCP只能有两个端点，一一映射。</li><li>可靠：不重、不漏、不错、有序。</li><li>双全工通信。</li><li>面向字节流。</li></ol><p>UDP:</p><pre><code>1. 无连接传输层协议1. 尽力而为传输，不可靠。1. 面向报文的，对应用层的报文不合并、不拆分，保留报文边界。1. 没有拥塞机制，不会降低发送效率。1. 可以一对一、一对多、多对多。1. 首部开销小，只有8字节。</code></pre><p>对比：</p><ol><li>TCP可靠，UDP不可靠。</li><li>TCP面向连接，UDP无连接。</li><li>TCP有序，UDP无序。</li><li>TCP不保存数据边界，UDP保存数据边界。</li><li>TCP传输较慢。</li><li>TCP拥有流量控制和拥塞控制，UDP没有。</li><li>TCP比较重量级。</li><li>TCP首部20字节，UDP首部8字节。</li></ol><h2 id="五层网络协议"><a href="#五层网络协议" class="headerlink" title="五层网络协议"></a>五层网络协议</h2><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><ol><li>http</li><li>ftp：文件传输</li><li>smtp：简单邮件传输</li><li>dns：域名系统</li><li>ssh：安全外壳</li><li>dhcp：动态主机配置</li><li>telnet：远程登录</li></ol><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><ol><li>tcp：传输控制协议</li><li>udp：用户数据报文协议</li></ol><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ol><li><p>ip：网际协议</p></li><li><p>arp：地址转换协议</p><blockquote><p>IP与物理地址的映射，如果发送数据包时能找到此映射就直接使用对应MAC地址，否则就直接广播出去。</p></blockquote></li><li><p>rarp：反向地址转换协议</p></li><li><p>icmp：Internet控制报文协议</p></li><li><p>igmp：Internet组管理协议</p></li><li><p>rip：路由信息协议</p></li><li><p>ospf：分布式链路状态协议</p></li><li><p>bgp：边界网关协议</p></li></ol><h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><ol><li>arq：自动重传请求协议</li><li>csma&#x2F;cd：停止等待协议</li><li>ppp：点对点协议</li></ol><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><ol><li>中继器</li><li>集线器</li><li>网线</li><li>HUB</li></ol><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><p>TCP传输时，一个数据包包含了发送端发送的两个数据包信息，就叫粘包。</p><p>具体的可分为发送方粘包和接收方粘包。</p><ul><li>发送方粘包<ul><li>TCP长连接时，当发送数据包过于小时，会启用Nagle算法，将小包和并发送，在缓冲区进行，发送出来就是粘包的。</li></ul></li><li>接收方粘包<ul><li>接收方接到数据，传输层的TCP会将数据包放到缓冲区，然后由应用层来获取。如果这时候应用层读取函数不能及时把缓冲区数据拿出来，那下一个数据又会补充道缓冲区末尾，形成粘包。</li></ul></li><li>如何解决粘包<ul><li>特殊字符控制</li><li>在包头添加数据包的长度</li><li>如果使用netty的话，可以有专门的编码器和解码器来解决这个问题。</li><li>UDP不会有粘包问题，UDP会丢包和乱序。</li></ul></li></ul><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>为了避免数据在传输过程中被替换，⽐如⿊客修改了你的报⽂内容，但是你并不知道，所以我们让发送端做⼀个数 字签名，把数据的摘要消息进⾏⼀个加密，⽐如 MD5，得到⼀个签名，和数据⼀起发送。然后接收端把数据摘要 进⾏ MD5 加密，如果和签名⼀样，则说明数据确实是真的。</p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>对称加密中，双⽅使⽤公钥进⾏解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥 也被替换，则仍然可以伪造数据，因为⽤户不知道对⽅提供的公钥其实是假的。所以为了保证发送⽅的公钥是真 的，CA 证书机构会负责颁发⼀个证书，⾥⾯的公钥保证是真的，⽤户请求服务器时，服务器将证书发给⽤户，这 个证书是经由系统内置证书的备案的。</p><h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><ol><li>sql注入</li><li>xss</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络&quot;&gt;&lt;a href=&quot;#网络&quot; class=&quot;headerlink&quot; title=&quot;网络&quot;&gt;&lt;/a&gt;网络&lt;/h1&gt;&lt;h2 id=&quot;浏览器输入网址到展示内容发生了什么？&quot;&gt;&lt;a href=&quot;#浏览器输入网址到展示内容发生了什么？&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://hideincode.github.io/2024/05/07/basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2024-05-06T18:09:22.555Z</published>
    <updated>2023-09-22T15:04:23.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><blockquote><p>这里主要是<code>linus</code>操作系统</p></blockquote><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul><li>运行</li><li>就绪</li><li>阻塞</li></ul><h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><ul><li>管道</li><li>命名管道</li><li>消息队列</li><li>信号量</li><li>共享内存</li></ul><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul><li>先来先服务</li><li>时间片轮转调度算法</li><li>短时间作业优先</li><li>最短剩余时间优先调度算法</li><li>高响应比优先调度算法</li><li>优先级调度算法</li></ul><p>死锁</p><p>循环占有，A有了拿到锁1，再去拿锁2；B有锁2，去拿锁1；就这样僵住了。</p><ul><li>产生原因：<ul><li>资源竞争，有不可剥夺的资源。</li><li>进程推进不当。</li></ul></li><li>资源分类：<ul><li>可剥夺的资源：某些进程获得这些资源后，这些资源也能被其他进程或系统剥夺，CPU和主存均属于此列。</li><li>不可剥夺的资源：分配给进程后，不可强制回收，只能等进程用完释放。如磁带、打印机。</li></ul></li></ul><h2 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h2><blockquote><p>死锁一定是这样子的，对于哲学家模型就是面只有一份只够一个人，每个人都会拿着自己的筷子不放手，每个人自己的筷子只能在自己用完后放手，形成了环。</p></blockquote><ol><li>互斥条件：进程要求对所分配的资源进⾏排它性控制，即在⼀段时间内某资源仅为⼀进程所占⽤。</li><li>请求和保持条件：当进程因请求资源⽽阻塞时，对已获得的资源保持不放。 </li><li>不剥夺条件：进程已获得的资源在未使⽤完之前，不能剥夺，只能在使⽤完时由⾃⼰释放。 </li><li>环路等待条件：在发⽣死锁时，必然存在⼀个进程–资源的环形链。</li></ol><h2 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h2><ol><li><p>预防</p><ol><li>破坏请求条件：⼀次性分配所有资源，这样就不会再有请求了；</li><li>破坏请保持条件：只要有⼀个资源得不到分配，也不给这个进程分配其他的资源： </li><li>破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源； </li><li>破坏环路等待条件：系统给每类资源赋予⼀个编号，每⼀个进程按编号递增的顺序请求资源，释放则相反。</li></ol></li><li><p>避免</p></li><li><p>检测</p></li><li><p>解除</p><pre><code> 1. 资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程（但应该防⽌被挂起的进程 ⻓时间得不到资源）；  2. 撤销进程：强制撤销部分、甚⾄全部死锁进程并剥夺这些进程的资源（撤销的原则可以按进程优先级和撤销进 程代价的⾼低进⾏）；  3. 进程回退：让⼀个或多个进程回退到⾜以避免死锁的地步。进程回退时⾃愿释放资源⽽不是被剥夺。要求系统 保持进程的历史信息，设置还原点。</code></pre></li></ol><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><ul><li>先进先出队列法</li><li>最佳置换：淘汰未来最远将要使用的页，可以证明缺页数最少。</li><li>LRU</li><li>时钟置换算法：为每个页面设置一个访问位，将内存中的所有页面都通过链接指针链成一个循环队列.</li></ul><h2 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h2><ul><li>内核态：处于内核态的 CPU 可以访问任意的数据，包括外围设备，⽐如⽹卡、硬盘等，处于内核态的 CPU 可以从⼀个程序切换到另外⼀个程序，并且占⽤ CPU 不会发⽣抢占情况，⼀般处于特权级 0 的状态我们称之 为内核态。</li><li>用户态：处于⽤户态的 CPU 只能受限的访问内存，并且不允许访问外围设备，⽤户态下的 CPU 不允许独 占，也就是说 CPU 能够被其他程序获取。</li></ul><h2 id="用户态和内核态之间的切换"><a href="#用户态和内核态之间的切换" class="headerlink" title="用户态和内核态之间的切换"></a>用户态和内核态之间的切换</h2><p>tips:这里并不扎实，还需再看看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这里主要是&lt;code&gt;linus&lt;/code&gt;操作系统&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/basic/%E5%B9%B6%E5%8F%91/"/>
    <id>https://hideincode.github.io/2024/05/07/basic/%E5%B9%B6%E5%8F%91/</id>
    <published>2024-05-06T18:09:22.554Z</published>
    <updated>2023-09-18T06:25:27.941Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/basic/%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%B8%8E%E6%BC%8F%E6%B4%9E/"/>
    <id>https://hideincode.github.io/2024/05/07/basic/%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%B8%8E%E6%BC%8F%E6%B4%9E/</id>
    <published>2024-05-06T18:09:22.553Z</published>
    <updated>2023-10-12T14:41:19.177Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/basic/JVM/"/>
    <id>https://hideincode.github.io/2024/05/07/basic/JVM/</id>
    <published>2024-05-06T18:09:22.552Z</published>
    <updated>2023-09-17T08:44:31.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h1><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><ol><li><p>类加载器</p><blockquote><p>把代码转化成字节码</p></blockquote></li><li><p>运行时数据区</p><blockquote><p>字节码加载到内存</p></blockquote></li><li><p>执行引擎</p><blockquote><p>把字节码翻译成底层指令，交给CPU。</p></blockquote></li><li><p>本地库接口</p><blockquote><p>调用其他语言本地库接口</p></blockquote><h2 id="运行时数据区组成"><a href="#运行时数据区组成" class="headerlink" title="运行时数据区组成"></a>运行时数据区组成</h2></li><li><p>线程共享区</p><ol><li><p>方法区</p><blockquote><p>存储虚拟机加载的类信息、常量、静态变量、编译后的代码。</p><p>别名：非堆。</p><p>不需要连续内存。</p><p>可以不实现垃圾收集。</p><p>会有OOM</p><p>分为运行时常量池、直接内存</p></blockquote></li><li><p>堆</p><blockquote><p>存放对象实例，为对象实例分配内存。</p><p>垃圾收集器管理主要区域，垃圾堆。</p><p>内存空间上逻辑连续即可，会有OOM.</p></blockquote></li></ol></li><li><p>线程私有区</p><ol><li><p>栈</p><blockquote><p>方法执行时的内存模型：方法执行时会创建栈帧，用于变量、操作数、动态链接、方法出口等。方法的调用到完成意味着栈帧在栈中入栈和出栈的过程。</p><p>局部变量表的单位时槽（slot）,在编译器分配完成。</p><p>会有OOM，SOE两种异常。</p></blockquote></li><li><p>本地方法栈</p><blockquote><p>区别于栈：为虚拟机用到的本地方法执行服务。</p></blockquote></li><li><p>程序计数器</p><blockquote><p>字节码的行号指示器，分支、循环跳转、异常处理、线程恢复都依赖于此。唯一一处没有OOM的区域。</p></blockquote></li></ol></li></ol><h2 id="对象大小计算"><a href="#对象大小计算" class="headerlink" title="对象大小计算"></a>对象大小计算</h2><ol><li>空Object是8byte</li><li>Object obj &#x3D; new Object();会占据4 + 8个字节，栈中保存引用也要4byte空间。</li><li>对对象内存分配时都是以 8 的整数倍来分</li><li>boolean 1byte</li></ol><h2 id="对象的定位方式"><a href="#对象的定位方式" class="headerlink" title="对象的定位方式"></a>对象的定位方式</h2><ol><li><p>句柄</p><blockquote><p>引用中存储句柄地址，对象被移动时只会改变句柄中的实例数据指针，引用不用改变。</p></blockquote></li><li><p>指针</p><blockquote><p>速度快，存的是对象的地址。</p></blockquote></li></ol><h2 id="垃圾回收思路"><a href="#垃圾回收思路" class="headerlink" title="垃圾回收思路"></a>垃圾回收思路</h2><ol><li><p>引用计数</p><blockquote><p>每个对象实例都有个引用计数器；</p><p>给对象分配变量时，就将计数器+1；</p><p>同理，引用超过生命周期或者变量被赋新值时，计数器-1；</p><p>计数器为0时实例会被垃圾收集；</p><p>优点：快</p><p>缺点：无法检测循环引用</p></blockquote></li><li><p>可达性分析</p><blockquote><ol><li>当成有向图处理</li><li>从GC Roots对象除法，包括<ol><li>虚拟机栈中引⽤的对象（栈帧中的本地变量表）； </li><li>⽅法区中类静态属性引⽤的对象；  </li><li>⽅法区中常量引⽤的对象；  </li><li>本地⽅法栈中 JNI（Native⽅法）引⽤的对象</li></ol></li></ol></blockquote></li></ol><h2 id="几个内存泄漏的场景"><a href="#几个内存泄漏的场景" class="headerlink" title="几个内存泄漏的场景"></a>几个内存泄漏的场景</h2><ol><li>静态集合类引起的内存泄漏；</li><li>当集合⾥⾯的对象属性被修改后，再调⽤ remove() ⽅法时不起作⽤； </li><li>监听器：释放对象的时候没有删除监听器； </li><li>各种连接：⽐如数据库连接（dataSourse.getConnection()），⽹络连接(socket) 和 IO 连接，除⾮其显式的 调⽤了其 close() ⽅法将其连接关闭，否则是不会⾃动被 GC 回收的；</li><li>内部类：内部类的引⽤是⽐较容易遗忘的⼀种，⽽且⼀旦没释放可能导致⼀系列的后继类对象没有释放； </li><li>单例模式：单例对象在初始化后将在 JVM 的整个⽣命周期中存在（以静态变量的⽅式），如果单例对象持有 外部的引⽤，那么这个对象将不能被 JVM 正常回收，导致内存泄漏</li></ol><h2 id="尽量避免内存泄漏"><a href="#尽量避免内存泄漏" class="headerlink" title="尽量避免内存泄漏"></a>尽量避免内存泄漏</h2><ol><li>尽量不要使用static成员变量，减少生命周期。</li><li>即使关闭资源</li><li>不用的对象考虑手动设置为null</li></ol><h2 id="常见垃圾回收算法"><a href="#常见垃圾回收算法" class="headerlink" title="常见垃圾回收算法"></a>常见垃圾回收算法</h2><ol><li>标记清除 Mark-Sweep<ul><li>从根集合GC Roots扫描，对存活对象进行标记，在扫描所有标记对象进行回收。</li><li>不需要对象的移动</li><li>会造成内存碎片；原因是直接回收了不存活得对象。</li></ul></li><li>复制算法 Copying<ul><li>把堆分成一个对象面和多个空闲面</li><li>在对象面上分配空间，对象面满了后就复制到空闲面，形成对调。</li><li>不会有内存碎片。</li></ul></li><li>标记-整理算法<ul><li>在标记清理的同时将存活对象向左边空闲空间移动</li><li>解决内存碎片问题</li></ul></li><li>分代收集算法<ul><li>堆区域<ul><li>老年代 少量需要回收</li><li>新生代 大量需要回收</li></ul></li><li>永久代</li></ul></li></ol><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><ol><li>年轻代<ol><li>复制为主</li><li>所有新生对象都在新生代</li><li>按照8：1：1分成一个eden区和两个survivor区，大部分对象在eden中生成。</li><li>回收时，先将eden区的复制到survivor0区，然后情况eden区，如果survivor0区满了后，将eden区和0区的复制到survivor1区，然后情空eden和0区，交换0区和1区，如此往复。</li><li>当1区也放不下时，直接放到老年代</li><li>当老年代也放不下的时候，触发一次Full GC，也叫Major GC.</li></ol></li><li>老年代<ol><li>以标记整理为主</li><li>在年轻代中经历多次垃圾回收仍然存活的对象，放入老年代。</li><li>内存比新生代大很多，大概1：2。</li><li>触发Full GC的概率比较低。</li></ol></li></ol><h2 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h2><ol><li>初始标记：记录下直接与 root 相连的对象，暂停所有的其他线程，速度很快； </li><li>并发标记：同时开启 GC 和⽤户线程，⽤⼀个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并 不能保证包含当前所有的可达对象。因为⽤户线程可能会不断的更新引⽤域，所以 GC 线程⽆法保证可达性分 析的实时性。所以这个算法⾥会跟踪记录这些发⽣引⽤更新的地⽅。</li><li>重新标记：重新标记阶段就是为了修正并发标记期间因为⽤户程序继续运⾏⽽导致标记产⽣变动的那⼀部分对 象的标记记录。【这个阶段的停顿时间⼀般会⽐初始标记阶段的时间稍⻓，远远⽐并发标记阶段时间短】；</li><li>并发清除：开启⽤户线程，同时 GC 线程开始对为标记的区域做清扫。 </li><li>优点：并发收集、低停顿</li><li>对CPU资源敏感、无法处理浮动垃圾、使用标记清除会有大量碎片。</li></ol><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><ol><li>力求最优解的收集器</li><li>把堆分成多个region的做法，利用分代的思想，优先处理活跃对象小的。</li></ol><h2 id="使用监控工具调优"><a href="#使用监控工具调优" class="headerlink" title="使用监控工具调优"></a>使用监控工具调优</h2><h3 id="1、堆信息查看"><a href="#1、堆信息查看" class="headerlink" title="1、堆信息查看"></a>1、堆信息查看</h3><ol><li>可查看堆空间⼤⼩分配（年轻代、年⽼代、持久代分配） </li><li>提供即时的垃圾回收功能 </li><li>垃圾监控（⻓时间监控回收情况）</li><li>查看堆内类、对象信息查看：数量、类型等 </li><li>对象引⽤情况查看</li></ol><p>有了堆信息查看⽅⾯的功能，我们⼀般可以顺利解决以下问题： </p><ol><li><p>年⽼代年轻代⼤⼩划分是否合理 </p></li><li><p>内存泄漏</p></li><li><p>圾回收算法设置是否合理</p></li></ol><h3 id="2、线程监控"><a href="#2、线程监控" class="headerlink" title="2、线程监控"></a>2、线程监控</h3><p>线程信息监控：系统线程数量 </p><p>线程状态监控：各个线程都处在什么样的状态下 </p><p>Dump 线程详细信息：查看线程内部运⾏情况</p><p>死锁检查 </p><h3 id="3、-热点分析"><a href="#3、-热点分析" class="headerlink" title="3、 热点分析"></a>3、 热点分析</h3><ol><li>CPU 热点：检查系统哪些⽅法占⽤的⼤量 CPU 时间； </li><li><ol start="2"><li>内存热点：检查哪些对象在系统中数量最⼤（⼀定时间内存活对象和销毁对象⼀起统计）这两个东⻄对于系统 优化很有帮助。我们可以根据找到的热点，有针对性的进⾏系统的瓶颈查找和进⾏系统优化，⽽不是漫⽆⽬的 的进⾏所有代码的优化。</li></ol></li></ol><h3 id="4、快照"><a href="#4、快照" class="headerlink" title="4、快照"></a>4、快照</h3><p>快照是系统运⾏到某⼀时刻的⼀个定格。在我们进⾏调优的时候，不可能⽤眼睛去跟踪所有系统变化，依赖快照功 能，我们就可以进⾏系统两个不同运⾏时刻，对象（或类、线程等）的不同，以便快速找到问题。 举例说，我要检查系统进⾏垃圾回收以后，是否还有该收回的对象被遗漏下来的了。那么，我可以在进⾏垃圾回收 前后，分别进⾏⼀次堆情况的快照，然后对⽐两次快照的对象情况。</p><h3 id="5、内存泄露检查"><a href="#5、内存泄露检查" class="headerlink" title="5、内存泄露检查"></a>5、内存泄露检查</h3><p> 内存泄漏是⽐较常⻅的问题，⽽且解决⽅法也⽐较通⽤，这⾥可以᯿点说⼀下，⽽线程、热点⽅⾯的问题则是具体 问题具体分析了。 内存泄漏⼀般可以理解为系统资源（各⽅⾯的资源，堆、栈、线程等）在错误使⽤的情况下，导致使⽤完毕的资源 ⽆法回收（或没有回收），从⽽导致新的资源分配请求⽆法完成，引起系统错误。内存泄漏对系统危害⽐较⼤，因 为它可以直接导致系统的崩溃</p><h2 id="jvm常见参数设置"><a href="#jvm常见参数设置" class="headerlink" title="jvm常见参数设置"></a>jvm常见参数设置</h2><ol><li><p>堆设置 </p><p>-Xms：初始堆⼤⼩ </p><p>-Xmx：最⼤堆⼤⼩ </p><p>-XX:NewSize&#x3D;n：设置年轻代⼤⼩ -XX:NewRatio&#x3D;n：设置年轻代和年⽼代的⽐值。如:为3，表示年轻代与年⽼代⽐值为 1：3，年轻代占整个年轻代 年⽼代和的 1&#x2F;4 </p><p>-XX:SurvivorRatio&#x3D;n：年轻代中 Eden 区与两个 Survivor 区的⽐值。注意 Survivor 区有两个。如：3，表示 Eden：Survivor&#x3D;3：2，⼀个Survivor区占整个年轻代的 1&#x2F;5 </p><p>-XX:MaxPermSize&#x3D;n：设置持久代⼤⼩ </p></li><li><p>收集器设置 </p><p>-XX:+UseSerialGC：设置串⾏收集器 </p><p>-XX:+UseParallelGC：设置并⾏收集器 </p><p>-XX:+UseParalledlOldGC：设置并⾏年⽼代收集器 </p><p>-XX:+UseConcMarkSweepGC：设置并发收集器 </p></li><li><p>垃圾回收统计信息</p></li></ol><p>   -XX:+PrintGC：开启打印 gc 信息 </p><p>   -XX:+PrintGCDetails：打印 gc 详细信息 </p><p>   -XX:+PrintGCTimeStamps -Xloggc:filename </p><ol start="4"><li>并⾏收集器设置</li></ol><p>   -XX:ParallelGCThreads&#x3D;n：设置并⾏收集器收集时使⽤的 CPU 数 </p><p>   -XX:MaxGCPauseMillis&#x3D;n：设置并⾏收集最⼤暂停时间 </p><p>   -XX:GCTimeRatio&#x3D;n：设置垃圾回收时间占程序运⾏时间的百分⽐ </p><ol start="5"><li>并发收集器设置</li></ol><p>   -XX:+CMSIncrementalMode：设置为增量模式。适⽤于单 CPU 情况 </p><p>   -XX:ParallelGCThreads&#x3D;n：设置并发收集器年轻代收集⽅式为并⾏收集时，使⽤的 CPU 数。并⾏收集线程数</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><blockquote><p>这个名字起的不好，叫父加载委托更合适，难道翻译也是被女权打怕了？</p></blockquote><ol><li>类加载器层级<ol><li>根加载器</li><li>拓展加载器</li><li>系统类加载器</li><li>自定义加载器</li></ol></li><li>一个类收到加载请求后，会先去委派父类加载器完成，逐步往上，如果父类完不成的时候就才会用当前加载器加载。</li><li>好处：最终都由顶端的类加载器进行加载，保证类在多个加载器中都是同一个类。如果每个类使用自己的加载器，确保了类的全局唯一性。</li><li>主要实现看<code>java.lang.ClassLoader </code>的<code>loadClass()</code>⽅法。</li><li>自定义加载，需要继承<code>loadClass() </code>,重写<code>findClass() </code>方法;</li><li>打破双亲委派机制<ol><li>自己写个类加载器</li><li>重写<code>loadClass()</code></li><li>重写<code>findClass()</code></li></ol></li><li>合适打破双亲委派机制？<ol><li>Java 中所有涉及 SPI 的加载动作</li><li>加载核心类库需要用户代码，如JDBC使用<code>DriverManager.getConnection</code>获取连接使用双亲委派就会有问题。</li></ol></li></ol><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><blockquote><p>又称JMM，内存和CPU处理速度不一样，需要高速缓存，多核处理器又会有多个缓存，需要和主存保持一致。而JMM就是为了保证内存访问一致性出现的。</p></blockquote><p>内存行为规范： 关于主内存与⼯作内存之间的具体的交互协议，即：⼀个变量如何从主内存拷⻉到⼯作内存、如何从⼯作内存同步 主内存之类的实现细节，Java内存模型中定义⼀下8种操作来完成：</p><ol><li>lock(锁定)：作⽤于主内存的变量。它把⼀个变量标志为⼀个线程独占的状态； </li><li>unlock(解锁)：作⽤于主内存的变量，它把处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁 定； </li><li>read(读取)：作⽤于主内存的变量，它把⼀个变量的值从主内存传输到线程的⼯作内存中，以便随后的load动 作使⽤； </li><li>load(载⼊)：作⽤于⼯作内存的变量，它把read操作从主内存中得到变量值放⼊⼯作内存的变量的副本中； </li><li>use(使⽤)：作⽤于⼯作内存的变量， 它把⼯作内存中⼀个变量的值传递给执⾏引擎，每当虚拟机遇到⼀个需 要使⽤到变量的值的字节码指令时将会执⾏这个操作； </li><li>assign(赋值)：作⽤于⼯作内存的变量。它把⼀个从执⾏引擎接收到的值赋值给⼯作内存的变量，每当虚拟机 遇到需要给⼀个变量赋值的字节码时执⾏这个操作； </li><li>store(存储)：作⽤于⼯作内存的变量。它把⼀个⼯作内存中⼀个变量的值传递到主内存中，以便随后的write 操作使⽤； </li><li>write(写⼊)：作⽤于主内存的变量。它把store操作从⼯作内存中得到的变量的值放⼊主内存的变量中。 如果要把⼀个变量从⼯作内存复制到⼯作内存，那就要按顺序执⾏ read 和 load 操作，如果要把变量从⼯作内存同 步回主内存，就要按顺序执⾏ store 和 write 操作。</li></ol><p><strong>上诉 8 种基本操作必须满⾜的规则</strong>： </p><ol><li>不允许 read 和 load、store 和 write 操作之⼀单独出现； </li><li>不允许⼀个线程丢弃它的最近的 assign 操作，即变量在⼯作内存中改变之后必须把该变化同步回主内存； </li><li>不允许⼀个线程⽆原因地（没有发⽣过任何 assign 操作）把数据从线程的⼯作内存同步回主内存中； </li><li>⼀个新的变量只能在主内存中“诞⽣”，不允许在⼯作内存中直接使⽤⼀个未被初始化（load 或 assign）的变 量，换句话说就是对⼀个变量实施 use 和 store 操作之前，必须执⾏过了 assign 和 load 操作； </li><li>⼀个变量在同⼀时刻只允许⼀条线程对其进⾏ lock 操作，但 lock 操作可以被同⼀线程᯿复执⾏多次，多次执 ⾏ lock 后，只有执⾏相同次数的 unlock，变量才会被解锁； </li><li>如果对⼀个变量执⾏ lock 操作，将会清空⼯作内存中此变量的值，在执⾏引擎使⽤这个变量前，需要᯿新执 ⾏ load 或 assign 操作初始化变量的值；</li><li>如果⼀个变量事先没有被 lock 操作锁定，则不允许对它执⾏ unlock 操作，也不允许去 unlock ⼀个被其他线 程锁定主的变量； </li><li>对⼀个变量执⾏ unlock 操作之前，必须先把此变量同步回主内存中（执⾏ store 和 write 操作）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java虚拟机&quot;&gt;&lt;a href=&quot;#Java虚拟机&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机&quot;&gt;&lt;/a&gt;Java虚拟机&lt;/h1&gt;&lt;h2 id=&quot;组成部分&quot;&gt;&lt;a href=&quot;#组成部分&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/system/Zookeeper/"/>
    <id>https://hideincode.github.io/2024/05/07/system/Zookeeper/</id>
    <published>2024-05-06T18:09:22.547Z</published>
    <updated>2023-10-12T14:22:58.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><blockquote><p>用于协调分布式组件，包括配置管理、名字服务、分布式锁、集群管理。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Zookeeper&quot;&gt;&lt;a href=&quot;#Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper&quot;&gt;&lt;/a&gt;Zookeeper&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;用于协调分布式组件，包括配置管理、名字服务、分布式锁、集群</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/system/Spring/"/>
    <id>https://hideincode.github.io/2024/05/07/system/Spring/</id>
    <published>2024-05-06T18:09:22.546Z</published>
    <updated>2023-10-12T14:34:43.265Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="为什么Spring"><a href="#为什么Spring" class="headerlink" title="为什么Spring?"></a>为什么Spring?</h2><ol><li>IOC进行松耦合与容器化管理对象，AOP进行业务和系统逻辑分开。</li><li>轻量，几兆而已。</li><li>事务处理能力：本地全局都可以进行统一事物管理。</li><li>异常处理：可以全局捕获运行时异常。</li><li>MVC进行web编程提高生产效率。</li></ol><h2 id="AOP的基本概念"><a href="#AOP的基本概念" class="headerlink" title="AOP的基本概念"></a>AOP的基本概念</h2><ol><li>切⾯（Aspect）：官⽅的抽象定义为“⼀个关注点的模块化，这个关注点可能会横切多个对象”。</li><li>连接点（Joinpoint）：程序执⾏过程中的某⼀⾏为。 </li><li>通知（Advice）：“切⾯”对于某个“连接点”所产⽣的动作。 </li><li>切⼊点（Pointcut）：匹配连接点的断⾔，在 AOP 中通知和⼀个切⼊点表达式关联。</li><li>⽬标对象（Target Object）：被⼀个或者多个切⾯所通知的对象。 </li><li>AOP 代理（AOP Proxy）：在 Spring AOP 中有两种代理⽅式，JDK 动态代理和 CGLIB 代理。</li></ol><h2 id="通知类型有哪些？"><a href="#通知类型有哪些？" class="headerlink" title="通知类型有哪些？"></a>通知类型有哪些？</h2><ol><li><p>前置通知（Before advice）：在某连接点（JoinPoint）之前执⾏的通知，但这个通知不能阻⽌连接点前的执 ⾏。ApplicationContext 中在 aop:aspect ⾥⾯使⽤ aop:before 元素进⾏声明； </p></li><li><p>后置通知（After advice）：当某连接点退出的时候执⾏的通知（不论是正常返回还是异常退出）。 ApplicationContext 中在 aop:aspect ⾥⾯使⽤ aop:after 元素进⾏声明。 </p></li><li><p>返回后通知（After return advice ：在某连接点正常完成后执⾏的通知，不包括抛出异常的情况。 ApplicationContext 中在 aop:aspect ⾥⾯使⽤ &lt;&gt; 元素进⾏声明。</p></li><li><p>环绕通知（Around advice）：包围⼀个连接点的通知，类似 Web 中 Servlet规范中的 Filter 的 doFilter ⽅ 法。可以在⽅法的调⽤前后完成⾃定义的⾏为，也可以选择不执⾏。ApplicationContext 中在 aop:aspect ⾥ ⾯使⽤ aop:around 元素进⾏声明。</p></li><li><p>抛出异常后通知（After throwing advice）：在⽅法抛出异常退出时执⾏的通知。ApplicationContext 中在 a op:aspect ⾥⾯使⽤ aop:after-throwing 元素进⾏声明</p></li></ol><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ol><li>Spring 启动，查找并加载需要被 Spring 管理的 Bean，进⾏ Bean 的实例化； </li><li>Bean 实例化后，对 Bean 的引⼊和值注⼊到 Bean 的属性中； </li><li>如果 Bean 实现了 BeanNameAware 接⼝的话，Spring 将 Bean 的 Id 传递给 setBeanName() ⽅法； </li><li>如果 Bean 实现了 BeanFactoryAware 接⼝的话，Spring 将调⽤ setBeanFactory() ⽅法，将 BeanFactory 容器实例传⼊； </li><li>如果 Bean 实现了 ApplicationContextAware 接⼝的话，Spring 将调⽤ Bean 的 setApplicationContext() ⽅ 法，将 Bean 所在应⽤上下⽂引⽤传⼊进来；</li><li>如果 Bean 实现了 BeanPostProcessor 接⼝，Spring 就将调⽤它们的 postProcessBeforeInitialization() ⽅ 法； </li><li>如果 Bean 实现了 InitializingBean 接⼝，Spring 将调⽤它们的 afterPropertiesSet() ⽅法。类似地，如果 Bean 使⽤ init-method 声明了初始化⽅法，该⽅法也会被调⽤； </li><li>如果 Bean 实现了 BeanPostProcessor 接⼝，Spring 就将调⽤它们的 postProcessAfterInitialization() ⽅ 法； </li><li>此时，Bean 已经准备就绪，可以被应⽤程序使⽤了。它们将⼀直驻留在应⽤上下⽂中，直到应⽤上下⽂被销 毁； </li><li>如果 Bean 实现了 DisposableBean 接⼝，Spring 将调⽤它的 destory() 接⼝⽅法，同样，如果 Bean 使⽤了 destory-method 声明销毁⽅法，该⽅法也会被调⽤。</li></ol><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><ol><li>singleton : 唯⼀ bean 实例，Spring 中的 bean 默认都是单例的； </li><li>prototype : 每次请求都会创建⼀个新的 bean 实例； </li><li>request：每⼀次 HTTP 请求都会产⽣⼀个新的 bean，该 bean 仅在当前 HTTP request 内有效； </li><li>session : 每⼀次 HTTP 请求都会产⽣⼀个新的 bean，该 bean 仅在当前 HTTP session 内有效； </li><li>global-session：全局 session 作⽤域，仅仅在基于 portlet 的 web 应⽤中才有意义，Spring5 已经没有了。 Portlet 是能够⽣成语义代码(例如：HTML)⽚段的⼩型 Java Web 插件。它们基于 portlet 容器，可以像 servlet ⼀样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。</li></ol><h2 id="Spring的事物隔离级别"><a href="#Spring的事物隔离级别" class="headerlink" title="Spring的事物隔离级别"></a>Spring的事物隔离级别</h2><p>TransactionDefinition 接⼝中定义了五个表示隔离级别的常量： <strong>TransactionDefinition.ISOLATION_DEFAULT</strong>：使⽤后端数据库默认的隔离级别，MySQL 默认采⽤的 REPEATABLE_READ 隔离级别 Oracle 默认采⽤的 READ_COMMITTED 隔离级别； TransactionDefinition.ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可 能会导致脏读、幻读或不可᯿复读； <strong>TransactionDefinition.ISOLATION_READ_COMMITTED</strong>：允许读取并发事务已经提交的数据，可以阻⽌脏读，但 是幻读或不可᯿复读仍有可能发⽣； <strong>TransactionDefinition.ISOLATION_REPEATABLE_READ</strong>：对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被 本身事务⾃⼰所修改，可以阻⽌脏读和不可᯿复读，但幻读仍有可能发⽣； </p><p><strong>TransactionDefinition.ISOLATION_SERIALIZABLE</strong>：最⾼的隔离级别，完全服从 ACID 的隔离级别。所有的事务依 次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可᯿复读以及幻读。但是 这将严᯿影响程序的性能。通常情况下也不会⽤到该级别.</p><h2 id="Spring的事物传播行为"><a href="#Spring的事物传播行为" class="headerlink" title="Spring的事物传播行为"></a>Spring的事物传播行为</h2><p>事务传播⾏为是为了解决业务层⽅法之间互相调⽤的事务问题。当事务⽅法被另⼀个事务⽅法调⽤时，必须指定事 务应该如何传播。例如：⽅法可能继续在现有事务中运⾏，也可能开启⼀个新事务，并在⾃⼰的事务中运⾏。在 TransactionDefinition 定义中包括了如下⼏个表示传播⾏为的常量： ⽀持当前事务的情况： <strong>TransactionDefinition.PROPAGATION_REQUIRED</strong>：如果当前存在事务，则加⼊该事务；如果当前没有事务，则 创建⼀个新的事务； <strong>TransactionDefinition.PROPAGATION_SUPPORTS</strong>：如果当前存在事务，则加⼊该事务；如果当前没有事务，则 以⾮事务的⽅式继续运⾏； <strong>TransactionDefinition.PROPAGATION_MANDATORY</strong>：如果当前存在事务，则加⼊该事务；如果当前没有事务， 则抛出异常。 不⽀持当前事务的情况： <strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW</strong>：创建⼀个新的事务，如果当前存在事务，则把当前事务 挂起； <strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</strong>：以⾮事务⽅式运⾏，如果当前存在事务，则把当前事 务挂起。 TransactionDefinition.PROPAGATION_NEVER：以⾮事务⽅式运⾏，如果当前存在事务，则抛出异常。 其他情况： <strong>TransactionDefinition.PROPAGATION_NESTED</strong>：如果当前存在事务，则创建⼀个事务作为当前事务的嵌套事务 来运⾏；如果当前没有事务，则该取值等价于 TransactionDefinition.PROPAGATION_REQUIRED</p><h2 id="循环依赖如何解决？"><a href="#循环依赖如何解决？" class="headerlink" title="循环依赖如何解决？"></a>循环依赖如何解决？</h2><h2 id="MVC执行流程"><a href="#MVC执行流程" class="headerlink" title="MVC执行流程"></a>MVC执行流程</h2><ol><li>⽤户向服务器发送请求，请求被 Spring 前端控制Servelt DispatcherServlet 捕获； </li><li>DispatcherServlet 对请求 URL 进⾏解析，得到请求资源标识符（URI）。然后根据该 URI，调⽤ HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截 器），最后以 HandlerExecutionChain 对象的形式返回； </li><li>DispatcherServlet 根据获得的 Handler，选择⼀个合适的HandlerAdapter；（附注：如果成功获得 HandlerAdapter 后，此时将开始执⾏拦截器的 preHandler(…)⽅法） </li><li>提取 Request 中的模型数据，填充 Handler ⼊参，开始执⾏Handler（Controller)。在填充 Handler 的⼊参 过程中，根据你的配置，Spring 将帮你做⼀些额外的⼯作： （1）HttpMessageConveter：将请求消息（如：Json、xml 等数据）转换成⼀个对象，将对象转换为指定的响应 信息； （2）数据转换：对请求消息进⾏数据转换。如：String 转换成 Integer、Double 等； （3）数据格式化：对请求消息进⾏数据格式化。如：将字符串转换成格式化数字或格式化⽇期等； （4）数据验证：验证数据的有效性（⻓度、格式等），验证结果存储到 BindingResult 或 Error 中; </li><li>Handler 执⾏完成后，向 DispatcherServlet 返回⼀个 ModelAndView 对象； </li><li>根据返回的 ModelAndView，选择⼀个适合的 ViewResolver（必须是已经注册到 Spring 容器中的 ViewResolver)返回给DispatcherServlet； </li><li>ViewResolver 结合 Model 和 View，来渲染视图； </li><li>将渲染结果返回给客户端。</li></ol><h2 id="MVC核心组件"><a href="#MVC核心组件" class="headerlink" title="MVC核心组件"></a>MVC核心组件</h2><ol><li>前端控制器 DispatcherServlet 作⽤：Spring MVC 的⼊⼝函数。接收请求，响应结果，相当于转发器，中央处理器。有了 DispatcherServlet 减 少了其它组件之间的耦合度。⽤户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个 流程控制的中⼼，由它调⽤其它组件处理⽤户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 </li><li>处理器映射器 HandlerMapping 作⽤：根据请求的 url 查找 Handler。HandlerMapping 负责根据⽤户请求找到 Handler 即处理器 （Controller），SpringMVC 提供了不同的映射器实现不同的映射⽅式，例如：配置⽂件⽅式，实现接⼝⽅式，注 解⽅式等。 </li><li>处理器适配器 HandlerAdapter 作⽤：按照特定规则（HandlerAdapter 要求的规则）去执⾏ Handler。通过 HandlerAdapter 对处理器进⾏执 ⾏，这是适配器模式的应⽤，通过扩展适配器可以对更多类型的处理器进⾏执⾏。</li><li>处理器 Handler 注意：编写 Handler 时按照 HandlerAdapter 的要求去做，这样适配器才可以去正确执⾏ Handler。Handler 是继 DispatcherServlet 前端控制器的后端控制器，在 DispatcherServlet 的控制下 Handler 对具体的⽤户请求进⾏处 理。由于 Handler 涉及到具体的⽤户业务请求，所以⼀般情况需要⼯程师根据业务需求开发 Handler。 </li><li>视图解析器 View resolver 作⽤：进⾏视图解析，根据逻辑视图名解析成真正的视图（View ）。View Resolver 负责将处理结果⽣成 View 视 图，View Resolver ⾸先根据逻辑视图名解析成物理视图名即具体的⻚⾯地址，再⽣成 View 视图对象，最后对 View 进⾏渲染将处理结果通过⻚⾯展示给⽤户。SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、 freemarkerView、pdfView 等。⼀般情况下需要通过⻚⾯标签或⻚⾯模版技术将模型数据通过⻚⾯展示给⽤户， 需要由⼯程师根据业务需求开发具体的⻚⾯。 </li><li>视图 View View 是⼀个接⼝，实现类⽀持不同的 View 类型（jsp、freemarker…）。 注意：处理器 Handler（也就是我们平常说的 Controller 控制器）以及视图层 View 都是需要我们⾃⼰⼿动 开发的。其他的⼀些组件⽐如：前端控制器 DispatcherServlet、处理器映射器 HandlerMapping、处理器适 配器 HandlerAdapter 等等都是框架提供给我们的，不需要⾃⼰⼿动开发。</li></ol><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><blockquote><p>优点：</p><ol><li>简化spring配置，自动配置。</li><li>内嵌各种容器，可以直接jar包启动</li><li>通过starter封装各种配置</li><li>避免了maven冲突</li><li>提供了监控服务</li></ol><p>缺点：</p><ol><li>封装太多，排查问题麻烦点。</li></ol></blockquote><h2 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><ol><li>启动加载大量自动配置类</li><li>检查需要的功能有没有在自动配置中</li><li>可以通过properties文件添加组件</li></ol><h2 id="SpringBoot启动流程"><a href="#SpringBoot启动流程" class="headerlink" title="SpringBoot启动流程"></a>SpringBoot启动流程</h2><ol><li>SpringBoot在启动的时候从类路径下的META-INF&#x2F;spring.factories中获取EnableAutoConfiguration指定的 值 </li><li>将这些值作为⾃动配置类导⼊容器 ， ⾃动配置类就⽣效 ， 帮我们进⾏⾃动配置⼯作； </li><li>整个J2EE的整体解决⽅案和⾃动配置都在springboot-autoconfigure的jar包中； </li><li>它会给容器中导⼊⾮常多的⾃动配置类 （xxxAutoConfiguration）, 就是给容器中导⼊这个场景需要的所有组 件 ， 并配置好这些组件 ； 5. 有了⾃动配置类 ， 免去了我们⼿动编写配置注⼊功能组件等的⼯作；</li></ol><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><h2 id="集成定时任务"><a href="#集成定时任务" class="headerlink" title="集成定时任务"></a>集成定时任务</h2><ol><li>配置Quartz</li><li>定义job和trigger即可</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;为什么Spring&quot;&gt;&lt;a href=&quot;#为什么Spring&quot; class=&quot;headerlink</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/system/Redis/"/>
    <id>https://hideincode.github.io/2024/05/07/system/Redis/</id>
    <published>2024-05-06T18:09:22.545Z</published>
    <updated>2023-10-12T14:33:13.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li><p>Strings</p></li><li><p>Hash</p></li><li><p>Lists</p><blockquote><p>粉丝列表,文章评论;基于缓存分页lrange</p></blockquote></li><li><p>Sets</p><blockquote><p>求交并补</p></blockquote></li><li><p>Sorted Sets</p></li></ul><h2 id="缓存与数据库数据一致性问题"><a href="#缓存与数据库数据一致性问题" class="headerlink" title="缓存与数据库数据一致性问题"></a>缓存与数据库数据一致性问题</h2><ol><li><p>CAP 读的时候先读缓存,写时先写库.</p><hr><ul><li><p>问题:如果删除缓存失败,那么就会读到旧数据.</p></li><li><p>解决方案:</p><ul><li>先删除缓存在更新库.</li><li>延时双删,利用队列 DelayQueue MQ</li></ul></li><li><p>高并发情况下的问题：</p><blockquote><p>A线程先删除了缓存，再去改数据，此时B线程读取数据会直接读取数据库旧数据，然后写入缓存。等到A修改完成，那么缓存与库数据不一致情况就会出现。</p></blockquote><p>解决方案，利用jvm本身的队列，进行串行化操作.</p></li></ul></li></ol><h2 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h2><ol><li><p><strong>雪崩</strong>：雪崩指的是大量的缓存失效（一般由于过期），大量查询直接到数据库，导致数据库爆炸。</p><p>预防：利用redis的高可用，就是主从+哨兵，集群；</p><p>正在发生：本地ehcache缓存+hystrix限流降级，避免mysql挂掉；</p><p>事后：redis持久化，之后再去重启redis就直接从磁盘拿数据。</p></li><li><p>穿透：高并发查询缓存和数据库中都没有的数据，例如查询id&#x3D;-1，致使所有的请求都打到数据库，数据库爆炸。因为视缓存为无物，所以叫做穿透。</p><p>解决方案：从数据库中查询不到的值，也要在缓存中设置一个空值，设置一个过期时间。</p><p>如果使用不同的负数查询，那么用布隆过滤器，把所有数据放到布隆hash中，利用布隆过滤器筛选，减少压力；</p></li><li><p><strong>击穿</strong>： 热点数据的key在缓存失效瞬间，全部请求到数据库，导致数据库爆炸。</p><p>解决方案：</p><ul><li><p>对于不怎么更新的数据，设置成永不过期。</p></li><li><p>更新不频繁的，耗时较短的数据，利用分布式锁，让少量请求更新缓存，其余的在锁释放后读取缓存即可；</p></li><li><p>若缓存更新频繁或者耗时较长，利用定时任务在过期前主动重新构建缓存或者延后缓存过期时间，保证所有请求都能访问对应的缓存；</p></li></ul></li></ol><h2 id="Redis并发竞争问题"><a href="#Redis并发竞争问题" class="headerlink" title="Redis并发竞争问题"></a>Redis并发竞争问题</h2><blockquote><p>并发写，由于顺序问题，导致数据出错。利用分布式锁和数据库中的时间戳（更新时间），利用锁一个个写，利用时间戳比对数据是否是最新的。</p></blockquote><h2 id="技术选型为啥用Redis"><a href="#技术选型为啥用Redis" class="headerlink" title="技术选型为啥用Redis"></a>技术选型为啥用Redis</h2><blockquote><p>redis支持复杂的数据结构,相比于memcached,redis支持集群,数据量多的情况下,还是redis更好用.redis内部使用文件事件处理器.比较复杂,todo</p></blockquote><h2 id="为啥单线程的redis这么快"><a href="#为啥单线程的redis这么快" class="headerlink" title="**为啥单线程的redis这么快 **"></a>**为啥单线程的redis这么快 **</h2><ol><li>纯内存操作</li><li>基于非阻塞的IO多路复用机制</li><li>采用了C语言这种更加接近底层的语言</li><li>单线程避免了多线程的上下文频繁切换.也不会出现redis本身的资源竞争问题.</li></ol><h2 id="redis是有多线程的-自6-0以后"><a href="#redis是有多线程的-自6-0以后" class="headerlink" title="redis是有多线程的,自6.0以后"></a><strong>redis是有多线程的,自6.0以后</strong></h2><blockquote><p>因为某些方面,单线程已经没有太大优势了,读写网络的Read和Write系统在调用redis执行期间占用了大部分cpu时间,这种地方使用多线程对性能更友好.</p></blockquote><h2 id="redis的过期策略"><a href="#redis的过期策略" class="headerlink" title="redis的过期策略"></a>redis的过期策略</h2><ol><li><p>定期删除+惰性删除</p><blockquote><p>每过100ms就随机抽查一部分<code>设置了过期时间</code>的key,如果过期就删除;</p><p>查询key的时候也会检查,如果key已经过期,那么直接删除;</p><p><strong>此时大量过期key堆积,导致内存不够用,该如何是好</strong></p><p>答案:内存淘汰机制</p></blockquote><p>​2. Redis 内存淘汰机制有以下几个：</p></li></ol><ul><li><p>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。</p></li><li><p><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，移除最近最少使用的 key（这个是<strong>最常用</strong>的）。</p></li><li><p>allkeys-random：当内存不足以容纳新写入数据时，在<strong>键空间</strong>中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。</p></li><li><p>volatile-lru：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，移除最近最少使用的 key（这个一般不太合适）。</p></li><li><p>volatile-random：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，<strong>随机移除</strong>某个 key。</p></li><li><p>volatile-ttl：当内存不足以容纳新写入数据时，在<strong>设置了过期时间的键空间</strong>中，有<strong>更早过期时间</strong>的 key 优先移除。</p><p> <strong>考点: LRU算法</strong></p></li></ul><h3 id="Redis通过哨兵集群实现高可用"><a href="#Redis通过哨兵集群实现高可用" class="headerlink" title="Redis通过哨兵集群实现高可用"></a>Redis通过哨兵集群实现高可用</h3><ul><li>集群监控：负责监控 Redis master 和 slave 进程是否正常工作。</li><li>消息通知：如果某个 Redis 实例有故障，那么哨兵负责发送消息作为报警通知给管理员。</li><li>故障转移：如果 master node 挂掉了，会自动转移到 slave node 上。</li><li>配置中心：如果故障转移发生了，通知 client 客户端新的 master 地址。</li></ul><p>哨兵本身也是分布式的,可以做集群部署.</p><ul><li>故障转移需要大部分的哨兵同意.</li><li>哨兵至少需要三个实例.</li><li>哨兵+Redis的主从部署,不保证数据零丢失,只能保证Redis集群的高可用.</li><li>复杂部署架构,需要在测试环境和生产环境做够充足演练.</li></ul><h3 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h3><blockquote><ul><li>RDB持久化机制,对Redis中的数据执行周期性的持久化</li><li>AOF记录日志,类似于Mysql的binlog,追加的形式到日志文件,重启时通过回放日志文件来重新构建数据集.</li></ul></blockquote><p><strong>RDB优缺点</strong></p><ul><li>会生成多个文件,适合存储云端服务器做冷备份.</li><li>对redis的对外读写影响很小,让redis保持高性能.</li><li>比AOF更快的持久化</li><li>由于周期型的,所以数据完整性不如AOF.</li><li>持久化的文件特别大时,会导致对客户端的服务暂停数毫秒到几秒.</li></ul><p><strong>AOF优缺点</strong></p><ul><li>数据完整性更可靠</li><li>写入性能高,直接追加.</li><li>日志文件过大也不会影响客户端的使用.</li><li>利用可读性较强的方式记录,适合做灾难性误删除的恢复.</li><li>开启后,支持写redis操作的QPS会降低</li><li>出现数据丢失</li></ul><p>可以同时开启两者。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/system/MQ/"/>
    <id>https://hideincode.github.io/2024/05/07/system/MQ/</id>
    <published>2024-05-06T18:09:22.536Z</published>
    <updated>2023-10-12T14:28:36.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h1><blockquote><p>当碰到需要解耦、异步、削峰问题时，那么就使用MQ吧。</p></blockquote><h2 id="常见的MQ"><a href="#常见的MQ" class="headerlink" title="常见的MQ"></a>常见的MQ</h2><p><strong>ActiveMQ</strong>：支持万级的吞吐量，较成熟完善；官方更新迭代较少，社区的活跃度不是很高，有消息丢失的情况。</p><p><strong>RabbitMQ</strong>：延时低，微妙级延时，社区活跃度高，bug 修复及时，而且提供了很友善的后台界面；用 Erlang 语言开发，只熟悉 Java 的无法阅读源码和自行修复 bug。</p><p><strong>RocketMQ</strong>：阿里维护的消息中间件，可以达到十万级的吞吐量，支持分布式事务。</p><p><strong>Kafka</strong>：分布式的中间件，最大优点是其吞吐量高，一般运用于大数据系统的实时运算和日志采集的场景，功能简单，可靠性高，扩展性高；缺点是可能导致重复消费。</p><h2 id="MQ处理消息时容易遇到的问题"><a href="#MQ处理消息时容易遇到的问题" class="headerlink" title="MQ处理消息时容易遇到的问题"></a>MQ处理消息时容易遇到的问题</h2><ul><li>消息丢失<ul><li>RabbitMQ<ul><li>生产者：<ul><li>开启事务（不推荐）</li><li>开启confirm模式（推荐）</li></ul></li><li>MQ：开启持久化</li><li>消费者：<ul><li>关闭自动ACK</li></ul></li></ul></li><li>Kafka<ul><li>生产者：设置acks&#x3D;all，数据一定不丢</li><li>MQ：？？</li><li>消费者：Kafka会自动offset，可以关闭offset，使用手动提交offset，保证数据不会丢。</li></ul></li></ul></li><li>消息幂等<ul><li>写数据时先根据主键查询数据是否存在，存在则更新。</li><li>利用数据库的唯一键索引。</li><li>如果是redis，那么redis的set天然支持去重幂等。</li></ul></li><li>消息顺序性<ul><li>RabbitMQ：拆分成多个Queue，每个Queue一个Consumer，然后Consumer内部用内存队列做排队，分发给底层不同的Worker处理。</li><li>Kafka：写N个内存Queue，具有相同key的数据进入到同一个Queue；对于N个线程，每个线程消费一个内存Queue，保证了顺序性。</li></ul></li><li>消息积压<ul><li>先修复consumer，保证消费速度，然后停掉consumer;</li><li>新建个topic，partion设置为原来10倍，临时建立原来10倍的queue。</li><li>写一个临时分发数据的consumer，用这个程序去消费积压数据，把数据轮询写入临时建好的10倍queue；</li><li><strong>10倍机器部署consumer</strong>，每一批consumer消费一个queue，相当于把queue资源和consumer资源扩大10倍，以原来10倍速度消费；</li><li>等消费完积压的数据，恢复原来结构，正常消费。</li></ul></li><li>消息失效<ul><li>把丢失的消息查出来，重新导入MQ。</li></ul></li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><ul><li>如何高可用<ul><li>RabbitMQ：镜像集群模式，队列的消息会分布在多个机器上，写消息时就会跟多个队列进行通讯。这样任意一个宕机都不影响系统。问题在于开销太大，拓展性差。</li><li>Kafka：partition和replica机制，每个节点都是一个broker，一个topic可以分成多个partition，partition可以存在多个broker上，也就是说一个topic的消息是分在多个机器上的。0.8版本后提供了HA机制，即replica副本机制。每个partition数据都会同步到其他机器，形成多个副本。然后所有的replica选举一个leader，生产消费都和这个leader打交道，其他的replica就是follower。写的时候leader会把数据同步到所有的follower上去，读的时候直接读leader上的数据。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MQ&quot;&gt;&lt;a href=&quot;#MQ&quot; class=&quot;headerlink&quot; title=&quot;MQ&quot;&gt;&lt;/a&gt;MQ&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;当碰到需要解耦、异步、削峰问题时，那么就使用MQ吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;常见的M</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/system/MyBatis/"/>
    <id>https://hideincode.github.io/2024/05/07/system/MyBatis/</id>
    <published>2024-05-06T18:09:22.536Z</published>
    <updated>2023-09-18T09:57:24.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><blockquote><ol><li>半自动ORM框架，对JDBC进行了封装。</li><li>使用xml&#x2F;注解进行配置和映射。</li><li>灵活编写SQL，不用与代码耦合。</li><li>兼容各种数据库。</li><li>提供了映射标签。</li><li>但是SQL编写量变大，多表时麻烦；SQL语句以来数据库，不好随便换库。</li><li>不要用RowBounds进行分页，这是个内存分页。</li></ol></blockquote><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><ol><li><p>一级缓存：基于 PerpetualCache 的 HashMap 本地缓存，其存储作⽤域为 Session，当 Session flush 或 close 之 后，该 Session 中的所有 Cache 就将清空，默认打开⼀级缓存；</p></li><li><p>二级缓存：与⼀级缓存其机制相同，默认也是采⽤ PerpetualCache，HashMap 存储，不同在于其存储作⽤域为 Mapper(Namespace)，并且可⾃定义存储源，如 Ehcache。默认不打开⼆级缓存，要开启⼆级缓存，使⽤⼆级缓 存属性类需要实现 Serializable 序列化接⼝(可⽤来保存对象的状态)，可在它的映射⽂件中配。</p></li><li><p>对于缓存数据更新机制，当某⼀个作⽤域(⼀级缓存 Session &#x2F; ⼆级缓存 Namespaces)的进⾏了 C&#x2F;U&#x2F;D 操作后，默 认该作⽤域下所有 select 中的缓存将被 clear。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mybatis&quot;&gt;&lt;a href=&quot;#Mybatis&quot; class=&quot;headerlink&quot; title=&quot;Mybatis&quot;&gt;&lt;/a&gt;Mybatis&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;半自动ORM框架，对JDBC进行了封装。&lt;/li&gt;
&lt;li&gt;使</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hideincode.github.io/2024/05/07/system/Mysql/"/>
    <id>https://hideincode.github.io/2024/05/07/system/Mysql/</id>
    <published>2024-05-06T18:09:22.536Z</published>
    <updated>2023-09-25T14:06:21.238Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><blockquote><p>伟大滴麦色可友，养活互联网企业的神器。</p></blockquote><h2 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><ul><li>server层<ul><li>连接器：管理链接，权限验证</li><li>查询缓存：命中直接返回</li><li>分析器：词法分析，语法分析</li><li>优化器：执行计划生成，索引选择</li><li>执行器：操作引擎，返回结果</li></ul></li><li>引擎层：操作引擎，返回结果。</li></ul><h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo-log"></a>redo-log</h3><ul><li>WAL：Write-Ahead Logging</li><li>crash-safe</li><li>innodb</li><li>物理日志：在数据页上做的修改</li><li>循环写</li></ul><h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin-log"></a>bin-log</h3><ul><li>server层，意味着所有引擎可以用</li><li>逻辑日志：语句原始逻辑，给ID&#x3D;2的字段c加1</li><li>追加写</li></ul><h3 id="两段式提交"><a href="#两段式提交" class="headerlink" title="两段式提交"></a>两段式提交</h3><ol><li>redolog进入prepare </li><li>写入binlog</li><li>提交事务</li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><ul><li><p>为什么选B+树？</p><ul><li>选了B+而不用B树，是因为B树在每个节点都存储数据，而B+树只会在叶子节点存储数据，所以B树IO会更频繁；数据库的索引是存在磁盘上的，当数据量大时，就不能全部加载到内存，只能逐一加载。</li></ul></li><li><p>基于B树实现，具有B树的平衡性；</p></li><li></li></ul><h3 id="索引特性"><a href="#索引特性" class="headerlink" title="索引特性"></a>索引特性</h3><ul><li>回表</li><li>索引覆盖</li><li>最左前缀原则</li><li>索引下推</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ol><li><p>原子性(Atomicity)</p><p>事务的所有操作只有成功和失败,操作期间不会去对数据库数据进行增删改操作,只记录操作,只有commit后才会去修改数据库的数据.事务失败就会rollback,数据不会有任何变化.</p></li><li><p>一致性（Consistency）</p><p>会话的双方要同时进行的DML操作,使得事务执行后数据库从一个一致性状态变到另一个一致性状态.</p></li><li><p>隔离性（Isolation）</p><p>事务之间是相互独立的两个对象,可以设置不同的隔离级别.</p></li><li><p>持久性（Durability）</p><p>事务终结的标志,提交后的事务将会永久性改变数据库的数据.</p></li></ol><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ol><li><p>read uncommitted -&gt;脏读</p><blockquote><p>这种隔离级别下 两个事务A B,A 没有提交数据 ,B 读到了A没有commit的数据(事务A正在操作的数据),这种数据叫做dirty data,这种行为叫做dirty read,一般只在理论上存在;</p></blockquote></li><li><p>read committed -&gt; 不可重复度</p><blockquote><p>两个事务A B,A提交数据,B就读到A的数据,这种隔离级别的缺点就是不可重复度,即会话双方一方修改,一方读取,总是读取不到正确数据.<br>不可重复读的重点是修改.</p></blockquote></li><li><p>repeatable read -&gt; 幻读</p><blockquote><p>看这名字就知道就是来解决无法重复读的问题的.事务A开始时,不管事务BCD修改数据还是提交事务,都不会改变A读取的数据.<br>幻读:幻读是指当事务不是独立执行时发生的一种现象.事务A读取与搜索条件相匹配的若干行。<br>事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。这时候事务A的用户发现表中还存在没有修改的数据行,就像出现了幻觉一样.</p></blockquote></li><li><p>serializable -&gt; 效率低</p><blockquote><p>不会出现上述问题,但由于进行了锁表操作,所以会降低吞吐量.<br>解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表.</p></blockquote></li></ol><p></p><h3 id="隔离的原理"><a href="#隔离的原理" class="headerlink" title="隔离的原理"></a>隔离的原理</h3><p>多版本并发控制MVCC</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><ul><li>一般全库逻辑备份时会用到</li><li>FlushTablesWithReadLock：库进入只读，阻塞DML，DDL，未提交的更新事务。故障时会释放锁。</li><li>set global readlonly&#x3D;true：用于主备库判断，故障时数据库不会释放锁。</li></ul><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><ul><li>lock tables … read&#x2F;write 客户端断开自动释放</li><li>元数据锁：metadata lock：访问表时自动开启，修改表结构时加MDL锁；</li><li>给小表安全加字段：<ul><li>kill长事务</li><li>alter table语句加等待时间，过期放弃。</li></ul></li></ul><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><ul><li>innodb特有</li><li>死锁与死锁检测：<ul><li>循环依赖导致</li><li>等到超时：innodb_lock_wait_timeout</li><li>主动检测：innodb_deadlock_detect&#x3D;on，缺点影响性能。</li><li>减小主动检测的性能影响：<ul><li>控制并发度，一行只能十个线程，但是客户端过多还是不行。</li><li>设计层面优化，把记录拆分多条，然后算多个记录的和。</li></ul></li></ul></li></ul><h2 id="常见表结构设计"><a href="#常见表结构设计" class="headerlink" title="常见表结构设计"></a>常见表结构设计</h2><h3 id="表设计三大范式"><a href="#表设计三大范式" class="headerlink" title="表设计三大范式"></a>表设计三大范式</h3><blockquote><p>范式只是一种参考，实际生产要考虑索引问题、联表查询效率问题。</p></blockquote><ol><li><p>列不可分</p><ul><li>一列不可有两种属性</li><li>比如地址可分为省、市、区三个字段</li></ul></li><li><p>在范式1的基础上，所有的非主键字段要<strong>完全依赖</strong>主键，不是依赖主键的某一部分（针对联合主键）</p><ul><li><p>出现了<strong>多对多</strong>关系</p></li><li><p>例如一张表存学生和课程</p><ul><li>新增一个学生，该学生还没有选课，因此就不能新增。新增老师同理。</li></ul></li><li><p>一个表只描述一件事情</p></li></ul></li><li><p>在范式2基础上，所有非主键字段和主键字段<strong>没有传递依赖</strong></p><ul><li>出现<strong>一对多</strong>关系</li><li>例如一张表存老师和学生<ul><li>修改老师职称时要改很多数据（修改一影响多）</li><li>没人选该老师课程时，该老师职称记录会被删除。（多没了代表了一也没了，不合理）</li><li>新老师还没指定职称，那么职称不知如何保存。</li></ul></li><li>一对多出现时考虑：一和多分成两张表，多表存一表主键，</li></ul></li></ol><h2 id="SQL命令使用常识"><a href="#SQL命令使用常识" class="headerlink" title="SQL命令使用常识"></a>SQL命令使用常识</h2><ul><li>count：count(字段)&lt;count(id)&lt;count(1)约等count(*)</li><li>order by：<ul><li>sort_buffer_size：排序内存大小，如果太小就利用临时文件排序。</li><li>rowid排序：如果要返回字段过多，只取出排序字段。</li><li>如果内存够，就用内存排序。</li></ul></li><li>join:<ul><li>正确选择驱动表，驱动表走全表扫描，被驱动表走数索引。</li><li>使用join语句，性能比强行拆成多个单表执行SQL语句的性能好。</li><li>如果使用join，需要使用小表做驱动。</li></ul></li></ul><h2 id="常见疑难杂症"><a href="#常见疑难杂症" class="headerlink" title="常见疑难杂症"></a>常见疑难杂症</h2><ul><li><p>普通索引和唯一索引怎么选？</p><ul><li><p>读：区别不大</p></li><li><p>写：</p><ul><li>change buffer：缓存更新操作，唯一索引不能用，只有普通索引可以用。如果更新后马上查询，不要用这个。redolog节省随机写磁盘的io消耗，changebuffer节省对应读的io消耗。</li><li>唯一索引：判断冲突</li><li>普通索引：更新记录在changebuffer</li></ul></li></ul></li><li><p>怎么给字符串加索引？</p></li><li><p>mysql为什么会抖一下？</p><ul><li>内存脏页：内存数据和磁盘数据不一样时，内存页就是脏页。</li></ul></li><li><p>为什么表数据删除一半，表文件大小不变？</p><ul><li>delete结果不会变，alter table才会改变。</li></ul></li><li><p>为什么逻辑相同的语句，性能缺差异巨大？</p><ul><li><p>条件字段函数操作</p></li><li><p>隐式类型转换</p></li><li><p>隐式字符编码转换</p></li></ul></li><li><p>查一行也很慢？</p><ul><li>查询长时间不返回：锁表了，通过show processlist查看状态。</li><li>等DML锁：show processlist查看wait for table metadata lock</li><li>等flush</li></ul></li><li><p>幻读有什么问题吗？</p></li><li><p>鸩止渴的提高性能？</p><ul><li><p>先处理占着链接但是不工作的线程</p></li><li><p>减少链接过程的消耗</p></li><li><p>慢查询性能问题</p><ul><li>索引没有设计好</li><li>语句没写好</li></ul></li><li><p>QPS突增问题</p></li></ul></li><li><p>如何保证数据不丢？</p><ul><li><p>binglog写入机制</p></li><li><p>redolog写入机制</p></li></ul></li><li><p>保证主备一致？</p></li><li><p>涉及到binlog可选</p><ul><li>statement</li><li>row</li><li>mixed</li></ul></li><li><p>怎么保证高可用？</p><ul><li><p>主备延迟</p><ul><li><p>备库机器差劲</p></li><li><p>备库压力大</p></li><li><p>大事务</p></li></ul></li><li><p>可靠性优先策略</p></li></ul></li><li><p>备库为什么会延迟几个小时？</p><ol><li><p>5.5版本并行复制策略</p><ol><li>按表分发</li><li>按行分发</li></ol></li><li><p>5.7并行复制策略</p></li><li><p>5.7.22并行复制策略</p></li></ol></li><li><p>主库出问题，从库怎么办？</p><ol><li><p>基于位点的主备切换</p></li><li><p>基于GTID的主备切换</p></li></ol></li><li><p>读写分离有哪些坑？</p></li></ul><ol><li>主备延迟导致的读写分离<ol><li>强制走主库</li><li>sleep</li><li>判断主备无延迟<ol><li>通过seconds_behind_master</li><li>位点比对</li><li>GTID</li></ol></li><li>semi-sync半同步复制</li></ol></li></ol><ul><li><p>判断数据库是不是出问题？</p><ol><li><p>select 1</p></li><li><p>查表判断</p></li><li><p>更新判断</p></li><li><p>内部统计</p></li></ol></li><li><p>误删数据怎么办？</p><ol><li><p>删除行</p></li><li><p>删除库&#x2F;表</p></li></ol></li><li><p>为什么有些命令kill不掉？</p><ol><li><p>kill query + 线程id</p></li><li><p>kill connection + 线程id</p></li><li><p>关于客户端的误解：表多就慢</p></li></ol></li><li><p>查大量数据会不会打爆内存？</p><ol><li><p>全表扫描对server层影响：先装net_buffer，满了就输出，边读边发。</p></li><li><p>全表扫描对innodb的影响</p></li></ol></li><li><p>为什么临时表可以重名？</p><ol><li><p>create temporary table 创建临时表</p></li><li><p>创建的临时表只能被当前session访问</p></li><li><p>可以与普通表重名，优先访问临时表，show tables不显示临时表。</p></li></ol></li><li><p>何时会用到临时表？</p><ol><li><p>union执行流程</p></li><li><p>group by</p></li></ol></li><li><p>innodb虽然厉害，那么memory还用不用？</p><ol><li><p>innodb索引组织表</p><ol><li>有序存放</li><li>有空位也会写入新位置</li><li>数据位置变化只要修改主键索引</li><li>通过主键就一次，普通索引要两次</li></ol></li><li><p>memory堆组织表</p><ol><li>按照写入顺序存放<ol><li>有空位就插入</li><li>位置变化要修改所有索引</li><li>查找时一视同仁</li></ol></li></ol></li></ol></li><li><p>怎么快速复制一张表？</p><ol><li><p>sqldump方法：生成包含insert语句的方法，可以在where参数里面加过滤，不能join</p></li><li><p>导出csv</p></li><li><p>物理拷贝：最快、必须全表拷贝、需要到机器上拷贝，在用户登录数据库的场景下无法使用，都得是innodb</p></li></ol></li><li><p>grant之后要跟着flushprivileges吗？</p></li><li><p>要不要分区分表？</p></li><li><p>自增ID用完怎么办？</p><ol><li><p>表定义自增id：用完会冲突，可以增加范围biginit unsigned。</p><ol><li><p>innodb系统自增row_id：</p><ol><li>不显示指定主键时，系统隐式自带。</li><li>用完就会重零开始覆盖</li></ol></li><li><p>xid</p><ol><li>作用于事务：这是redo log和binglog配合使用的id</li><li>不要在binlog重复</li></ol></li></ol></li><li><p>innodb trx_id：每次随着mysql重启会被保存起来。</p></li><li><p>thread_id</p></li></ol></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>初始化SQL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists dept;</span><br><span class="line">drop table if exists salgrade;</span><br><span class="line">drop table if exists emp; </span><br><span class="line">create table dept(</span><br><span class="line">    deptno int(10) primary key,</span><br><span class="line">    dname varchar(14),</span><br><span class="line">    loc varchar(13)</span><br><span class="line">);</span><br><span class="line">create table salgrade(</span><br><span class="line">    grade int(11),</span><br><span class="line">    losal int(11),</span><br><span class="line">    hisal int(11)</span><br><span class="line">);</span><br><span class="line">create table emp(</span><br><span class="line">    empno int(4) primary key,</span><br><span class="line">    ename varchar(10),</span><br><span class="line">    job varchar(9),</span><br><span class="line">    mgr int(4),</span><br><span class="line">    hiredate date,</span><br><span class="line">    sal double(7,2),</span><br><span class="line">    comm double(7,2),</span><br><span class="line">    deptno int(2)</span><br><span class="line">);</span><br><span class="line">insert into dept(deptno,dname,loc) values(10,&#x27;ACCOUNTING&#x27;,&#x27;NEW YORK&#x27;);</span><br><span class="line">insert into dept(deptno,dname,loc) values(20,&#x27;RESEARCHING&#x27;,&#x27;DALLAS&#x27;);</span><br><span class="line">insert into dept(deptno,dname,loc) values(30,&#x27;SALES&#x27;,&#x27;CHICAGO&#x27;);</span><br><span class="line">insert into dept(deptno,dname,loc) values(40,&#x27;OPERATIONS&#x27;,&#x27;BOSTON&#x27;); </span><br><span class="line"></span><br><span class="line">insert into salgrade(grade,losal,hisal) values(1,700,1200);</span><br><span class="line">insert into salgrade(grade,losal,hisal) values(2,1201,1400);</span><br><span class="line">insert into salgrade(grade,losal,hisal) values(3,1401,2000);</span><br><span class="line">insert into salgrade(grade,losal,hisal) values(4,2001,3000);</span><br><span class="line">insert into salgrade(grade,losal,hisal) values(5,3001,5000); </span><br><span class="line"></span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7369,&#x27;SIMITH&#x27;,&#x27;CLERK&#x27;,7902,&#x27;1980-12-17&#x27;,800,null,20);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7499,&#x27;ALLEN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-02-20&#x27;,1600,300,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7521,&#x27;WARD&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-02-22&#x27;,1250,500,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7566,&#x27;JONES&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-04-02&#x27;,2975,null,20);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7654,&#x27;MARTIN&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-09-28&#x27;,1250,1400,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7698,&#x27;BLAKE&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-05-01&#x27;,2850,null,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7782,&#x27;CLARK&#x27;,&#x27;MANAGER&#x27;,7839,&#x27;1981-06-09&#x27;,2450,null,10);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7788,&#x27;SCOTT&#x27;,&#x27;ANALYST&#x27;,7566,&#x27;1987-04-19&#x27;,3000,null,20);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7839,&#x27;KING&#x27;,&#x27;PRESIDENT&#x27;,null,&#x27;1981-11-17&#x27;,5000,null,10);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7844,&#x27;TURNER&#x27;,&#x27;SALESMAN&#x27;,7698,&#x27;1981-09-08&#x27;,1500,null,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7876,&#x27;ADAMS&#x27;,&#x27;CLERK&#x27;,7788,&#x27;1987-05-23&#x27;,1100,null,20);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7900,&#x27;JAMES&#x27;,&#x27;CLERK&#x27;,7698,&#x27;1981-12-03&#x27;,950,null,30);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7902,&#x27;FORD&#x27;,&#x27;ANALYST&#x27;,7566,&#x27;1981-12-03&#x27;,3000,null,20);</span><br><span class="line">insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)values(7934,&#x27;MILLER&#x27;,&#x27;CLERK&#x27;,7782,&#x27;1982-01-23&#x27;,1300,null,10);</span><br></pre></td></tr></table></figure><ol><li><p>每个部门薪水最高的人员名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.ename NAME,</span><br><span class="line">t.maxsal,</span><br><span class="line">d.dname deptname </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">JOIN ( SELECT deptno, max( sal ) maxsal FROM emp GROUP BY deptno ) t ON t.deptno = e.deptno </span><br><span class="line">AND t.maxsal = e.sal</span><br><span class="line">JOIN dept d ON t.deptno = d.deptno;</span><br></pre></td></tr></table></figure></li><li><p>薪水在部门平均水平以上的人</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">e.ename name,e.deptno,e.sal</span><br><span class="line">from </span><br><span class="line">emp e join (select deptno,avg(sal) avgsal from emp group by deptno) t </span><br><span class="line">on e.sal &gt; t.avgsal and t.deptno=e.deptno;</span><br></pre></td></tr></table></figure></li><li><p>取得部门中的平均薪水等级(所有人)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">t.deptno deptno,s.grade grade </span><br><span class="line">from </span><br><span class="line">(select deptno, avg(sal) avgsal from emp group by deptno) t join salgrade s on t.avgsal between losal and hisal;</span><br></pre></td></tr></table></figure></li><li><p>取得部门中所有人的薪水等级,并对部门薪水等级求平均</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t.dept, avg(t.grade) avg_grade from (select e.deptno dept,e.ename name,e.sal salary,s.grade grade from emp e join salgrade s on e.sal between s.losal and hisal) t group by t.dept;</span><br></pre></td></tr></table></figure><p>也可以</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select e.deptno dept,avg(s.grade) from emp e join salgrade s on e.sal between s.losal and hisal group by e.deptno;</span><br></pre></td></tr></table></figure></li><li><p>不用聚合函数max,取得最高薪水,使用两种方法解决</p><ol><li><code>select ename,sal from emp order by sal desc limit 1;</code></li><li><code>select sal from emp where sal not in (select distinct a.sal sal_a from emp a join emp b on a.sal &lt; b.sal);</code></li></ol></li><li><p>取得平均薪水最高的部门的部门编号(2种方案)</p><blockquote><p>可能有相等数据,取第一个可能会错误,所以要根据deptno找到重复的max</p></blockquote><ol><li><pre><code class="mysql">select     deptno,avg(sal) as avgsalfrom     emp group by     deptnohaving     avg(sal) = (select avg(sal) avgsal from emp group by deptno order by avgsal desc limit 1);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 聚合函数max</span><br><span class="line"></span><br><span class="line">   ```mysql</span><br><span class="line">   select </span><br><span class="line">   deptno,avg(sal) avgsal</span><br><span class="line">   from </span><br><span class="line">   emp</span><br><span class="line">   group by </span><br><span class="line">   deptno</span><br><span class="line">   having</span><br><span class="line">   avg(sal) = (select max(t.avgsal) from (select deptno,avg(sal) avgsal from emp group by deptno ) t);</span><br></pre></td></tr></table></figure></code></pre></li></ol></li><li><p>取得平均薪水最高的部门的部门名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">select </span><br><span class="line">d.dname,m.avgsal</span><br><span class="line">from</span><br><span class="line">dept d</span><br><span class="line">join </span><br><span class="line">(select </span><br><span class="line">deptno,avg(sal) avgsal</span><br><span class="line">from </span><br><span class="line">emp</span><br><span class="line">group by </span><br><span class="line">deptno</span><br><span class="line">having</span><br><span class="line">avg(sal) = (select max(t.avgsal) from (select deptno,avg(sal) avgsal from emp group by deptno ) t)) m</span><br><span class="line">on m.deptno=d.deptno;</span><br></pre></td></tr></table></figure></li><li><p>求平均薪水的等级最高的部门名称</p></li><li><p>求各个部门平均薪水的等级(结果只有部门名称.平均薪水,等级三个字段)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select t.avgsal,s.grade,t.dname from </span><br><span class="line">(select d.dname dname,avg(e.sal) avgsal from emp e join dept d on e.deptno=d.deptno group by dname) t</span><br><span class="line">join salgrade s</span><br><span class="line">on t.avgsal between s.losal and s.hisal;</span><br></pre></td></tr></table></figure></li><li><p>获取最高等级值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select max(s.grade) from </span><br><span class="line">(select deptno,avg(sal) avgsal from emp group by deptno) t</span><br><span class="line">join salgrade s</span><br><span class="line">on t.avgsal between s.losal and s.hisal;</span><br></pre></td></tr></table></figure></li><li><p>联合上两张表 给出avgsal,dname,grade,满足平均值为最大值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select t.avgsal,s.grade,t.dname from </span><br><span class="line">(select d.dname dname,avg(e.sal) avgsal from emp e join dept d on e.deptno=d.deptno group by dname) t</span><br><span class="line">join salgrade s</span><br><span class="line">on t.avgsal between s.losal and s.hisal</span><br><span class="line">where</span><br><span class="line">s.grade=(select max(s.grade) from </span><br><span class="line">(select deptno,avg(sal) avgsal from emp group by deptno) t</span><br><span class="line">join salgrade s</span><br><span class="line">on t.avgsal between s.losal and s.hisal);</span><br></pre></td></tr></table></figure></li><li><p>取得比<strong>普通员工</strong>(员工代码没有在mgr字段上出现的)的<strong>最高薪水</strong>还要高的姓名</p><ol><li><p>先找到普通员工(注意not in (不能有null))<br><code>select * from emp where empno  not in (select distinct mgr from emp where mgr is not null);</code></p><pre><code>     2. 找出普通员工最高薪水</code></pre><p><code>select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null);</code></p></li><li><p>找出薪水高于1600</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select ename ,sal from emp </span><br><span class="line">where sal &gt; (select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null));</span><br></pre></td></tr></table></figure></li></ol></li></ol><p>​补充学习: <code>select ename,sal,(case job when &#39;manager&#39; then sal * 0.8 when &#39;salesman&#39; then sal*1.5 end) newsal from emp;</code></p><ol start="9"><li><p>取得薪水最高的前五</p></li><li><p>取得薪水最高的第六名到第十名</p></li><li><p>取得最后入职的5名员工</p></li><li><p>取得每个薪水等级有多少个员工</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select e.ename, e.sal, s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;</span><br><span class="line">select t.sgrade ,count(*) from (select e.ename, e.sal, s.grade sgrade from emp e join salgrade s on e.sal between s.losal and s.hisal) t group by t.sgrade;</span><br><span class="line">select count(*), s.grade </span><br><span class="line">from emp e join salgrade s on e.sal between s.losal and s.hisal</span><br><span class="line">group by s.grade;</span><br></pre></td></tr></table></figure></li><li><p>列出所有员工和领导的名字<br> 列出所有的领导,not in 领导就是员工(自连接)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select distinct a.empno,a.ename,b.mgr from emp a join emp b on a.empno =b.mgr;-- 所有的领导</span><br><span class="line">select ename from emp where ename not in (select distinct a.ename from emp a join emp b on a.empno =b.mgr);</span><br></pre></td></tr></table></figure></li><li><p>找出入职日期早于其直接领导的员工编号,姓名,部门名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">t.adno,</span><br><span class="line">t.aname,</span><br><span class="line">d.dname </span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">              SELECT</span><br><span class="line">              a.empno eno,</span><br><span class="line">              a.ename aname,</span><br><span class="line">              a.hiredate ahdate,</span><br><span class="line">              a.deptno adno,</span><br><span class="line">              b.hiredate bhdate </span><br><span class="line">              FROM</span><br><span class="line">              emp a</span><br><span class="line">              LEFT JOIN emp b ON a.mgr = b.empno </span><br><span class="line">          ) t</span><br><span class="line">JOIN dept d ON d.deptno = t.adno </span><br><span class="line">WHERE</span><br><span class="line">t.ahdate &lt; t.bhdate</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 老司机做法选出员工直接老板和各自的入职日期,通过where筛选</span><br><span class="line">select a.empno aempno, a.ename aename,d.dname ddname, b.empno bempno, b.ename bename</span><br><span class="line">from emp a join emp b on a.mgr = b.empno join dept d on d.deptno = a.deptno</span><br><span class="line">where a.hiredate&lt;b.hiredate;</span><br></pre></td></tr></table></figure></li><li><p>列出部门名称和这些部门员工信息,同时列出没有员工的部门<br><code>select d.dname,e.* from emp e right join dept d on e.deptno=d.deptno order by d.dname asc;</code></p></li><li><p>列出至少有5个员工的所有部门(什么这里select后可以有groupby没有的东西)<br><code>select dept.*,emp.deptno,count(*) from emp join dept on emp.deptno = dept.deptno group by dept.deptno having count(*) &gt;=5;</code></p></li><li><p>列出薪资比simith高的员工的个人信息<br><code>select * from emp where sal &gt; (select sal from emp where ename=&#39;simith&#39;);</code></p></li><li><p>列出所有clerk职位的员工姓名,部门名称,部门人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select e.ename ename,d.dname ddname, t.countall from emp e join dept d on d.deptno = e.deptno join (select e.deptno, count(*) countall from  emp e  group by e.deptno) t on t.deptno = d.deptno</span><br><span class="line">where job=&#x27;clerk&#x27; ;</span><br><span class="line">select e.deptno, count(*) countall from  emp e group by e.deptno;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>列出最低薪资大于1500的各工种及从事此工作的全部员工人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select job,min(sal) minsal,count(*) from emp group by job having minsal &gt;1500;</span><br></pre></td></tr></table></figure></li><li><p>在不知道部门编号的情况下列出sales部门的员工姓名<br> 这题又理解错误,emp的deptno是知道的,只有dept表中deptno不知道</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select deptno from dept where dname=&#x27;sales&#x27;;</span><br><span class="line">select ename from emp where deptno = ( select deptno from dept where dname=&#x27;sales&#x27;);</span><br></pre></td></tr></table></figure><ol start="21"><li><p>列出薪资高于公司平均薪资的所有员工,所在部门,上级领导,员工的工资等级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-- 注意用全连接找出king的信息</span><br><span class="line">SELECT</span><br><span class="line">e.mgr,</span><br><span class="line">e.ename,</span><br><span class="line">e.deptno,</span><br><span class="line">e2.ename boss,</span><br><span class="line">d.dname,</span><br><span class="line">s.grade </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">LEFT JOIN emp e2 ON e.mgr = e2.empno</span><br><span class="line">JOIN dept d ON d.deptno = e.deptno</span><br><span class="line">JOIN salgrade s ON e.sal BETWEEN s.losal </span><br><span class="line">AND s.hisal </span><br><span class="line">WHERE</span><br><span class="line">e.sal &gt; ( SELECT avg( sal ) FROM emp );</span><br></pre></td></tr></table></figure></li><li><p>列出与scott从事相同工作的所有员工及其部门名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">job </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">ename = &#x27;scott&#x27;;</span><br><span class="line">SELECT</span><br><span class="line">e.ename,</span><br><span class="line">d.dname,</span><br><span class="line">e.job </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">JOIN dept d ON e.deptno = d.deptno </span><br><span class="line">WHERE</span><br><span class="line">job = ( SELECT job FROM emp WHERE ename = &#x27;scott&#x27; );</span><br></pre></td></tr></table></figure></li><li><p>列出薪资等于部门30中员工的薪资的其他员工的姓名和薪金</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">sal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">deptno = 30;</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">ename,</span><br><span class="line">sal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">( sal IN ( SELECT DISTINCT sal FROM emp WHERE deptno = 30 ) ) AND deptno &lt;&gt; 30;</span><br></pre></td></tr></table></figure></li><li><p>列出薪资高于部门30中员工的薪资的其他员工的姓名和薪金</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">ename,</span><br><span class="line">sal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">WHERE</span><br><span class="line">sal &gt; ( SELECT max( t.sal ) FROM ( SELECT DISTINCT sal FROM emp WHERE deptno = 30 ) t );</span><br></pre></td></tr></table></figure><ol start="25"><li>列出在每个部门工作的员工数量,平均工资和平均服务期限(工龄)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 所有、每个这类关键字，一般需要全连接</span><br><span class="line">SELECT</span><br><span class="line">e.deptno,</span><br><span class="line">count( e.ename ) totalmember,</span><br><span class="line">IFNULL(avg( sal ) ,0) avgsal,</span><br><span class="line">IFNULL(avg(( ( TO_DAYS( now( ) ) - TO_DAYS( hiredate ) ) / 356 )),0) year</span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">RIGHT JOIN dept d ON e.deptno = d.deptno </span><br><span class="line">GROUP BY</span><br><span class="line">deptno;</span><br></pre></td></tr></table></figure><ol start="26"><li><p>列出所有员工的姓名,部门名称,工资<br><code>select e.ename,d.dname,e.sal from emp e join dept d on e.deptno=d.deptno;</code></p></li><li><p>列出所有部门的详细信息和人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select d.deptno,d.dnae,d.loc,count(e.ename) from emp e right join dept d on e.deptno=d.deptno group by d.deptno,d.dname,d.loc;</span><br></pre></td></tr></table></figure></li><li><p>列出各个工作岗位最低工资和符合最低工资的人姓名<br>(判空与去重)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">t.job,</span><br><span class="line">e.ename,</span><br><span class="line">t.minsal </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">JOIN ( SELECT job, min( sal ) minsal FROM emp GROUP BY job ) t ON e.job = t.job </span><br><span class="line">AND e.sal = t.minsal </span><br><span class="line">ORDER BY</span><br><span class="line">t.minsal ASC;</span><br></pre></td></tr></table></figure></li><li><p>获取各个部门mgr的最低薪资</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">deptno,</span><br><span class="line">min( sal ) minsal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">where</span><br><span class="line">job=&#x27;manager&#x27;</span><br><span class="line">GROUP BY</span><br><span class="line">deptno;</span><br></pre></td></tr></table></figure><ol start="30"><li><p>取出所有员工年薪,由低到高排序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">ename,</span><br><span class="line">sal * 12+ ifnull( comm, 0 ) yearsal </span><br><span class="line">FROM</span><br><span class="line">emp </span><br><span class="line">ORDER BY</span><br><span class="line">yearsal ASC;</span><br></pre></td></tr></table></figure></li><li><p>取出员工领导薪水超过3000的员工名称和领导名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">e.ename,</span><br><span class="line">e2.ename leader</span><br><span class="line">FROM</span><br><span class="line">emp e JOIN emp e2 ON e.mgr = e2.empno AND e2.sal &gt; 3000;</span><br></pre></td></tr></table></figure></li><li><p>取出含有s的部门,给出此部门的工资合计,部门人数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">d.dname empname,</span><br><span class="line">count( e.ename ) totalpersons,</span><br><span class="line">SUM( ifnull( e.sal, 0 ) ) sumsal </span><br><span class="line">FROM</span><br><span class="line">emp e</span><br><span class="line">RIGHT JOIN dept d ON e.deptno = d.deptno </span><br><span class="line">WHERE</span><br><span class="line">d.dname LIKE &#x27;%s%&#x27; </span><br><span class="line">GROUP BY</span><br><span class="line">d.dname;</span><br></pre></td></tr></table></figure></li><li><p>给任职超过30年的人加薪10%;<br>工作时间计算公式(年)<br>(( TO_DAYS( now( ) ) - TO_DAYS( hiredate ) ) &#x2F; 365 ) year</p></li></ol><p>create table emp_bak as select * from emp;</p><ol start="34"><li>面试一下</li></ol><p><strong>初始化数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists s;</span><br><span class="line">drop table if exists c;</span><br><span class="line">drop table if exists sc; </span><br><span class="line">create table s(</span><br><span class="line">    sno int(10) primary key,</span><br><span class="line">    sname varchar(14)</span><br><span class="line">);</span><br><span class="line">create table c(</span><br><span class="line">    cno int(10) primary key,</span><br><span class="line">    cname varchar(14),</span><br><span class="line">    cteacher varchar(14)</span><br><span class="line">);</span><br><span class="line">create table sc(</span><br><span class="line">    sno int(10),  </span><br><span class="line">    cno int(10),</span><br><span class="line">    scgrade int(10),</span><br><span class="line">    primary key(sno,cno)</span><br><span class="line">);</span><br><span class="line">insert into s(sno,sname) values(1,&#x27;a&#x27;);</span><br><span class="line">insert into s(sno,sname) values(2,&#x27;b&#x27;);</span><br><span class="line">insert into s(sno,sname) values(3,&#x27;c&#x27;);</span><br><span class="line">insert into s(sno,sname) values(4,&#x27;d&#x27;); </span><br><span class="line"></span><br><span class="line">insert into c(cno,cname,cteacher) values(1,&#x27;java&#x27;,&#x27;王老师&#x27;);</span><br><span class="line">insert into c(cno,cname,cteacher) values(2,&#x27;C++&#x27;,&#x27;张老师&#x27;);</span><br><span class="line">insert into c(cno,cname,cteacher) values(3,&#x27;C#&#x27;,&#x27;李老师&#x27;);</span><br><span class="line">insert into c(cno,cname,cteacher) values(4,&#x27;mysql&#x27;,&#x27;周老师&#x27;);</span><br><span class="line">insert into c(cno,cname,cteacher) values(5,&#x27;oracle&#x27;,&#x27;黎明&#x27;); </span><br><span class="line"></span><br><span class="line">insert into sc(sno,cno,scgrade) values(1,1,50);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(1,2,50);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(1,3,50);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(2,2,80);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(2,3,70);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(2,4,59);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(3,1,60);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(3,2,61);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(3,3,99);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(3,4,100);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(3,5,52);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(4,3,82);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(4,4,99);</span><br><span class="line">insert into sc(sno,cno,scgrade) values(4,5,40);</span><br></pre></td></tr></table></figure><blockquote><p>有3个表s(学生表),c(课程表),sc(学生选课表)<br>s(sno,sname) 代表 (学号,姓名)<br>c(cno,cname,cteacher) 代表(课号,课名,教师)<br>sc(sno,cno,scgrade)代表 (学号,课号,成绩)</p></blockquote><ol><li><p>找出没选过”黎明”老师的所有学生姓名<br>1. 肯定要用补集求解,所以先求黎明苏所在表的相关信息<br>select cno,cname from c where cteacher&#x3D;’黎明’;<br>2. 选了黎明的人<br>select sno from sc where cno &#x3D; (select cno from c where cteacher&#x3D;’黎明’);<br> 3. 没选黎明的人<br> select sname from s where sno not in (select sno from sc where cno &#x3D; (select cno from c where cteacher&#x3D;’黎明’))</p></li><li><p>列出2门以上(含2门) 不及格学生姓名及他的所有成绩的平均成绩<br> 1. 先选出2门不及格的学生<br><br> <code>    select sno from sc where scgrade &lt; 60 group by sno having count(*)&gt;=2 ;</code><br><br> 2. 连接s取姓名<br><br> <code>select s.sname from sc join s on sc.sno = s.sno where sc.scgrade &lt; 60 group by s.sname having count(*)&gt;=2 ;</code><br><br> 3. 算出每个学生的平均成绩跟不及格的姓名连接(下面这个做法不行,因为其他成绩已经过滤掉了,只会求不及格成绩的平均线)<br>   <code>select s.sname name, avg(sc.scgrade) avgscore from sc join s on sc.sno = s.sno where sc.scgrade &lt; 60 group by s.sname having count(*)&gt;=2 ;</code></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 求出所有学生平均成绩</span><br><span class="line">select sc.sno,avg(sc.scgrade) avgscore from sc group  by sc.sno;</span><br><span class="line">select sno,avg(sc.scgrade) avgscore from sc group  by sno;</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">t1.NAME NAME,</span><br><span class="line">t2.avgscore avgscore </span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">s.sname NAME,</span><br><span class="line">s.sno sno </span><br><span class="line">FROM</span><br><span class="line">sc</span><br><span class="line">JOIN s ON sc.sno = s.sno </span><br><span class="line">WHERE</span><br><span class="line">sc.scgrade &lt; 60 GROUP BY NAME, sno HAVING count( * ) &gt;= 2 </span><br><span class="line">) t1</span><br><span class="line">JOIN ( SELECT sc.sno sno, avg( sc.scgrade ) avgscore FROM sc GROUP BY sc.sno ) t2 ON t1.sno = t2.sno </span><br><span class="line">GROUP BY</span><br><span class="line">t1.sno;</span><br></pre></td></tr></table></figure><ol start="3"><li>即学过1号课程又学过2号课程所有学生的姓名<br>1. 学过1号课程的所有学生(sname,cno)<br><code>select s.sname sname,sc.cno cno from sc join s on s.sno=sc.sno where cno = 1;</code><br>2. 学过2号课程的所有学生(sname,cno)<br><code>select s.sname sname,sc.cno cno from sc join s on s.sno=sc.sno where cno=2;</code><br>3. 求交集</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select t1.sname sname from (select s.sname sname,sc.cno cno from sc </span><br><span class="line">join s on s.sno=sc.sno where cno = 1) t1 </span><br><span class="line">join (select s.sname sname,sc.cno cno from sc join s on s.sno=sc.sno where cno=2) t2 on t1.sname = t2.sname;</span><br></pre></td></tr></table></figure><p><strong>总结</strong><br><strong>作业到此完成,所有的问题都可分成小问题来拼出来,这个过程中除了注意sql的语法,mysql的特殊语法,还要考虑判空,去重,是否要全连接等.</strong><br><strong>查询数据的思路</strong></p><ol><li>我需要哪些字段?这些字段分别在那些表里?这些表靠什么连接?</li><li>涉及多表字段(自连接也算) 要先分开查询,查询时要注意判空与去重,以及选用合适的过滤方法和分组函数.</li><li>连接时选用内还是外连接,是要用增加查询字段,进行子查询,还是表连接要先后判断一下.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql&quot;&gt;&lt;a href=&quot;#Mysql&quot; class=&quot;headerlink&quot; title=&quot;Mysql&quot;&gt;&lt;/a&gt;Mysql&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;伟大滴麦色可友，养活互联网企业的神器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=</summary>
      
    
    
    
    
  </entry>
  
</feed>
